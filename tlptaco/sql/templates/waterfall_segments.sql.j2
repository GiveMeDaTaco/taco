-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--

{% for segment in segments %}
-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    '{{ segment.name }}' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM {{ eligibility_table }} c
WHERE {{ segment.summary_column }}
  AND {{ pre_filter }}
  {% for prev_segment in segments[:loop.index0] %}
    AND NOT {{ prev_segment.summary_column }}
  {%- endfor %}

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM {{ eligibility_table }} c
    WHERE {{ pre_filter }}
    {% if loop.index0 > 0 %}
      AND {% for prev_segment in segments[:loop.index0] %}
          NOT {{ prev_segment.summary_column }}
          {{ "AND " if not loop.last }}
      {%- endfor %}
    {% endif %}
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    {% for uid in unique_identifiers %}{{ uid.split('.')[-1] }}{{ "," if not loop.last }}{%- endfor %},
    {% for col in segment.checks %}{{ col }}{{ "," if not loop.last }}{% endfor %}
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  '{{ segment.name }}' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    {%- for part in ['unique_drops', 'incremental_drops', 'remaining', 'cumulative_drops'] %}
    SELECT
      '{{ part }}' AS stat_name,
      check_name,
      cntr
    FROM (
        {% for col in segment.checks %}
        SELECT
          '{{ col }}' as check_name,
          {%- if part == 'unique_drops' %} SUM(CASE WHEN {{ col }} = 0 THEN 1 ELSE 0 END)
          {%- elif part == 'incremental_drops' %} SUM(CASE WHEN {{ col }} = 0 {%- for prev in segment.checks[:loop.index0] %} AND {{ prev }} = 1{%- endfor %} THEN 1 ELSE 0 END)
          {%- elif part == 'remaining' %} SUM(CASE WHEN {{ col }} = 1 {%- for prev in segment.checks[:loop.index0] %} AND {{ prev }} = 1{%- endfor %} THEN 1 ELSE 0 END)
          {%- elif part == 'cumulative_drops' %} COUNT(*) - SUM(CASE WHEN {{ col }} = 1 {%- for prev in segment.checks[:loop.index0] %} AND {{ prev }} = 1{%- endfor %} THEN 1 ELSE 0 END)
          {%- endif %} AS cntr
        FROM flags
        {% if not loop.last %}UNION ALL{% endif %}
        {% endfor %}
    ) q
    {%- if not loop.last %}
    UNION ALL
    {% endif %}
    {%- endfor %}
) metrics

{%- if not loop.last %}
UNION ALL
{% endif %}
{%- endfor %};