-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--

{% for segment in segments %}
-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    '{{ segment.name }}' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM {{ eligibility_table }} c
WHERE {{ segment.summary_column }}
  AND {{ pre_filter }}
  {% for prev_segment in segments[:loop.index0] %}
    AND NOT {{ prev_segment.summary_column }}
  {%- endfor %}

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM {{ eligibility_table }} c
    WHERE {{ pre_filter }}
    {% if loop.index0 > 0 %}
      AND {% for prev_segment in segments[:loop.index0] %}
          NOT {{ prev_segment.summary_column }}
          {{ "AND " if not loop.last }}
      {%- endfor %}
    {% endif %}
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    {% for uid in unique_identifiers %}{{ uid.split('.')[-1] }}{{ "," if not loop.last }}{%- endfor %},
    {% for col in segment.checks %}{{ col }}{{ "," if not loop.last }}{% endfor %}
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  '{{ segment.name }}' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    {%- for col in segment.checks %}
    SELECT
      'unique_drops' AS stat_name,
      '{{ col }}' AS check_name,
      SUM(CASE WHEN {{ col }} = 0
               AND ( {%- for other in segment.checks if other != col %}{{ other }} = 1{%- if not loop.last %} AND {% endif %}{% endfor %} )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    {%- if not loop.last %}UNION ALL{% endif %}
    {%- endfor %}

    UNION ALL

    -- Drop Incremental
    {%- for col in segment.checks %}
    SELECT
      'incremental_drops' AS stat_name,
      '{{ col }}' AS check_name,
      SUM(CASE WHEN {{ col }} = 0
               {%- for prev in segment.checks[:loop.index0] %}AND {{ prev }} = 1 {%- endfor %}
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    {%- if not loop.last %}UNION ALL{% endif %}
    {%- endfor %}

    UNION ALL

    -- Drop Cumulative
    {%- for col in segment.checks %}
    SELECT
      'cumulative_drops' AS stat_name,
      '{{ col }}' AS check_name,
      COUNT(*) - SUM(CASE WHEN {{ col }} = 1
                         {%- for prev in segment.checks[:loop.index0] %}AND {{ prev }} = 1{%- endfor %}
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    {%- if not loop.last %}UNION ALL{% endif %}
    {%- endfor %}

    UNION ALL

    -- Regain If No Scrub
    {%- for col in segment.checks %}
    SELECT
      'regain' AS stat_name,
      '{{ col }}' AS check_name,
      SUM(CASE WHEN {{ col }} = 0
               AND ( {%- for other in segment.checks if other != col %}{{ other }} = 1{%- if not loop.last %} AND {% endif %}{% endfor %} )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    {%- if not loop.last %}UNION ALL{% endif %}
    {%- endfor %}

    UNION ALL

    -- Remaining
    {%- for col in segment.checks %}
    SELECT
      'remaining' AS stat_name,
      '{{ col }}' AS check_name,
      SUM(CASE WHEN {{ col }} = 1
               {%- for prev in segment.checks[:loop.index0] %}AND {{ prev }} = 1{%- endfor %}
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    {%- if not loop.last %}UNION ALL{% endif %}
    {%- endfor %}
) metrics

{%- if not loop.last %}
UNION ALL
{% endif %}
{%- endfor %};