-- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    {%- for col in columns %}
    {%- if column_types and column_types.get(col) %}
    CAST({{ col }} AS {{ column_types[col] }}) AS {{ col.split('.')[-1] }}
    {%- else %}
    {{ col }}
    {%- endif %}{{ ',' if not loop.last else '' }}
    {%- endfor %},
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            {%- for c in cases %}
            WHEN {{ c.condition }} THEN '{{ c.template }}'
            {%- endfor %}
            ELSE NULL
        END AS template_id
    FROM {{ eligibility_table }} c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
{%- if unique_on %}
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY {{ unique_on|join(', ') }} ORDER BY template_id) = 1
{%- endif %};