-- Failed Records dump generated by tlptaco

-- Context variables supplied by OutputEngine
--   eligibility_table        : str      – name of smart eligibility table (aliased as c)
--   unique_identifiers       : list[str]– columns that uniquely identify a record
--   failed_flag_checks       : list[dict{ name , sql , rank }]
--   unbucketed_channels      : list[dict{ channel , pre_filter , no_template_condition , rank }]
--   first_reason_only        : bool     – if true keep only 1st failure reason per ID set

{% set id_cols = unique_identifiers %}

WITH failures AS (
{% for chk in failed_flag_checks %}
    SELECT
        {{ id_cols | join(', ') }},
        '{{ chk.name }}'    AS fail_reason,
        '{{ chk.sql | replace("'", "''") }}' AS fail_logic,
        {{ chk.rank }}       AS reason_rank
    FROM {{ eligibility_table }} c
    WHERE c.{{ chk.name }} = 0
    {% if not loop.last or unbucketed_channels %}UNION ALL{% endif %}
{% endfor %}

{% for ub in unbucketed_channels %}
    SELECT
        {{ id_cols | join(', ') }},
        '{{ ub.channel }}_unbucketed' AS fail_reason,
        '{{ ub.no_template_condition | replace("'", "''") }}' AS fail_logic,
        {{ ub.rank }}                 AS reason_rank
    FROM {{ eligibility_table }} c
    WHERE {{ ub.pre_filter }}
      AND {{ ub.no_template_condition }}
    {% if not loop.last %}UNION ALL{% endif %}
{% endfor %}
)

SELECT *
FROM failures
{% if first_reason_only %}
QUALIFY ROW_NUMBER() OVER (PARTITION BY {{ id_cols | join(', ') }} ORDER BY reason_rank) = 1
{% endif %};
