"""
Pydantic models for tlptaco configuration with built-in validation.
"""
from pydantic import BaseModel, model_validator, field_validator, ConfigDict
from typing import List, Dict, Optional, Any, Union
import re

# --- Base Models ---

class ConditionCheck(BaseModel):
    # name is autogenerated if not provided
    name: Optional[str] = None
    sql: str
    description: Optional[str] = None

class TemplateConditions(BaseModel):
    """
    Conditions for a given channel or main: a BA (base) filter and one or more segments.
    Users may define segments directly alongside BA; legacy 'others' key is also supported.
    """
    # allow legacy 'others' key and arbitrary segment keys
    model_config = ConfigDict(extra="allow")
    BA: List[ConditionCheck]
    # segments: mapping segment_name -> list of checks
    segments: Dict[str, List[ConditionCheck]] = {}

    @model_validator(mode='before')
    def parse_segments(cls, data):  # type: ignore[name-defined]
        # Extract user-defined segments: legacy 'others' dict or keys beside 'BA'
        if not isinstance(data, dict):
            return data
        raw = data.copy()
        segs: Dict[str, Any] = {}
        # legacy 'others'
        if 'others' in raw:
            old = raw.pop('others') or {}
            if isinstance(old, dict):
                segs.update(old)
        # new-style: any key != 'BA'
        for key in list(raw.keys()):
            if key == 'BA':
                continue
            # treat as segment
            segs[key] = raw.pop(key)
        raw['segments'] = segs
        return raw
    
    @property
    def others(self) -> Dict[str, List[ConditionCheck]]:
        """Legacy alias for segments mapping."""
        return self.segments

class ConditionsConfig(BaseModel):
    """
    All conditions configuration: main BA filters and per-channel BA filters + segments.
    Automatically assigns unique names to each check and enforces structure.
    """
    main: TemplateConditions
    channels: Dict[str, TemplateConditions]

    @model_validator(mode='after')
    def assign_names_and_validate(cls, self) -> 'ConditionsConfig':  # type: ignore[name-defined]
        # Assign autogenerated names for main BA checks
        # main channel key is 'main'
        # BA filters for main
        for idx, chk in enumerate(self.main.BA, start=1):
            chk.name = f"main_BA_{idx}"
        # main should not have any segments
        if self.main.segments:
            raise ValueError("'main' conditions may not include segments; only BA checks are allowed")
        # Process each channel: assign names for BA filters and optional segments
        for channel, tmpl in self.channels.items():
            # BA filters for channel
            for idx, chk in enumerate(tmpl.BA, start=1):
                chk.name = f"{channel}_BA_{idx}"
            # segments for channel (optional)
            for seg_name, checks in tmpl.segments.items():
                for idx, chk in enumerate(checks, start=1):
                    chk.name = f"{channel}_{seg_name}_{idx}"
        return self

class TableConfig(BaseModel):
    name: str
    alias: str
    sql: Optional[str] = None  # Made optional as it might not always be used
    join_type: Optional[str]
    join_conditions: Optional[str]
    where_conditions: Optional[str]
    unique_index: Optional[str]
    collect_stats: Optional[List[str]]
    # Ensure alias is a valid identifier (starts with letter/_ and contains only alphanumeric/_)
    @field_validator('alias', mode='before')
    def validate_alias(cls, v):  # type: ignore[name-defined]
        if not isinstance(v, str) or not re.match(r'^[A-Za-z_][A-Za-z0-9_]*$', v):
            raise ValueError(
                f"Invalid alias '{v}'. Must start with a letter or underscore and contain only alphanumeric characters or underscores."
            )
        return v

class OutputOptions(BaseModel):
    format: str
    additional_arguments: Optional[Dict[str, Any]] = {}
    custom_function: Optional[str]

# --- Config Sections with Validation ---

class EligibilityConfig(BaseModel):
    eligibility_table: str
    conditions: ConditionsConfig
    tables: List[TableConfig]
    unique_identifiers: List[str]

    @model_validator(mode='after')
    def check_identifier_aliases_are_valid(self) -> 'EligibilityConfig':
        valid_aliases = {t.alias for t in self.tables}
        for identifier in self.unique_identifiers:
            if '.' in identifier:
                alias = identifier.split('.')[0]
                if alias not in valid_aliases:
                    raise ValueError(
                        f"In 'eligibility.unique_identifiers', '{identifier}' uses an invalid alias '{alias}'. "
                        f"Valid aliases are: {valid_aliases}"
                    )
        return self
    # Validate eligibility_table naming: identifier or schema.table
    @field_validator('eligibility_table', mode='before')
    def validate_eligibility_table(cls, v):  # type: ignore[name-defined]
        if not isinstance(v, str) or not re.match(
            r'^[A-Za-z_][A-Za-z0-9_]*(\.[A-Za-z_][A-Za-z0-9_]*)?$', v
        ):
            raise ValueError(
                f"Invalid eligibility_table '{v}'. Must be a valid identifier or schema.table."
            )
        return v

class WaterfallConfig(BaseModel):
    output_directory: str
    count_columns: List[Union[str, List[str]]]

class OutputChannelConfig(BaseModel):
    columns: List[str]
    file_location: str
    file_base_name: str
    output_options: OutputOptions
    unique_on: Optional[List[str]] = []

    @model_validator(mode='after')
    def check_unique_on_are_in_columns(cls, self) -> 'OutputChannelConfig':  # type: ignore[name-defined]
        """
        Ensure that simple unique_on column names exist in the output columns.
        If the unique_on element contains a dot, assume it's a qualified identifier and skip validation.
        """
        if self.unique_on:
            # If all unique_on entries are unqualified (no dot), enforce subset
            simple_keys = [u for u in self.unique_on if '.' not in u]
            if simple_keys:
                missing = set(simple_keys) - set(self.columns)
                if missing:
                    raise ValueError(
                        f"'unique_on' columns {missing} are not present in the selected 'columns'."
                    )
        return self

class OutputConfig(BaseModel):
    channels: Dict[str, OutputChannelConfig]

class LoggingConfig(BaseModel):
    level: str
    file: Optional[str]
    debug_file: Optional[str]

class DatabaseConfig(BaseModel):
    host: str
    user: str
    password: Optional[str]
    logmech: Optional[str] = "KRB5"

# --- Top-Level App Config with Cross-Section Validation ---

class AppConfig(BaseModel):
    """
    Top-level application configuration, including offer code and campaign metadata.
    """
    # Offer code displayed in CLI progress bar (defaults to 'Running')
    offer_code: str = "Running"
    # Campaign metadata for waterfall report header
    campaign_planner: str = ""
    lead: str = ""
    logging: LoggingConfig
    database: DatabaseConfig
    eligibility: EligibilityConfig
    waterfall: WaterfallConfig
    output: OutputConfig

    @model_validator(mode='after')
    def check_cross_config_dependencies(self) -> 'AppConfig':
        # 1. Check WaterfallConfig -> EligibilityConfig dependency
        valid_ids = {uid.split('.')[-1] for uid in self.eligibility.unique_identifiers}
        waterfall_ids = set()
        for item in self.waterfall.count_columns:
            cols = [item] if isinstance(item, str) else item
            for col in cols:
                waterfall_ids.add(col.split('.')[-1])
        if not waterfall_ids.issubset(valid_ids):
            invalid_cols = waterfall_ids - valid_ids
            raise ValueError(
                f"Waterfall 'count_columns' contain invalid identifiers: {invalid_cols}. "
                f"They must be a subset of eligibility 'unique_identifiers': {valid_ids}"
            )

        # 2. Check OutputConfig -> EligibilityConfig dependency (for aliases)
        valid_aliases = {t.alias for t in self.eligibility.tables}
        for channel, out_cfg in self.output.channels.items():
            for column in out_cfg.columns:
                if '.' in column:
                    alias = column.split('.')[0]
                    if alias not in valid_aliases:
                        raise ValueError(
                            f"In output channel '{channel}', column '{column}' uses an invalid alias '{alias}'. "
                            f"Valid aliases are: {valid_aliases}"
                        )
        return self
