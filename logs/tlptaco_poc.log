ℹ️ [19:42:56] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [19:42:56] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [19:42:56] root INFO: Calculation complete: 3 steps.
ℹ️ [19:42:56] root INFO: Calculating the number of waterfall steps.
ℹ️ [19:42:56] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [19:42:56] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [19:42:56] root INFO: Calculating the number of output steps.
ℹ️ [19:42:56] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [19:42:56] root INFO: Preparing logic for channel 'email'
ℹ️ [19:42:56] root INFO: Preparing logic for channel 'sms'
ℹ️ [19:42:56] root INFO: Preparing logic for channel 'push'
ℹ️ [19:42:56] root INFO: Calculation complete: 3 steps (files).
ℹ️ [19:42:56] root INFO: Using cached SQL statements.
ℹ️ [19:42:56] root INFO: Dropping existing table eligibility_poc
ℹ️ [19:42:56] root INFO: Executing SQL statement
ℹ️ [19:42:58] root INFO: SQL execution finished in 1.23s
ℹ️ [19:42:58] root INFO: Executing eligibility SQL statement
ℹ️ [19:42:58] root INFO: Executing SQL statement
ℹ️ [19:42:58] root INFO: SQL execution finished in 0.49s
ℹ️ [19:42:58] root INFO: Executing eligibility SQL statement
ℹ️ [19:42:58] root INFO: Executing SQL statement
ℹ️ [19:42:58] root INFO: SQL execution finished in 0.20s
ℹ️ [19:42:58] root INFO: Using cached waterfall steps.
ℹ️ [19:42:58] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [19:42:58] root INFO: Fetching data to DataFrame
ℹ️ [19:42:59] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.17s
❌ [19:42:59] root ERROR: Waterfall grouping 'customer_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [19:42:59] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [19:42:59] root INFO: Fetching data to DataFrame
ℹ️ [19:42:59] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.10s
❌ [19:42:59] root ERROR: Waterfall grouping 'customer_id_account_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [19:42:59] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [19:42:59] root INFO: Fetching data to DataFrame
ℹ️ [19:42:59] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.10s
❌ [19:42:59] root ERROR: Waterfall grouping 'region_id_segment_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [19:42:59] root INFO: Using cached output steps.
ℹ️ [19:42:59] root INFO: Running output job for channel email
ℹ️ [19:42:59] root INFO: Fetching data to DataFrame
ℹ️ [19:42:59] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.17s
ℹ️ [19:42:59] root INFO: Fetched 17 rows for channel email
ℹ️ [19:42:59] root INFO: Writing output file for channel email to reports/poc/email/email_list.csv
ℹ️ [19:42:59] root INFO: Running output job for channel sms
ℹ️ [19:42:59] root INFO: Fetching data to DataFrame
ℹ️ [19:42:59] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.17s
ℹ️ [19:42:59] root INFO: Fetched 8 rows for channel sms
ℹ️ [19:42:59] root INFO: Writing output file for channel sms to reports/poc/sms/sms_list.parquet
ℹ️ [19:42:59] root INFO: Running output job for channel push
ℹ️ [19:42:59] root INFO: Fetching data to DataFrame
ℹ️ [19:42:59] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.15s
ℹ️ [19:42:59] root INFO: Fetched 17 rows for channel push
ℹ️ [19:42:59] root INFO: Writing output file for channel push to reports/poc/push/push_list.xlsx
ℹ️ [19:42:59] root INFO: Cleaning up DB connection
ℹ️ [20:00:56] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [20:00:56] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [20:00:56] root INFO: Calculation complete: 3 steps.
ℹ️ [20:00:56] root INFO: Calculating the number of waterfall steps.
ℹ️ [20:00:56] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [20:00:56] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [20:00:56] root INFO: Calculating the number of output steps.
ℹ️ [20:00:56] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [20:00:56] root INFO: Preparing logic for channel 'email'
ℹ️ [20:00:56] root INFO: Preparing logic for channel 'sms'
ℹ️ [20:00:56] root INFO: Preparing logic for channel 'push'
ℹ️ [20:00:56] root INFO: Calculation complete: 3 steps (files).
ℹ️ [20:00:56] root INFO: Using cached SQL statements.
ℹ️ [20:00:56] root INFO: Dropping existing table eligibility_poc
ℹ️ [20:00:56] root INFO: Executing SQL statement
ℹ️ [20:00:57] root INFO: SQL execution finished in 1.31s
ℹ️ [20:00:57] root INFO: Executing eligibility SQL statement
ℹ️ [20:00:57] root INFO: Executing SQL statement
ℹ️ [20:00:58] root INFO: SQL execution finished in 0.52s
ℹ️ [20:00:58] root INFO: Executing eligibility SQL statement
ℹ️ [20:00:58] root INFO: Executing SQL statement
ℹ️ [20:00:58] root INFO: SQL execution finished in 0.19s
ℹ️ [20:00:58] root INFO: Using cached waterfall steps.
ℹ️ [20:00:58] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [20:00:58] root INFO: Fetching data to DataFrame
ℹ️ [20:00:58] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.20s
❌ [20:00:58] root ERROR: Waterfall grouping 'customer_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [20:00:58] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [20:00:58] root INFO: Fetching data to DataFrame
ℹ️ [20:00:58] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.11s
❌ [20:00:58] root ERROR: Waterfall grouping 'customer_id_account_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [20:00:58] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [20:00:58] root INFO: Fetching data to DataFrame
ℹ️ [20:00:59] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.11s
❌ [20:00:59] root ERROR: Waterfall grouping 'region_id_segment_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [20:00:59] root INFO: Using cached output steps.
ℹ️ [20:00:59] root INFO: Running output job for channel email
ℹ️ [20:00:59] root INFO: Fetching data to DataFrame
ℹ️ [20:00:59] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [20:00:59] root INFO: Fetched 17 rows for channel email
ℹ️ [20:00:59] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [20:00:59] root INFO: Running output job for channel sms
ℹ️ [20:00:59] root INFO: Fetching data to DataFrame
ℹ️ [20:00:59] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.20s
ℹ️ [20:00:59] root INFO: Fetched 8 rows for channel sms
ℹ️ [20:00:59] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [20:00:59] root INFO: Running output job for channel push
ℹ️ [20:00:59] root INFO: Fetching data to DataFrame
ℹ️ [20:00:59] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [20:00:59] root INFO: Fetched 17 rows for channel push
ℹ️ [20:00:59] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [20:00:59] root INFO: Cleaning up DB connection
ℹ️ [20:04:07] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [20:04:07] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [20:04:07] root INFO: Calculation complete: 3 steps.
ℹ️ [20:04:07] root INFO: Calculating the number of waterfall steps.
ℹ️ [20:04:07] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [20:04:07] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [20:04:07] root INFO: Calculating the number of output steps.
ℹ️ [20:04:07] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [20:04:07] root INFO: Preparing logic for channel 'email'
ℹ️ [20:04:07] root INFO: Preparing logic for channel 'sms'
ℹ️ [20:04:07] root INFO: Preparing logic for channel 'push'
ℹ️ [20:04:07] root INFO: Calculation complete: 3 steps (files).
ℹ️ [20:04:07] root INFO: Using cached SQL statements.
ℹ️ [20:04:07] root INFO: Dropping existing table eligibility_poc
ℹ️ [20:04:07] root INFO: Executing SQL statement
ℹ️ [20:04:08] root INFO: SQL execution finished in 1.41s
ℹ️ [20:04:08] root INFO: Executing eligibility SQL statement
ℹ️ [20:04:08] root INFO: Executing SQL statement
ℹ️ [20:04:09] root INFO: SQL execution finished in 0.52s
ℹ️ [20:04:09] root INFO: Executing eligibility SQL statement
ℹ️ [20:04:09] root INFO: Executing SQL statement
ℹ️ [20:04:09] root INFO: SQL execution finished in 0.19s
ℹ️ [20:04:09] root INFO: Using cached waterfall steps.
ℹ️ [20:04:09] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [20:04:09] root INFO: Fetching data to DataFrame
ℹ️ [20:04:09] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.24s
❌ [20:04:09] root ERROR: Waterfall grouping 'customer_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [20:04:09] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [20:04:09] root INFO: Fetching data to DataFrame
ℹ️ [20:04:09] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.09s
❌ [20:04:09] root ERROR: Waterfall grouping 'customer_id_account_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [20:04:09] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [20:04:09] root INFO: Fetching data to DataFrame
ℹ️ [20:04:09] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.11s
❌ [20:04:09] root ERROR: Waterfall grouping 'region_id_segment_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [20:04:09] root INFO: Using cached output steps.
ℹ️ [20:04:09] root INFO: Running output job for channel email
ℹ️ [20:04:09] root INFO: Fetching data to DataFrame
ℹ️ [20:04:10] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [20:04:10] root INFO: Fetched 17 rows for channel email
ℹ️ [20:04:10] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [20:04:10] root INFO: Running output job for channel sms
ℹ️ [20:04:10] root INFO: Fetching data to DataFrame
ℹ️ [20:04:10] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [20:04:10] root INFO: Fetched 8 rows for channel sms
ℹ️ [20:04:10] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [20:04:10] root INFO: Running output job for channel push
ℹ️ [20:04:10] root INFO: Fetching data to DataFrame
ℹ️ [20:04:10] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [20:04:10] root INFO: Fetched 17 rows for channel push
ℹ️ [20:04:10] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [20:04:10] root INFO: Cleaning up DB connection
ℹ️ [20:25:52] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [20:25:52] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [20:25:52] root INFO: Calculation complete: 3 steps.
ℹ️ [20:25:52] root INFO: Calculating the number of waterfall steps.
ℹ️ [20:25:52] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [20:25:52] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [20:25:52] root INFO: Calculating the number of output steps.
ℹ️ [20:25:52] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [20:25:52] root INFO: Preparing logic for channel 'email'
ℹ️ [20:25:52] root INFO: Preparing logic for channel 'sms'
ℹ️ [20:25:52] root INFO: Preparing logic for channel 'push'
ℹ️ [20:25:52] root INFO: Calculation complete: 3 steps (files).
ℹ️ [20:25:52] root INFO: Using cached SQL statements.
ℹ️ [20:25:52] root INFO: Dropping existing table eligibility_poc
ℹ️ [20:25:52] root INFO: Executing SQL statement
ℹ️ [20:25:53] root INFO: SQL execution finished in 1.34s
ℹ️ [20:25:53] root INFO: Executing eligibility SQL statement
ℹ️ [20:25:53] root INFO: Executing SQL statement
ℹ️ [20:25:54] root INFO: SQL execution finished in 0.53s
ℹ️ [20:25:54] root INFO: Executing eligibility SQL statement
ℹ️ [20:25:54] root INFO: Executing SQL statement
ℹ️ [20:25:54] root INFO: SQL execution finished in 0.19s
ℹ️ [20:25:54] root INFO: Using cached waterfall steps.
ℹ️ [20:25:54] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [20:25:54] root INFO: Fetching data to DataFrame
❌ [20:25:54] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS value
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS value
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:25:55] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [20:25:55] root INFO: Fetching data to DataFrame
❌ [20:25:55] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,account_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS value
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,account_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS value
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:25:55] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [20:25:55] root INFO: Fetching data to DataFrame
❌ [20:25:55] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    region_id,segment_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS value
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    region_id,segment_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS value
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:25:55] root INFO: Using cached output steps.
ℹ️ [20:25:55] root INFO: Running output job for channel email
ℹ️ [20:25:55] root INFO: Fetching data to DataFrame
ℹ️ [20:25:56] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [20:25:56] root INFO: Fetched 17 rows for channel email
ℹ️ [20:25:56] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [20:25:56] root INFO: Running output job for channel sms
ℹ️ [20:25:56] root INFO: Fetching data to DataFrame
ℹ️ [20:25:56] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [20:25:56] root INFO: Fetched 8 rows for channel sms
ℹ️ [20:25:56] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [20:25:56] root INFO: Running output job for channel push
ℹ️ [20:25:56] root INFO: Fetching data to DataFrame
ℹ️ [20:25:56] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [20:25:56] root INFO: Fetched 17 rows for channel push
ℹ️ [20:25:56] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [20:25:56] root INFO: Cleaning up DB connection
ℹ️ [20:27:13] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [20:27:13] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [20:27:13] root INFO: Calculation complete: 3 steps.
ℹ️ [20:27:13] root INFO: Calculating the number of waterfall steps.
ℹ️ [20:27:13] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [20:27:13] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [20:27:13] root INFO: Calculating the number of output steps.
ℹ️ [20:27:13] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [20:27:13] root INFO: Preparing logic for channel 'email'
ℹ️ [20:27:13] root INFO: Preparing logic for channel 'sms'
ℹ️ [20:27:13] root INFO: Preparing logic for channel 'push'
ℹ️ [20:27:13] root INFO: Calculation complete: 3 steps (files).
ℹ️ [20:27:13] root INFO: Using cached SQL statements.
ℹ️ [20:27:13] root INFO: Dropping existing table eligibility_poc
ℹ️ [20:27:13] root INFO: Executing SQL statement
ℹ️ [20:27:14] root INFO: SQL execution finished in 1.18s
ℹ️ [20:27:14] root INFO: Executing eligibility SQL statement
ℹ️ [20:27:14] root INFO: Executing SQL statement
ℹ️ [20:27:14] root INFO: SQL execution finished in 0.50s
ℹ️ [20:27:14] root INFO: Executing eligibility SQL statement
ℹ️ [20:27:14] root INFO: Executing SQL statement
ℹ️ [20:27:15] root INFO: SQL execution finished in 0.19s
ℹ️ [20:27:15] root INFO: Using cached waterfall steps.
ℹ️ [20:27:15] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [20:27:15] root INFO: Fetching data to DataFrame
❌ [20:27:15] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:27:15] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [20:27:15] root INFO: Fetching data to DataFrame
❌ [20:27:15] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,account_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,account_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:27:15] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [20:27:15] root INFO: Fetching data to DataFrame
❌ [20:27:16] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    region_id,segment_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    region_id,segment_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:27:16] root INFO: Using cached output steps.
ℹ️ [20:27:16] root INFO: Running output job for channel email
ℹ️ [20:27:16] root INFO: Fetching data to DataFrame
ℹ️ [20:27:16] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [20:27:16] root INFO: Fetched 17 rows for channel email
ℹ️ [20:27:16] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [20:27:16] root INFO: Running output job for channel sms
ℹ️ [20:27:16] root INFO: Fetching data to DataFrame
ℹ️ [20:27:16] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [20:27:16] root INFO: Fetched 8 rows for channel sms
ℹ️ [20:27:16] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [20:27:16] root INFO: Running output job for channel push
ℹ️ [20:27:16] root INFO: Fetching data to DataFrame
ℹ️ [20:27:16] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [20:27:16] root INFO: Fetched 17 rows for channel push
ℹ️ [20:27:16] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [20:27:16] root INFO: Cleaning up DB connection
ℹ️ [20:28:58] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [20:28:58] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [20:28:58] root INFO: Calculation complete: 3 steps.
ℹ️ [20:28:58] root INFO: Calculating the number of waterfall steps.
ℹ️ [20:28:58] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [20:28:58] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [20:28:58] root INFO: Calculating the number of output steps.
ℹ️ [20:28:58] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [20:28:58] root INFO: Preparing logic for channel 'email'
ℹ️ [20:28:58] root INFO: Preparing logic for channel 'sms'
ℹ️ [20:28:58] root INFO: Preparing logic for channel 'push'
ℹ️ [20:28:58] root INFO: Calculation complete: 3 steps (files).
ℹ️ [20:28:58] root INFO: Using cached SQL statements.
ℹ️ [20:28:58] root INFO: Dropping existing table eligibility_poc
ℹ️ [20:28:58] root INFO: Executing SQL statement
ℹ️ [20:28:59] root INFO: SQL execution finished in 1.33s
ℹ️ [20:28:59] root INFO: Executing eligibility SQL statement
ℹ️ [20:28:59] root INFO: Executing SQL statement
ℹ️ [20:29:00] root INFO: SQL execution finished in 0.58s
ℹ️ [20:29:00] root INFO: Executing eligibility SQL statement
ℹ️ [20:29:00] root INFO: Executing SQL statement
ℹ️ [20:29:00] root INFO: SQL execution finished in 0.19s
ℹ️ [20:29:00] root INFO: Using cached waterfall steps.
ℹ️ [20:29:00] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [20:29:00] root INFO: Fetching data to DataFrame
ℹ️ [20:29:00] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.52s
ℹ️ [20:29:00] root INFO: Fetching data to DataFrame
ℹ️ [20:29:01] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.25s
ℹ️ [20:29:01] root INFO: Fetching data to DataFrame
❌ [20:29:01] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_13 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_13
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo1_6 = 1 OR c.email_promo2_7 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  
    AND NOT (c.email_loyalty_13 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
      AND 
          NOT (c.email_loyalty_13 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo1_6,email_promo2_7
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, COUNT(*) - SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, COUNT(*) - SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_13 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_13
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo1_6 = 1 OR c.email_promo2_7 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  
    AND NOT (c.email_loyalty_13 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
      AND 
          NOT (c.email_loyalty_13 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo1_6,email_promo2_7
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, COUNT(*) - SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, COUNT(*) - SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:29:01] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [20:29:01] root INFO: Fetching data to DataFrame
ℹ️ [20:29:01] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.37s
ℹ️ [20:29:01] root INFO: Fetching data to DataFrame
ℹ️ [20:29:02] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.27s
ℹ️ [20:29:02] root INFO: Fetching data to DataFrame
❌ [20:29:02] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_13 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_13
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo1_6 = 1 OR c.email_promo2_7 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  
    AND NOT (c.email_loyalty_13 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
      AND 
          NOT (c.email_loyalty_13 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo1_6,email_promo2_7
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, COUNT(*) - SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, COUNT(*) - SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_13 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_13
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo1_6 = 1 OR c.email_promo2_7 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  
    AND NOT (c.email_loyalty_13 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
      AND 
          NOT (c.email_loyalty_13 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo1_6,email_promo2_7
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, COUNT(*) - SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, COUNT(*) - SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:29:02] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [20:29:02] root INFO: Fetching data to DataFrame
ℹ️ [20:29:03] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.41s
ℹ️ [20:29:03] root INFO: Fetching data to DataFrame
ℹ️ [20:29:03] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.33s
ℹ️ [20:29:03] root INFO: Fetching data to DataFrame
❌ [20:29:03] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_13 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_13
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo1_6 = 1 OR c.email_promo2_7 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  
    AND NOT (c.email_loyalty_13 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
      AND 
          NOT (c.email_loyalty_13 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo1_6,email_promo2_7
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, COUNT(*) - SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, COUNT(*) - SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_13 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_13
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo1_6 = 1 OR c.email_promo2_7 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  
    AND NOT (c.email_loyalty_13 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
      AND 
          NOT (c.email_loyalty_13 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo1_6,email_promo2_7
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, COUNT(*) - SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, COUNT(*) - SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:29:03] root INFO: Using cached output steps.
ℹ️ [20:29:03] root INFO: Running output job for channel email
ℹ️ [20:29:03] root INFO: Fetching data to DataFrame
ℹ️ [20:29:04] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [20:29:04] root INFO: Fetched 17 rows for channel email
ℹ️ [20:29:04] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [20:29:04] root INFO: Running output job for channel sms
ℹ️ [20:29:04] root INFO: Fetching data to DataFrame
ℹ️ [20:29:04] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.22s
ℹ️ [20:29:04] root INFO: Fetched 8 rows for channel sms
ℹ️ [20:29:04] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [20:29:04] root INFO: Running output job for channel push
ℹ️ [20:29:04] root INFO: Fetching data to DataFrame
ℹ️ [20:29:04] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [20:29:04] root INFO: Fetched 17 rows for channel push
ℹ️ [20:29:04] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [20:29:04] root INFO: Cleaning up DB connection
ℹ️ [22:15:00] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [22:15:00] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [22:15:00] root INFO: Calculation complete: 3 steps.
ℹ️ [22:15:00] root INFO: Calculating the number of waterfall steps.
ℹ️ [22:15:00] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [22:15:00] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [22:15:00] root INFO: Calculating the number of output steps.
ℹ️ [22:15:00] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [22:15:00] root INFO: Preparing logic for channel 'email'
ℹ️ [22:15:00] root INFO: Preparing logic for channel 'sms'
ℹ️ [22:15:00] root INFO: Preparing logic for channel 'push'
ℹ️ [22:15:00] root INFO: Calculation complete: 3 steps (files).
ℹ️ [22:15:00] root INFO: Using cached SQL statements.
ℹ️ [22:15:00] root INFO: Dropping existing table eligibility_poc
ℹ️ [22:15:00] root INFO: Executing SQL statement
ℹ️ [22:15:01] root INFO: SQL execution finished in 1.48s
ℹ️ [22:15:01] root INFO: Executing eligibility SQL statement
ℹ️ [22:15:01] root INFO: Executing SQL statement
ℹ️ [22:15:02] root INFO: SQL execution finished in 0.56s
ℹ️ [22:15:02] root INFO: Executing eligibility SQL statement
ℹ️ [22:15:02] root INFO: Executing SQL statement
ℹ️ [22:15:02] root INFO: SQL execution finished in 0.19s
ℹ️ [22:15:02] root INFO: Using cached waterfall steps.
ℹ️ [22:15:02] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [22:15:02] root INFO: Fetching data to DataFrame
ℹ️ [22:15:03] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.47s
ℹ️ [22:15:03] root INFO: Fetching data to DataFrame
ℹ️ [22:15:03] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.27s
ℹ️ [22:15:03] root INFO: Fetching data to DataFrame
❌ [22:15:03] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:15:03] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [22:15:03] root INFO: Fetching data to DataFrame
ℹ️ [22:15:04] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [22:15:04] root INFO: Fetching data to DataFrame
ℹ️ [22:15:04] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.31s
ℹ️ [22:15:04] root INFO: Fetching data to DataFrame
❌ [22:15:04] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:15:04] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [22:15:04] root INFO: Fetching data to DataFrame
ℹ️ [22:15:05] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.37s
ℹ️ [22:15:05] root INFO: Fetching data to DataFrame
ℹ️ [22:15:05] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.25s
ℹ️ [22:15:05] root INFO: Fetching data to DataFrame
❌ [22:15:05] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:15:06] root INFO: Using cached output steps.
ℹ️ [22:15:06] root INFO: Running output job for channel email
ℹ️ [22:15:06] root INFO: Fetching data to DataFrame
ℹ️ [22:15:06] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [22:15:06] root INFO: Fetched 17 rows for channel email
ℹ️ [22:15:06] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [22:15:06] root INFO: Running output job for channel sms
ℹ️ [22:15:06] root INFO: Fetching data to DataFrame
ℹ️ [22:15:06] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [22:15:06] root INFO: Fetched 8 rows for channel sms
ℹ️ [22:15:06] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [22:15:06] root INFO: Running output job for channel push
ℹ️ [22:15:06] root INFO: Fetching data to DataFrame
ℹ️ [22:15:06] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [22:15:06] root INFO: Fetched 17 rows for channel push
ℹ️ [22:15:06] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [22:15:06] root INFO: Cleaning up DB connection
ℹ️ [22:36:17] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [22:36:17] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [22:36:18] root INFO: Calculation complete: 3 steps.
ℹ️ [22:36:18] root INFO: Calculating the number of waterfall steps.
ℹ️ [22:36:18] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [22:36:18] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [22:36:18] root INFO: Calculating the number of output steps.
ℹ️ [22:36:18] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [22:36:18] root INFO: Preparing logic for channel 'email'
ℹ️ [22:36:18] root INFO: Preparing logic for channel 'sms'
ℹ️ [22:36:18] root INFO: Preparing logic for channel 'push'
ℹ️ [22:36:18] root INFO: Calculation complete: 3 steps (files).
ℹ️ [22:36:18] root INFO: Using cached SQL statements.
ℹ️ [22:36:18] root INFO: Dropping existing table eligibility_poc
ℹ️ [22:36:18] root INFO: Executing SQL statement
ℹ️ [22:36:19] root INFO: SQL execution finished in 1.41s
ℹ️ [22:36:19] root INFO: Executing eligibility SQL statement
ℹ️ [22:36:19] root INFO: Executing SQL statement
ℹ️ [22:36:20] root INFO: SQL execution finished in 0.53s
ℹ️ [22:36:20] root INFO: Executing eligibility SQL statement
ℹ️ [22:36:20] root INFO: Executing SQL statement
ℹ️ [22:36:20] root INFO: SQL execution finished in 0.18s
ℹ️ [22:36:20] root INFO: Using cached waterfall steps.
ℹ️ [22:36:20] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [22:36:20] root INFO: Fetching data to DataFrame
ℹ️ [22:36:20] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.47s
ℹ️ [22:36:20] root INFO: Fetching data to DataFrame
ℹ️ [22:36:20] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.23s
ℹ️ [22:36:20] root INFO: Fetching data to DataFrame
❌ [22:36:21] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1153] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1153] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1153] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:36:21] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [22:36:21] root INFO: Fetching data to DataFrame
ℹ️ [22:36:21] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [22:36:21] root INFO: Fetching data to DataFrame
ℹ️ [22:36:21] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.25s
ℹ️ [22:36:21] root INFO: Fetching data to DataFrame
❌ [22:36:22] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1153] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1153] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1153] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:36:22] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [22:36:22] root INFO: Fetching data to DataFrame
ℹ️ [22:45:27] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [22:45:27] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [22:45:27] root INFO: Calculation complete: 3 steps.
ℹ️ [22:45:27] root INFO: Calculating the number of waterfall steps.
ℹ️ [22:45:27] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [22:45:27] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [22:45:27] root INFO: Calculating the number of output steps.
ℹ️ [22:45:27] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [22:45:27] root INFO: Preparing logic for channel 'email'
ℹ️ [22:45:27] root INFO: Preparing logic for channel 'sms'
ℹ️ [22:45:27] root INFO: Preparing logic for channel 'push'
ℹ️ [22:45:27] root INFO: Calculation complete: 3 steps (files).
ℹ️ [22:45:27] root INFO: Using cached SQL statements.
ℹ️ [22:45:27] root INFO: Dropping existing table eligibility_poc
ℹ️ [22:45:27] root INFO: Executing SQL statement
ℹ️ [22:45:29] root INFO: SQL execution finished in 1.51s
ℹ️ [22:45:29] root INFO: Executing eligibility SQL statement
ℹ️ [22:45:29] root INFO: Executing SQL statement
ℹ️ [22:45:31] root INFO: SQL execution finished in 1.70s
ℹ️ [22:45:31] root INFO: Executing eligibility SQL statement
ℹ️ [22:45:31] root INFO: Executing SQL statement
ℹ️ [22:45:31] root INFO: SQL execution finished in 0.20s
ℹ️ [22:45:31] root INFO: Using cached waterfall steps.
ℹ️ [22:45:31] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [22:45:31] root INFO: Fetching data to DataFrame
ℹ️ [22:45:31] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.44s
ℹ️ [22:45:31] root INFO: Fetching data to DataFrame
ℹ️ [22:45:32] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [22:45:32] root INFO: Fetching data to DataFrame
❌ [22:45:32] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:45:32] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [22:45:32] root INFO: Fetching data to DataFrame
ℹ️ [22:45:32] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [22:45:32] root INFO: Fetching data to DataFrame
ℹ️ [22:45:32] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [22:45:32] root INFO: Fetching data to DataFrame
❌ [22:45:33] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:45:33] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [22:45:33] root INFO: Fetching data to DataFrame
ℹ️ [22:45:33] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [22:45:33] root INFO: Fetching data to DataFrame
ℹ️ [22:45:33] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [22:45:33] root INFO: Fetching data to DataFrame
❌ [22:45:33] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:45:33] root INFO: Using cached output steps.
ℹ️ [22:45:33] root INFO: Running output job for channel email
ℹ️ [22:45:33] root INFO: Fetching data to DataFrame
ℹ️ [22:45:34] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [22:45:34] root INFO: Fetched 17 rows for channel email
ℹ️ [22:45:34] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [22:45:34] root INFO: Running output job for channel sms
ℹ️ [22:45:34] root INFO: Fetching data to DataFrame
ℹ️ [22:45:34] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [22:45:34] root INFO: Fetched 8 rows for channel sms
ℹ️ [22:45:34] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [22:45:34] root INFO: Running output job for channel push
ℹ️ [22:45:34] root INFO: Fetching data to DataFrame
ℹ️ [22:45:34] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [22:45:34] root INFO: Fetched 17 rows for channel push
ℹ️ [22:45:34] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [22:45:34] root INFO: Cleaning up DB connection
ℹ️ [22:57:41] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [22:57:41] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [22:57:41] root INFO: Calculation complete: 3 steps.
ℹ️ [22:57:41] root INFO: Calculating the number of waterfall steps.
ℹ️ [22:57:41] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [22:57:42] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [22:57:42] root INFO: Calculating the number of output steps.
ℹ️ [22:57:42] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [22:57:42] root INFO: Preparing logic for channel 'email'
ℹ️ [22:57:42] root INFO: Preparing logic for channel 'sms'
ℹ️ [22:57:42] root INFO: Preparing logic for channel 'push'
ℹ️ [22:57:42] root INFO: Calculation complete: 3 steps (files).
ℹ️ [22:57:42] root INFO: Using cached SQL statements.
ℹ️ [22:57:42] root INFO: Dropping existing table eligibility_poc
ℹ️ [22:57:42] root INFO: Executing SQL statement
ℹ️ [22:57:43] root INFO: SQL execution finished in 1.63s
ℹ️ [22:57:43] root INFO: Executing eligibility SQL statement
ℹ️ [22:57:43] root INFO: Executing SQL statement
ℹ️ [22:57:44] root INFO: SQL execution finished in 0.57s
ℹ️ [22:57:44] root INFO: Executing eligibility SQL statement
ℹ️ [22:57:44] root INFO: Executing SQL statement
ℹ️ [22:57:44] root INFO: SQL execution finished in 0.20s
ℹ️ [22:57:44] root INFO: Using cached waterfall steps.
ℹ️ [22:57:44] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [22:57:44] root INFO: Fetching data to DataFrame
ℹ️ [22:57:44] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.42s
ℹ️ [22:57:44] root INFO: Fetching data to DataFrame
ℹ️ [22:57:45] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.24s
ℹ️ [22:57:45] root INFO: Fetching data to DataFrame
❌ [22:57:45] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:57:45] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [22:57:45] root INFO: Fetching data to DataFrame
ℹ️ [22:57:45] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.32s
ℹ️ [22:57:45] root INFO: Fetching data to DataFrame
ℹ️ [22:57:45] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.24s
ℹ️ [22:57:45] root INFO: Fetching data to DataFrame
❌ [22:57:46] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:57:46] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [22:57:46] root INFO: Fetching data to DataFrame
ℹ️ [22:57:46] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.35s
ℹ️ [22:57:46] root INFO: Fetching data to DataFrame
ℹ️ [22:57:46] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [22:57:46] root INFO: Fetching data to DataFrame
❌ [22:57:47] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:57:47] root INFO: Using cached output steps.
ℹ️ [22:57:47] root INFO: Running output job for channel email
ℹ️ [22:57:47] root INFO: Fetching data to DataFrame
ℹ️ [22:57:47] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [22:57:47] root INFO: Fetched 17 rows for channel email
ℹ️ [22:57:47] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [22:57:47] root INFO: Running output job for channel sms
ℹ️ [22:57:47] root INFO: Fetching data to DataFrame
ℹ️ [22:57:47] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [22:57:47] root INFO: Fetched 8 rows for channel sms
ℹ️ [22:57:47] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [22:57:47] root INFO: Running output job for channel push
ℹ️ [22:57:47] root INFO: Fetching data to DataFrame
ℹ️ [22:57:47] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [22:57:47] root INFO: Fetched 17 rows for channel push
ℹ️ [22:57:47] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [22:57:47] root INFO: Cleaning up DB connection
ℹ️ [23:15:44] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:15:44] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:15:44] root INFO: Calculation complete: 3 steps.
ℹ️ [23:15:44] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:15:44] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:15:44] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:15:44] root INFO: Calculating the number of output steps.
ℹ️ [23:15:44] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:15:44] root INFO: Preparing logic for channel 'email'
ℹ️ [23:15:44] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:15:44] root INFO: Preparing logic for channel 'push'
ℹ️ [23:15:44] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:15:44] root INFO: Using cached SQL statements.
ℹ️ [23:15:44] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:15:44] root INFO: Executing SQL statement
ℹ️ [23:15:46] root INFO: SQL execution finished in 1.52s
ℹ️ [23:15:46] root INFO: Executing eligibility SQL statement
ℹ️ [23:15:46] root INFO: Executing SQL statement
ℹ️ [23:15:46] root INFO: SQL execution finished in 0.69s
ℹ️ [23:15:46] root INFO: Executing eligibility SQL statement
ℹ️ [23:15:46] root INFO: Executing SQL statement
ℹ️ [23:15:47] root INFO: SQL execution finished in 0.18s
ℹ️ [23:15:47] root INFO: Using cached waterfall steps.
ℹ️ [23:15:47] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:15:47] root INFO: Fetching data to DataFrame
ℹ️ [23:15:47] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.42s
ℹ️ [23:15:47] root INFO: Fetching data to DataFrame
ℹ️ [23:15:47] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:15:47] root INFO: Fetching data to DataFrame
❌ [23:15:47] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:15:47] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:15:47] root INFO: Fetching data to DataFrame
ℹ️ [23:15:48] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [23:15:48] root INFO: Fetching data to DataFrame
ℹ️ [23:15:48] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:15:48] root INFO: Fetching data to DataFrame
❌ [23:15:48] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:15:48] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:15:48] root INFO: Fetching data to DataFrame
ℹ️ [23:15:48] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [23:15:48] root INFO: Fetching data to DataFrame
ℹ️ [23:15:49] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.24s
ℹ️ [23:15:49] root INFO: Fetching data to DataFrame
❌ [23:15:49] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:15:49] root INFO: Using cached output steps.
ℹ️ [23:15:49] root INFO: Running output job for channel email
ℹ️ [23:15:49] root INFO: Fetching data to DataFrame
ℹ️ [23:15:49] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [23:15:49] root INFO: Fetched 17 rows for channel email
ℹ️ [23:15:49] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:15:49] root INFO: Running output job for channel sms
ℹ️ [23:15:49] root INFO: Fetching data to DataFrame
ℹ️ [23:15:49] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [23:15:49] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:15:49] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:15:49] root INFO: Running output job for channel push
ℹ️ [23:15:49] root INFO: Fetching data to DataFrame
ℹ️ [23:15:49] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [23:15:49] root INFO: Fetched 17 rows for channel push
ℹ️ [23:15:49] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:15:50] root INFO: Cleaning up DB connection
ℹ️ [23:16:00] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:16:00] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:16:00] root INFO: Calculation complete: 3 steps.
ℹ️ [23:16:00] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:16:00] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:16:00] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:16:00] root INFO: Calculating the number of output steps.
ℹ️ [23:16:00] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:16:00] root INFO: Preparing logic for channel 'email'
ℹ️ [23:16:00] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:16:00] root INFO: Preparing logic for channel 'push'
ℹ️ [23:16:00] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:16:00] root INFO: Using cached SQL statements.
ℹ️ [23:16:00] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:16:00] root INFO: Executing SQL statement
ℹ️ [23:16:02] root INFO: SQL execution finished in 2.29s
ℹ️ [23:16:02] root INFO: Executing eligibility SQL statement
ℹ️ [23:16:02] root INFO: Executing SQL statement
ℹ️ [23:16:02] root INFO: SQL execution finished in 0.52s
ℹ️ [23:16:02] root INFO: Executing eligibility SQL statement
ℹ️ [23:16:02] root INFO: Executing SQL statement
ℹ️ [23:16:03] root INFO: SQL execution finished in 0.18s
ℹ️ [23:16:03] root INFO: Using cached waterfall steps.
ℹ️ [23:16:03] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:16:03] root INFO: Fetching data to DataFrame
ℹ️ [23:16:03] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.37s
ℹ️ [23:16:03] root INFO: Fetching data to DataFrame
ℹ️ [23:16:03] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:16:03] root INFO: Fetching data to DataFrame
❌ [23:16:03] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:16:03] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:16:03] root INFO: Fetching data to DataFrame
ℹ️ [23:16:04] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.34s
ℹ️ [23:16:04] root INFO: Fetching data to DataFrame
ℹ️ [23:16:04] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:16:04] root INFO: Fetching data to DataFrame
❌ [23:16:04] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:16:04] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:16:04] root INFO: Fetching data to DataFrame
ℹ️ [23:16:05] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [23:16:05] root INFO: Fetching data to DataFrame
ℹ️ [23:16:05] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.30s
ℹ️ [23:16:05] root INFO: Fetching data to DataFrame
❌ [23:16:05] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:16:05] root INFO: Using cached output steps.
ℹ️ [23:16:05] root INFO: Running output job for channel email
ℹ️ [23:16:05] root INFO: Fetching data to DataFrame
ℹ️ [23:16:05] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [23:16:05] root INFO: Fetched 17 rows for channel email
ℹ️ [23:16:05] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:16:05] root INFO: Running output job for channel sms
ℹ️ [23:16:05] root INFO: Fetching data to DataFrame
ℹ️ [23:16:05] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [23:16:05] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:16:05] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:16:05] root INFO: Running output job for channel push
ℹ️ [23:16:05] root INFO: Fetching data to DataFrame
ℹ️ [23:16:06] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [23:16:06] root INFO: Fetched 17 rows for channel push
ℹ️ [23:16:06] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:16:06] root INFO: Cleaning up DB connection
ℹ️ [23:16:28] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:16:28] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:16:28] root INFO: Calculation complete: 3 steps.
ℹ️ [23:16:28] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:16:28] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:16:28] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:16:28] root INFO: Calculating the number of output steps.
ℹ️ [23:16:28] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:16:28] root INFO: Preparing logic for channel 'email'
ℹ️ [23:16:28] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:16:28] root INFO: Preparing logic for channel 'push'
ℹ️ [23:16:28] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:16:28] root INFO: Using cached SQL statements.
ℹ️ [23:16:28] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:16:28] root INFO: Executing SQL statement
ℹ️ [23:16:29] root INFO: SQL execution finished in 1.21s
ℹ️ [23:16:29] root INFO: Executing eligibility SQL statement
ℹ️ [23:16:29] root INFO: Executing SQL statement
ℹ️ [23:16:30] root INFO: SQL execution finished in 0.44s
ℹ️ [23:16:30] root INFO: Executing eligibility SQL statement
ℹ️ [23:16:30] root INFO: Executing SQL statement
ℹ️ [23:16:30] root INFO: SQL execution finished in 0.18s
ℹ️ [23:16:30] root INFO: Using cached waterfall steps.
ℹ️ [23:16:30] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:16:30] root INFO: Fetching data to DataFrame
ℹ️ [23:16:30] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.39s
ℹ️ [23:16:30] root INFO: Fetching data to DataFrame
ℹ️ [23:16:30] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.20s
ℹ️ [23:16:30] root INFO: Fetching data to DataFrame
❌ [23:16:31] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:16:31] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:16:31] root INFO: Fetching data to DataFrame
ℹ️ [23:16:31] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.40s
ℹ️ [23:16:31] root INFO: Fetching data to DataFrame
ℹ️ [23:16:31] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.30s
ℹ️ [23:16:31] root INFO: Fetching data to DataFrame
❌ [23:16:32] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:16:32] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:16:32] root INFO: Fetching data to DataFrame
ℹ️ [23:16:32] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.50s
ℹ️ [23:16:32] root INFO: Fetching data to DataFrame
ℹ️ [23:16:32] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.32s
ℹ️ [23:16:32] root INFO: Fetching data to DataFrame
❌ [23:16:33] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:16:33] root INFO: Using cached output steps.
ℹ️ [23:16:33] root INFO: Running output job for channel email
ℹ️ [23:16:33] root INFO: Fetching data to DataFrame
ℹ️ [23:16:33] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [23:16:33] root INFO: Fetched 17 rows for channel email
ℹ️ [23:16:33] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:16:33] root INFO: Running output job for channel sms
ℹ️ [23:16:33] root INFO: Fetching data to DataFrame
ℹ️ [23:16:33] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [23:16:33] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:16:33] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:16:33] root INFO: Running output job for channel push
ℹ️ [23:16:33] root INFO: Fetching data to DataFrame
ℹ️ [23:16:34] root INFO: Fetched DataFrame with 17 rows and 5 columns in 1.21s
ℹ️ [23:16:34] root INFO: Fetched 17 rows for channel push
ℹ️ [23:16:34] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:16:34] root INFO: Cleaning up DB connection
ℹ️ [23:17:08] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:17:08] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:17:08] root INFO: Calculation complete: 3 steps.
ℹ️ [23:17:08] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:17:08] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:17:08] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:17:08] root INFO: Calculating the number of output steps.
ℹ️ [23:17:08] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:17:08] root INFO: Preparing logic for channel 'email'
ℹ️ [23:17:08] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:17:08] root INFO: Preparing logic for channel 'push'
ℹ️ [23:17:08] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:17:08] root INFO: Using cached SQL statements.
ℹ️ [23:17:08] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:17:08] root INFO: Executing SQL statement
ℹ️ [23:17:09] root INFO: SQL execution finished in 1.17s
ℹ️ [23:17:09] root INFO: Executing eligibility SQL statement
ℹ️ [23:17:09] root INFO: Executing SQL statement
ℹ️ [23:17:10] root INFO: SQL execution finished in 0.44s
ℹ️ [23:17:10] root INFO: Executing eligibility SQL statement
ℹ️ [23:17:10] root INFO: Executing SQL statement
ℹ️ [23:17:10] root INFO: SQL execution finished in 0.18s
ℹ️ [23:17:10] root INFO: Using cached waterfall steps.
ℹ️ [23:17:10] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:17:10] root INFO: Fetching data to DataFrame
ℹ️ [23:17:10] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.37s
ℹ️ [23:17:10] root INFO: Fetching data to DataFrame
ℹ️ [23:17:10] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:17:10] root INFO: Fetching data to DataFrame
❌ [23:17:11] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:17:11] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:17:11] root INFO: Fetching data to DataFrame
ℹ️ [23:17:11] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.32s
ℹ️ [23:17:11] root INFO: Fetching data to DataFrame
ℹ️ [23:17:11] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:17:11] root INFO: Fetching data to DataFrame
❌ [23:17:11] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:17:11] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:17:11] root INFO: Fetching data to DataFrame
ℹ️ [23:17:12] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.34s
ℹ️ [23:17:12] root INFO: Fetching data to DataFrame
ℹ️ [23:17:12] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:17:12] root INFO: Fetching data to DataFrame
❌ [23:17:12] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:17:12] root INFO: Using cached output steps.
ℹ️ [23:17:12] root INFO: Running output job for channel email
ℹ️ [23:17:12] root INFO: Fetching data to DataFrame
ℹ️ [23:17:12] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [23:17:12] root INFO: Fetched 17 rows for channel email
ℹ️ [23:17:12] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:17:12] root INFO: Running output job for channel sms
ℹ️ [23:17:12] root INFO: Fetching data to DataFrame
ℹ️ [23:17:12] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [23:17:12] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:17:12] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:17:12] root INFO: Running output job for channel push
ℹ️ [23:17:12] root INFO: Fetching data to DataFrame
ℹ️ [23:17:13] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [23:17:13] root INFO: Fetched 17 rows for channel push
ℹ️ [23:17:13] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:17:13] root INFO: Cleaning up DB connection
ℹ️ [23:17:15] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:17:15] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:17:15] root INFO: Calculation complete: 3 steps.
ℹ️ [23:17:15] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:17:15] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:17:15] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:17:15] root INFO: Calculating the number of output steps.
ℹ️ [23:17:15] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:17:15] root INFO: Preparing logic for channel 'email'
ℹ️ [23:17:15] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:17:15] root INFO: Preparing logic for channel 'push'
ℹ️ [23:17:15] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:17:15] root INFO: Using cached SQL statements.
ℹ️ [23:17:15] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:17:15] root INFO: Executing SQL statement
ℹ️ [23:17:16] root INFO: SQL execution finished in 1.19s
ℹ️ [23:17:16] root INFO: Executing eligibility SQL statement
ℹ️ [23:17:16] root INFO: Executing SQL statement
ℹ️ [23:17:16] root INFO: SQL execution finished in 0.48s
ℹ️ [23:17:16] root INFO: Executing eligibility SQL statement
ℹ️ [23:17:16] root INFO: Executing SQL statement
ℹ️ [23:17:16] root INFO: SQL execution finished in 0.18s
ℹ️ [23:17:16] root INFO: Using cached waterfall steps.
ℹ️ [23:17:16] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:17:16] root INFO: Fetching data to DataFrame
ℹ️ [23:17:17] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.37s
ℹ️ [23:17:17] root INFO: Fetching data to DataFrame
ℹ️ [23:17:17] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:17:17] root INFO: Fetching data to DataFrame
❌ [23:17:17] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:17:17] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:17:17] root INFO: Fetching data to DataFrame
ℹ️ [23:17:18] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.36s
ℹ️ [23:17:18] root INFO: Fetching data to DataFrame
ℹ️ [23:17:18] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.26s
ℹ️ [23:17:18] root INFO: Fetching data to DataFrame
❌ [23:17:18] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:17:18] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:17:18] root INFO: Fetching data to DataFrame
ℹ️ [23:17:19] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.58s
ℹ️ [23:17:19] root INFO: Fetching data to DataFrame
ℹ️ [23:17:19] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.32s
ℹ️ [23:17:19] root INFO: Fetching data to DataFrame
❌ [23:17:19] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:17:19] root INFO: Using cached output steps.
ℹ️ [23:17:19] root INFO: Running output job for channel email
ℹ️ [23:17:19] root INFO: Fetching data to DataFrame
ℹ️ [23:17:19] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [23:17:19] root INFO: Fetched 17 rows for channel email
ℹ️ [23:17:19] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:17:19] root INFO: Running output job for channel sms
ℹ️ [23:17:19] root INFO: Fetching data to DataFrame
ℹ️ [23:17:20] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [23:17:20] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:17:20] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:17:20] root INFO: Running output job for channel push
ℹ️ [23:17:20] root INFO: Fetching data to DataFrame
ℹ️ [23:17:20] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [23:17:20] root INFO: Fetched 17 rows for channel push
ℹ️ [23:17:20] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:17:20] root INFO: Cleaning up DB connection
ℹ️ [23:19:46] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:19:46] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:19:46] root INFO: Calculation complete: 3 steps.
ℹ️ [23:19:46] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:19:46] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:19:46] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:19:46] root INFO: Calculating the number of output steps.
ℹ️ [23:19:46] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:19:46] root INFO: Preparing logic for channel 'email'
ℹ️ [23:19:46] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:19:46] root INFO: Preparing logic for channel 'push'
ℹ️ [23:19:46] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:19:46] root INFO: Using cached SQL statements.
ℹ️ [23:19:46] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:19:46] root INFO: Executing SQL statement
ℹ️ [23:19:47] root INFO: SQL execution finished in 1.31s
ℹ️ [23:19:47] root INFO: Executing eligibility SQL statement
ℹ️ [23:19:47] root INFO: Executing SQL statement
ℹ️ [23:19:48] root INFO: SQL execution finished in 0.87s
ℹ️ [23:19:48] root INFO: Executing eligibility SQL statement
ℹ️ [23:19:48] root INFO: Executing SQL statement
ℹ️ [23:19:48] root INFO: SQL execution finished in 0.24s
ℹ️ [23:19:48] root INFO: Using cached waterfall steps.
ℹ️ [23:19:48] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:19:48] root INFO: Fetching data to DataFrame
ℹ️ [23:19:48] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.43s
ℹ️ [23:19:48] root INFO: Fetching data to DataFrame
ℹ️ [23:19:49] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:19:49] root INFO: Fetching data to DataFrame
❌ [23:19:49] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:19:49] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:19:49] root INFO: Fetching data to DataFrame
ℹ️ [23:19:49] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.31s
ℹ️ [23:19:49] root INFO: Fetching data to DataFrame
ℹ️ [23:19:49] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.27s
ℹ️ [23:19:49] root INFO: Fetching data to DataFrame
❌ [23:19:50] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:19:50] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:19:50] root INFO: Fetching data to DataFrame
ℹ️ [23:19:50] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [23:19:50] root INFO: Fetching data to DataFrame
ℹ️ [23:19:50] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.20s
ℹ️ [23:19:50] root INFO: Fetching data to DataFrame
❌ [23:19:50] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:19:50] root INFO: Using cached output steps.
ℹ️ [23:19:50] root INFO: Running output job for channel email
ℹ️ [23:19:50] root INFO: Fetching data to DataFrame
ℹ️ [23:19:51] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [23:19:51] root INFO: Fetched 17 rows for channel email
ℹ️ [23:19:51] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:19:51] root INFO: Running output job for channel sms
ℹ️ [23:19:51] root INFO: Fetching data to DataFrame
ℹ️ [23:19:51] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [23:19:51] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:19:51] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:19:51] root INFO: Running output job for channel push
ℹ️ [23:19:51] root INFO: Fetching data to DataFrame
ℹ️ [23:19:51] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [23:19:51] root INFO: Fetched 17 rows for channel push
ℹ️ [23:19:51] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:19:51] root INFO: Cleaning up DB connection
ℹ️ [23:19:55] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:19:55] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:19:55] root INFO: Calculation complete: 3 steps.
ℹ️ [23:19:55] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:19:55] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:19:55] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:19:55] root INFO: Calculating the number of output steps.
ℹ️ [23:19:55] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:19:55] root INFO: Preparing logic for channel 'email'
ℹ️ [23:19:55] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:19:55] root INFO: Preparing logic for channel 'push'
ℹ️ [23:19:55] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:19:55] root INFO: Using cached SQL statements.
ℹ️ [23:19:55] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:19:55] root INFO: Executing SQL statement
ℹ️ [23:19:57] root INFO: SQL execution finished in 1.12s
ℹ️ [23:19:57] root INFO: Executing eligibility SQL statement
ℹ️ [23:19:57] root INFO: Executing SQL statement
ℹ️ [23:19:57] root INFO: SQL execution finished in 0.47s
ℹ️ [23:19:57] root INFO: Executing eligibility SQL statement
ℹ️ [23:19:57] root INFO: Executing SQL statement
ℹ️ [23:19:57] root INFO: SQL execution finished in 0.18s
ℹ️ [23:19:57] root INFO: Using cached waterfall steps.
ℹ️ [23:19:57] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:19:57] root INFO: Fetching data to DataFrame
ℹ️ [23:19:58] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.39s
ℹ️ [23:19:58] root INFO: Fetching data to DataFrame
ℹ️ [23:19:58] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.24s
ℹ️ [23:19:58] root INFO: Fetching data to DataFrame
❌ [23:19:58] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:19:58] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:19:58] root INFO: Fetching data to DataFrame
ℹ️ [23:19:58] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.30s
ℹ️ [23:19:58] root INFO: Fetching data to DataFrame
ℹ️ [23:19:59] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:19:59] root INFO: Fetching data to DataFrame
❌ [23:19:59] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:19:59] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:19:59] root INFO: Fetching data to DataFrame
ℹ️ [23:19:59] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.37s
ℹ️ [23:19:59] root INFO: Fetching data to DataFrame
ℹ️ [23:19:59] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.30s
ℹ️ [23:19:59] root INFO: Fetching data to DataFrame
❌ [23:20:00] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:20:00] root INFO: Using cached output steps.
ℹ️ [23:20:00] root INFO: Running output job for channel email
ℹ️ [23:20:00] root INFO: Fetching data to DataFrame
ℹ️ [23:20:00] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.22s
ℹ️ [23:20:00] root INFO: Fetched 17 rows for channel email
ℹ️ [23:20:00] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:20:00] root INFO: Running output job for channel sms
ℹ️ [23:20:00] root INFO: Fetching data to DataFrame
ℹ️ [23:20:00] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.22s
ℹ️ [23:20:00] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:20:00] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:20:00] root INFO: Running output job for channel push
ℹ️ [23:20:00] root INFO: Fetching data to DataFrame
ℹ️ [23:20:00] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [23:20:00] root INFO: Fetched 17 rows for channel push
ℹ️ [23:20:00] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:20:00] root INFO: Cleaning up DB connection
ℹ️ [23:20:10] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:20:10] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:20:10] root INFO: Calculation complete: 3 steps.
ℹ️ [23:20:10] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:20:10] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:20:10] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:20:10] root INFO: Calculating the number of output steps.
ℹ️ [23:20:10] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:20:10] root INFO: Preparing logic for channel 'email'
ℹ️ [23:20:10] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:20:10] root INFO: Preparing logic for channel 'push'
ℹ️ [23:20:10] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:20:10] root INFO: Using cached SQL statements.
ℹ️ [23:20:10] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:20:10] root INFO: Executing SQL statement
ℹ️ [23:20:11] root INFO: SQL execution finished in 1.42s
ℹ️ [23:20:11] root INFO: Executing eligibility SQL statement
ℹ️ [23:20:11] root INFO: Executing SQL statement
ℹ️ [23:20:12] root INFO: SQL execution finished in 0.77s
ℹ️ [23:20:12] root INFO: Executing eligibility SQL statement
ℹ️ [23:20:12] root INFO: Executing SQL statement
ℹ️ [23:20:12] root INFO: SQL execution finished in 0.22s
ℹ️ [23:20:12] root INFO: Using cached waterfall steps.
ℹ️ [23:20:12] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:20:12] root INFO: Fetching data to DataFrame
ℹ️ [23:20:13] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.37s
ℹ️ [23:20:13] root INFO: Fetching data to DataFrame
ℹ️ [23:20:13] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.20s
ℹ️ [23:20:13] root INFO: Fetching data to DataFrame
❌ [23:20:13] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:20:13] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:20:13] root INFO: Fetching data to DataFrame
ℹ️ [23:20:13] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.31s
ℹ️ [23:20:13] root INFO: Fetching data to DataFrame
ℹ️ [23:20:14] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:20:14] root INFO: Fetching data to DataFrame
❌ [23:20:14] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:20:14] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:20:14] root INFO: Fetching data to DataFrame
ℹ️ [23:20:14] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.30s
ℹ️ [23:20:14] root INFO: Fetching data to DataFrame
ℹ️ [23:20:14] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:20:14] root INFO: Fetching data to DataFrame
❌ [23:20:15] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:20:15] root INFO: Using cached output steps.
ℹ️ [23:20:15] root INFO: Running output job for channel email
ℹ️ [23:20:15] root INFO: Fetching data to DataFrame
ℹ️ [23:20:15] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [23:20:15] root INFO: Fetched 17 rows for channel email
ℹ️ [23:20:15] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:20:15] root INFO: Running output job for channel sms
ℹ️ [23:20:15] root INFO: Fetching data to DataFrame
ℹ️ [23:20:15] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [23:20:15] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:20:15] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:20:15] root INFO: Running output job for channel push
ℹ️ [23:20:15] root INFO: Fetching data to DataFrame
ℹ️ [23:20:15] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [23:20:15] root INFO: Fetched 17 rows for channel push
ℹ️ [23:20:15] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:20:15] root INFO: Cleaning up DB connection
ℹ️ [23:26:58] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:26:58] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:26:58] root INFO: Calculation complete: 3 steps.
ℹ️ [23:26:58] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:26:58] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:26:58] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:26:58] root INFO: Calculating the number of output steps.
ℹ️ [23:26:58] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:26:58] root INFO: Preparing logic for channel 'email'
ℹ️ [23:26:58] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:26:58] root INFO: Preparing logic for channel 'push'
ℹ️ [23:26:58] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:26:58] root INFO: Using cached SQL statements.
ℹ️ [23:26:58] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:26:58] root INFO: Executing SQL statement
ℹ️ [23:27:10] root INFO: No existing eligibility table to drop
ℹ️ [23:27:10] root INFO: Executing eligibility SQL statement
ℹ️ [23:27:10] root INFO: Executing SQL statement
ℹ️ [23:31:21] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:31:21] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:31:21] root INFO: Calculation complete: 3 steps.
ℹ️ [23:31:21] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:31:21] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:31:21] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:31:21] root INFO: Calculating the number of output steps.
ℹ️ [23:31:21] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:31:21] root INFO: Preparing logic for channel 'email'
ℹ️ [23:31:21] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:31:21] root INFO: Preparing logic for channel 'push'
ℹ️ [23:31:21] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:31:21] root INFO: Using cached SQL statements.
ℹ️ [23:31:21] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:31:21] root INFO: Executing SQL statement
ℹ️ [23:31:33] root INFO: No existing eligibility table to drop
ℹ️ [23:31:33] root INFO: Executing eligibility SQL statement
ℹ️ [23:31:33] root INFO: Executing SQL statement
ℹ️ [23:37:26] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:37:26] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:37:26] root INFO: Calculation complete: 3 steps.
ℹ️ [23:37:26] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:37:26] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:37:26] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:37:26] root INFO: Calculating the number of output steps.
ℹ️ [23:37:26] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:37:26] root INFO: Preparing logic for channel 'email'
ℹ️ [23:37:26] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:37:26] root INFO: Preparing logic for channel 'push'
ℹ️ [23:37:26] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:37:26] root INFO: Using cached SQL statements.
ℹ️ [23:37:26] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:37:26] root INFO: Executing SQL statement
ℹ️ [23:39:15] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:39:15] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:39:15] root INFO: Calculation complete: 3 steps.
ℹ️ [23:39:15] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:39:15] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:39:15] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:39:15] root INFO: Calculating the number of output steps.
ℹ️ [23:39:15] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:39:15] root INFO: Preparing logic for channel 'email'
ℹ️ [23:39:15] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:39:15] root INFO: Preparing logic for channel 'push'
ℹ️ [23:39:15] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:39:15] root INFO: Using cached SQL statements.
ℹ️ [23:39:15] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:39:15] root INFO: Executing SQL statement
ℹ️ [23:41:09] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:41:09] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:41:09] root INFO: Calculation complete: 3 steps.
ℹ️ [23:41:09] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:41:09] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:41:09] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:41:09] root INFO: Calculating the number of output steps.
ℹ️ [23:41:09] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:41:09] root INFO: Preparing logic for channel 'email'
ℹ️ [23:41:09] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:41:09] root INFO: Preparing logic for channel 'push'
ℹ️ [23:41:09] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:41:09] root INFO: Using cached SQL statements.
ℹ️ [23:41:09] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:41:09] root INFO: Executing SQL statement
ℹ️ [23:43:38] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:43:38] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:43:38] root INFO: Calculation complete: 3 steps.
ℹ️ [23:43:38] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:43:38] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:43:38] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:43:38] root INFO: Calculating the number of output steps.
ℹ️ [23:43:38] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:43:38] root INFO: Preparing logic for channel 'email'
ℹ️ [23:43:38] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:43:38] root INFO: Preparing logic for channel 'push'
ℹ️ [23:43:38] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:43:38] root INFO: Using cached SQL statements.
ℹ️ [23:43:38] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:43:38] root INFO: Executing SQL statement
ℹ️ [23:45:15] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:45:15] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:45:15] root INFO: Calculation complete: 3 steps.
ℹ️ [23:45:15] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:45:15] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:45:15] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:45:15] root INFO: Calculating the number of output steps.
ℹ️ [23:45:15] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:45:15] root INFO: Preparing logic for channel 'email'
ℹ️ [23:45:15] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:45:15] root INFO: Preparing logic for channel 'push'
ℹ️ [23:45:15] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:45:15] root INFO: Using cached SQL statements.
ℹ️ [23:45:15] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:45:15] root INFO: Executing SQL statement
ℹ️ [23:53:35] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:53:35] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:53:35] root INFO: Calculation complete: 3 steps.
ℹ️ [23:53:35] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:53:35] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:53:35] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:53:35] root INFO: Calculating the number of output steps.
ℹ️ [23:53:35] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:53:35] root INFO: Preparing logic for channel 'email'
ℹ️ [23:53:35] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:53:35] root INFO: Preparing logic for channel 'push'
ℹ️ [23:53:35] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:53:35] root INFO: Using cached SQL statements.
ℹ️ [23:53:35] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:53:35] root INFO: Executing SQL statement
ℹ️ [23:53:47] root INFO: No existing eligibility table to drop
ℹ️ [23:53:47] root INFO: Executing eligibility SQL statement
ℹ️ [23:53:47] root INFO: Executing SQL statement
ℹ️ [07:19:49] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [07:19:49] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [07:19:49] root INFO: Calculation complete: 3 steps.
ℹ️ [07:19:49] root INFO: Calculating the number of waterfall steps.
ℹ️ [07:19:49] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [07:19:49] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [07:19:49] root INFO: Calculating the number of output steps.
ℹ️ [07:19:49] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [07:19:49] root INFO: Preparing logic for channel 'email'
ℹ️ [07:19:49] root INFO: Preparing logic for channel 'sms'
ℹ️ [07:19:49] root INFO: Preparing logic for channel 'push'
ℹ️ [07:19:49] root INFO: Calculation complete: 3 steps (files).
ℹ️ [07:19:49] root INFO: Using cached SQL statements.
ℹ️ [07:19:49] root INFO: Dropping existing table eligibility_poc
ℹ️ [07:19:49] root INFO: Executing SQL statement
ℹ️ [15:28:50] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [15:28:50] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [15:28:50] root INFO: Calculation complete: 3 steps.
ℹ️ [15:28:50] root INFO: Calculating the number of waterfall steps.
ℹ️ [15:28:50] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [15:28:50] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [15:28:50] root INFO: Calculating the number of output steps.
ℹ️ [15:28:50] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [15:28:50] root INFO: Preparing logic for channel 'email'
ℹ️ [15:28:50] root INFO: Preparing logic for channel 'sms'
ℹ️ [15:28:50] root INFO: Preparing logic for channel 'push'
ℹ️ [15:28:50] root INFO: Calculation complete: 3 steps (files).
ℹ️ [15:28:50] root INFO: Using cached SQL statements.
ℹ️ [15:28:50] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:28:50] root INFO: Executing SQL statement
ℹ️ [15:29:04] root INFO: No existing eligibility table to drop
ℹ️ [15:29:04] root INFO: Executing eligibility SQL statement
ℹ️ [15:29:04] root INFO: Executing SQL statement
ℹ️ [15:30:14] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [15:30:14] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [15:30:14] root INFO: Calculation complete: 3 steps.
ℹ️ [15:30:14] root INFO: Calculating the number of waterfall steps.
ℹ️ [15:30:14] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [15:30:14] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [15:30:14] root INFO: Calculating the number of output steps.
ℹ️ [15:30:14] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [15:30:14] root INFO: Preparing logic for channel 'email'
ℹ️ [15:30:14] root INFO: Preparing logic for channel 'sms'
ℹ️ [15:30:14] root INFO: Preparing logic for channel 'push'
ℹ️ [15:30:14] root INFO: Calculation complete: 3 steps (files).
ℹ️ [15:30:14] root INFO: Using cached SQL statements.
ℹ️ [15:30:14] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:30:14] root INFO: Executing SQL statement
ℹ️ [15:30:16] root INFO: SQL execution finished in 1.98s
ℹ️ [15:30:16] root INFO: Executing eligibility SQL statement
ℹ️ [15:30:16] root INFO: Executing SQL statement
ℹ️ [15:30:18] root INFO: SQL execution finished in 1.35s
ℹ️ [15:30:18] root INFO: Executing eligibility SQL statement
ℹ️ [15:30:18] root INFO: Executing SQL statement
ℹ️ [15:30:18] root INFO: SQL execution finished in 0.51s
ℹ️ [15:30:18] root INFO: Using cached waterfall steps.
ℹ️ [15:30:18] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [15:30:18] root INFO: Fetching data to DataFrame
ℹ️ [15:30:19] root INFO: Fetched DataFrame with 11 rows and 3 columns in 1.01s
ℹ️ [15:30:19] root INFO: Fetching data to DataFrame
❌ [15:30:19] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        email_BA_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_BA_1' AS check_name,
        SUM(CASE WHEN email_BA_1 = 0
            AND (
                (email_loyalty_1 = 1) OR 
                (email_promo_1 = 1 OR email_promo_2 = 1)
            )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
) metrics;': [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        email_BA_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_BA_1' AS check_name,
        SUM(CASE WHEN email_BA_1 = 0
            AND (
                (email_loyalty_1 = 1) OR 
                (email_promo_1 = 1 OR email_promo_2 = 1)
            )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
) metrics;': [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [15:30:20] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [15:30:20] root INFO: Fetching data to DataFrame
ℹ️ [15:30:20] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.90s
ℹ️ [15:30:20] root INFO: Fetching data to DataFrame
❌ [15:30:21] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        account_id, 
        email_BA_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_BA_1' AS check_name,
        SUM(CASE WHEN email_BA_1 = 0
            AND (
                (email_loyalty_1 = 1) OR 
                (email_promo_1 = 1 OR email_promo_2 = 1)
            )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
) metrics;': [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        account_id, 
        email_BA_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_BA_1' AS check_name,
        SUM(CASE WHEN email_BA_1 = 0
            AND (
                (email_loyalty_1 = 1) OR 
                (email_promo_1 = 1 OR email_promo_2 = 1)
            )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
) metrics;': [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [15:30:21] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [15:30:21] root INFO: Fetching data to DataFrame
ℹ️ [15:30:21] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.54s
ℹ️ [15:30:21] root INFO: Fetching data to DataFrame
❌ [15:30:22] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        region_id, 
        segment_id, 
        email_BA_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_BA_1' AS check_name,
        SUM(CASE WHEN email_BA_1 = 0
            AND (
                (email_loyalty_1 = 1) OR 
                (email_promo_1 = 1 OR email_promo_2 = 1)
            )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
) metrics;': [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        region_id, 
        segment_id, 
        email_BA_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_BA_1' AS check_name,
        SUM(CASE WHEN email_BA_1 = 0
            AND (
                (email_loyalty_1 = 1) OR 
                (email_promo_1 = 1 OR email_promo_2 = 1)
            )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
) metrics;': [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [15:30:22] root INFO: Using cached output steps.
ℹ️ [15:30:22] root INFO: Running output job for channel email
ℹ️ [15:30:22] root INFO: Fetching data to DataFrame
ℹ️ [15:30:22] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [15:30:22] root INFO: Fetched 17 rows for channel email
ℹ️ [15:30:22] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [15:30:22] root INFO: Running output job for channel sms
ℹ️ [15:30:22] root INFO: Fetching data to DataFrame
ℹ️ [15:30:22] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [15:30:22] root INFO: Fetched 8 rows for channel sms
ℹ️ [15:30:22] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [15:30:22] root INFO: Running output job for channel push
ℹ️ [15:30:22] root INFO: Fetching data to DataFrame
ℹ️ [15:30:22] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [15:30:22] root INFO: Fetched 17 rows for channel push
ℹ️ [15:30:22] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [15:30:22] root INFO: Cleaning up DB connection
ℹ️ [15:59:11] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [15:59:11] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [15:59:11] root INFO: Calculation complete: 3 steps.
ℹ️ [15:59:11] root INFO: Calculating the number of waterfall steps.
ℹ️ [15:59:11] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [15:59:11] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [15:59:11] root INFO: Calculating the number of output steps.
ℹ️ [15:59:11] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [15:59:11] root INFO: Preparing logic for channel 'email'
ℹ️ [15:59:11] root INFO: Preparing logic for channel 'sms'
ℹ️ [15:59:11] root INFO: Preparing logic for channel 'push'
ℹ️ [15:59:11] root INFO: Calculation complete: 3 steps (files).
ℹ️ [15:59:11] root INFO: Using cached SQL statements.
ℹ️ [15:59:11] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:59:11] root INFO: Executing SQL statement
ℹ️ [15:59:12] root INFO: SQL execution finished in 1.09s
ℹ️ [15:59:12] root INFO: Executing eligibility SQL statement
ℹ️ [15:59:12] root INFO: Executing SQL statement
ℹ️ [15:59:12] root INFO: SQL execution finished in 0.50s
ℹ️ [15:59:12] root INFO: Executing eligibility SQL statement
ℹ️ [15:59:12] root INFO: Executing SQL statement
ℹ️ [15:59:13] root INFO: SQL execution finished in 0.17s
ℹ️ [15:59:13] root INFO: Using cached waterfall steps.
ℹ️ [15:59:13] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [15:59:13] root INFO: Fetching data to DataFrame
ℹ️ [15:59:13] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.47s
ℹ️ [15:59:13] root INFO: Fetching data to DataFrame
ℹ️ [15:59:13] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [15:59:13] root INFO: Fetching data to DataFrame
❌ [15:59:14] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed breakdown for email - loyalty

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),
flags AS (
    SELECT
      customer_id, 
      email_loyalty_1, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,
        SUM(CASE WHEN email_loyalty_1 = 0
            AND NOT ( email_promo_1 = 1 OR email_promo_2 = 1 )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  UNION ALL
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed breakdown for email - promo

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      AND NOT ( c.email_loyalty_1 = 1 )
),
flags AS (
    SELECT
      customer_id, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,
        SUM(CASE WHEN email_promo_1 = 0 AND email_promo_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,
        SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  ;': [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed breakdown for email - loyalty

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),
flags AS (
    SELECT
      customer_id, 
      email_loyalty_1, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,
        SUM(CASE WHEN email_loyalty_1 = 0
            AND NOT ( email_promo_1 = 1 OR email_promo_2 = 1 )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  UNION ALL
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed breakdown for email - promo

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      AND NOT ( c.email_loyalty_1 = 1 )
),
flags AS (
    SELECT
      customer_id, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,
        SUM(CASE WHEN email_promo_1 = 0 AND email_promo_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,
        SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  ;': [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [15:59:14] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [15:59:14] root INFO: Fetching data to DataFrame
ℹ️ [15:59:14] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.40s
ℹ️ [15:59:14] root INFO: Fetching data to DataFrame
ℹ️ [15:59:14] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [15:59:14] root INFO: Fetching data to DataFrame
❌ [15:59:15] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed breakdown for email - loyalty

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),
flags AS (
    SELECT
      customer_id, 
      account_id, 
      email_loyalty_1, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,
        SUM(CASE WHEN email_loyalty_1 = 0
            AND NOT ( email_promo_1 = 1 OR email_promo_2 = 1 )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  UNION ALL
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed breakdown for email - promo

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      AND NOT ( c.email_loyalty_1 = 1 )
),
flags AS (
    SELECT
      customer_id, 
      account_id, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,
        SUM(CASE WHEN email_promo_1 = 0 AND email_promo_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,
        SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  ;': [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed breakdown for email - loyalty

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),
flags AS (
    SELECT
      customer_id, 
      account_id, 
      email_loyalty_1, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,
        SUM(CASE WHEN email_loyalty_1 = 0
            AND NOT ( email_promo_1 = 1 OR email_promo_2 = 1 )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  UNION ALL
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed breakdown for email - promo

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      AND NOT ( c.email_loyalty_1 = 1 )
),
flags AS (
    SELECT
      customer_id, 
      account_id, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,
        SUM(CASE WHEN email_promo_1 = 0 AND email_promo_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,
        SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  ;': [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [15:59:15] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [15:59:15] root INFO: Fetching data to DataFrame
ℹ️ [15:59:15] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.48s
ℹ️ [15:59:15] root INFO: Fetching data to DataFrame
ℹ️ [15:59:15] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [15:59:16] root INFO: Fetching data to DataFrame
❌ [15:59:16] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed breakdown for email - loyalty

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),
flags AS (
    SELECT
      region_id, 
      segment_id, 
      email_loyalty_1, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,
        SUM(CASE WHEN email_loyalty_1 = 0
            AND NOT ( email_promo_1 = 1 OR email_promo_2 = 1 )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  UNION ALL
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed breakdown for email - promo

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      AND NOT ( c.email_loyalty_1 = 1 )
),
flags AS (
    SELECT
      region_id, 
      segment_id, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,
        SUM(CASE WHEN email_promo_1 = 0 AND email_promo_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,
        SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  ;': [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed breakdown for email - loyalty

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),
flags AS (
    SELECT
      region_id, 
      segment_id, 
      email_loyalty_1, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,
        SUM(CASE WHEN email_loyalty_1 = 0
            AND NOT ( email_promo_1 = 1 OR email_promo_2 = 1 )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  UNION ALL
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed breakdown for email - promo

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      AND NOT ( c.email_loyalty_1 = 1 )
),
flags AS (
    SELECT
      region_id, 
      segment_id, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,
        SUM(CASE WHEN email_promo_1 = 0 AND email_promo_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,
        SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  ;': [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [15:59:16] root INFO: Using cached output steps.
ℹ️ [15:59:16] root INFO: Running output job for channel email
ℹ️ [15:59:16] root INFO: Fetching data to DataFrame
ℹ️ [15:59:16] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [15:59:16] root INFO: Fetched 17 rows for channel email
ℹ️ [15:59:16] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [15:59:16] root INFO: Running output job for channel sms
ℹ️ [15:59:16] root INFO: Fetching data to DataFrame
ℹ️ [15:59:16] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [15:59:16] root INFO: Fetched 8 rows for channel sms
ℹ️ [15:59:16] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [15:59:16] root INFO: Running output job for channel push
ℹ️ [15:59:16] root INFO: Fetching data to DataFrame
ℹ️ [15:59:16] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [15:59:16] root INFO: Fetched 17 rows for channel push
ℹ️ [15:59:16] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [15:59:17] root INFO: Cleaning up DB connection
ℹ️ [16:13:42] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [16:13:42] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [16:13:42] root INFO: Calculation complete: 3 steps.
ℹ️ [16:13:42] root INFO: Calculating the number of waterfall steps.
ℹ️ [16:13:42] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [16:13:42] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [16:13:42] root INFO: Calculating the number of output steps.
ℹ️ [16:13:42] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [16:13:42] root INFO: Preparing logic for channel 'email'
ℹ️ [16:13:42] root INFO: Preparing logic for channel 'sms'
ℹ️ [16:13:42] root INFO: Preparing logic for channel 'push'
ℹ️ [16:13:42] root INFO: Calculation complete: 3 steps (files).
ℹ️ [16:13:42] root INFO: Using cached SQL statements.
ℹ️ [16:13:42] root INFO: Dropping existing table eligibility_poc
ℹ️ [16:13:42] root INFO: Executing SQL statement
ℹ️ [16:13:44] root INFO: SQL execution finished in 1.27s
ℹ️ [16:13:44] root INFO: Executing eligibility SQL statement
ℹ️ [16:13:44] root INFO: Executing SQL statement
ℹ️ [16:13:44] root INFO: SQL execution finished in 0.48s
ℹ️ [16:13:44] root INFO: Executing eligibility SQL statement
ℹ️ [16:13:44] root INFO: Executing SQL statement
ℹ️ [16:13:44] root INFO: SQL execution finished in 0.15s
ℹ️ [16:13:44] root INFO: Using cached waterfall steps.
ℹ️ [16:13:44] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [16:13:44] root INFO: Fetching data to DataFrame
❌ [16:13:45] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),
flags AS (
    SELECT
        customer_id, 
        main_BA_1, 
        main_BA_2
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'main_BA_1' AS check_name,
        SUM(CASE WHEN main_BA_1 = 0 AND main_BA_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'main_BA_2' AS check_name,
        SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r': [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),
flags AS (
    SELECT
        customer_id, 
        main_BA_1, 
        main_BA_2
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'main_BA_1' AS check_name,
        SUM(CASE WHEN main_BA_1 = 0 AND main_BA_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'main_BA_2' AS check_name,
        SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r': [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:13:45] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [16:13:45] root INFO: Fetching data to DataFrame
❌ [16:13:45] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),
flags AS (
    SELECT
        customer_id, 
        account_id, 
        main_BA_1, 
        main_BA_2
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'main_BA_1' AS check_name,
        SUM(CASE WHEN main_BA_1 = 0 AND main_BA_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'main_BA_2' AS check_name,
        SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r': [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),
flags AS (
    SELECT
        customer_id, 
        account_id, 
        main_BA_1, 
        main_BA_2
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'main_BA_1' AS check_name,
        SUM(CASE WHEN main_BA_1 = 0 AND main_BA_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'main_BA_2' AS check_name,
        SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r': [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:13:45] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [16:13:45] root INFO: Fetching data to DataFrame
❌ [16:13:45] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),
flags AS (
    SELECT
        region_id, 
        segment_id, 
        main_BA_1, 
        main_BA_2
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'main_BA_1' AS check_name,
        SUM(CASE WHEN main_BA_1 = 0 AND main_BA_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'main_BA_2' AS check_name,
        SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r': [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),
flags AS (
    SELECT
        region_id, 
        segment_id, 
        main_BA_1, 
        main_BA_2
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'main_BA_1' AS check_name,
        SUM(CASE WHEN main_BA_1 = 0 AND main_BA_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'main_BA_2' AS check_name,
        SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r': [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:13:46] root INFO: Using cached output steps.
ℹ️ [16:13:46] root INFO: Running output job for channel email
ℹ️ [16:13:46] root INFO: Fetching data to DataFrame
ℹ️ [16:13:46] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.65s
ℹ️ [16:13:46] root INFO: Fetched 17 rows for channel email
ℹ️ [16:13:46] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [16:13:46] root INFO: Running output job for channel sms
ℹ️ [16:13:46] root INFO: Fetching data to DataFrame
ℹ️ [16:13:46] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [16:13:46] root INFO: Fetched 8 rows for channel sms
ℹ️ [16:13:46] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [16:13:46] root INFO: Running output job for channel push
ℹ️ [16:13:46] root INFO: Fetching data to DataFrame
ℹ️ [16:13:47] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [16:13:47] root INFO: Fetched 17 rows for channel push
ℹ️ [16:13:47] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [16:13:47] root INFO: Cleaning up DB connection
ℹ️ [16:17:23] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [16:17:23] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [16:17:23] root INFO: Calculation complete: 3 steps.
ℹ️ [16:17:23] root INFO: Calculating the number of waterfall steps.
ℹ️ [16:17:23] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [16:17:23] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [16:17:23] root INFO: Calculating the number of output steps.
ℹ️ [16:17:23] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [16:17:23] root INFO: Preparing logic for channel 'email'
ℹ️ [16:17:23] root INFO: Preparing logic for channel 'sms'
ℹ️ [16:17:23] root INFO: Preparing logic for channel 'push'
ℹ️ [16:17:23] root INFO: Calculation complete: 3 steps (files).
ℹ️ [16:17:23] root INFO: Using cached SQL statements.
ℹ️ [16:17:23] root INFO: Dropping existing table eligibility_poc
ℹ️ [16:17:23] root INFO: Executing SQL statement
ℹ️ [16:17:25] root INFO: SQL execution finished in 1.43s
ℹ️ [16:17:25] root INFO: Executing eligibility SQL statement
ℹ️ [16:17:25] root INFO: Executing SQL statement
ℹ️ [16:17:25] root INFO: SQL execution finished in 0.63s
ℹ️ [16:17:25] root INFO: Executing eligibility SQL statement
ℹ️ [16:17:25] root INFO: Executing SQL statement
ℹ️ [16:17:25] root INFO: SQL execution finished in 0.17s
ℹ️ [16:17:25] root INFO: Using cached waterfall steps.
ℹ️ [16:17:25] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [16:17:25] root INFO: Fetching data to DataFrame
ℹ️ [16:17:26] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.48s
ℹ️ [16:17:26] root INFO: Fetching data to DataFrame
ℹ️ [16:17:26] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [16:17:26] root INFO: Fetching data to DataFrame
❌ [16:17:26] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed waterfall breakdown and regain for email - loyalty
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
) q
;
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed waterfall breakdown and regain for email - promo
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 AND c.email_promo_2 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
) q
;': [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed waterfall breakdown and regain for email - loyalty
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
) q
;
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed waterfall breakdown and regain for email - promo
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 AND c.email_promo_2 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
) q
;': [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:17:27] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [16:17:27] root INFO: Fetching data to DataFrame
ℹ️ [16:17:27] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.36s
ℹ️ [16:17:27] root INFO: Fetching data to DataFrame
ℹ️ [16:17:27] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.39s
ℹ️ [16:17:27] root INFO: Fetching data to DataFrame
❌ [16:17:28] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed waterfall breakdown and regain for email - loyalty
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
) q
;
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed waterfall breakdown and regain for email - promo
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 AND c.email_promo_2 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
) q
;': [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed waterfall breakdown and regain for email - loyalty
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
) q
;
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed waterfall breakdown and regain for email - promo
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 AND c.email_promo_2 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
) q
;': [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:17:28] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [16:17:28] root INFO: Fetching data to DataFrame
ℹ️ [16:17:28] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.38s
ℹ️ [16:17:28] root INFO: Fetching data to DataFrame
ℹ️ [16:17:29] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [16:17:29] root INFO: Fetching data to DataFrame
❌ [16:17:29] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed waterfall breakdown and regain for email - loyalty
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
) q
;
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed waterfall breakdown and regain for email - promo
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 AND c.email_promo_2 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
) q
;': [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed waterfall breakdown and regain for email - loyalty
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
) q
;
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed waterfall breakdown and regain for email - promo
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 AND c.email_promo_2 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
) q
;': [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:17:29] root INFO: Using cached output steps.
ℹ️ [16:17:29] root INFO: Running output job for channel email
ℹ️ [16:17:29] root INFO: Fetching data to DataFrame
ℹ️ [16:17:29] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [16:17:29] root INFO: Fetched 17 rows for channel email
ℹ️ [16:17:29] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [16:17:29] root INFO: Running output job for channel sms
ℹ️ [16:17:29] root INFO: Fetching data to DataFrame
ℹ️ [16:17:29] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [16:17:29] root INFO: Fetched 8 rows for channel sms
ℹ️ [16:17:29] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [16:17:29] root INFO: Running output job for channel push
ℹ️ [16:17:30] root INFO: Fetching data to DataFrame
ℹ️ [16:17:30] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.32s
ℹ️ [16:17:30] root INFO: Fetched 17 rows for channel push
ℹ️ [16:17:30] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [16:17:30] root INFO: Cleaning up DB connection
ℹ️ [16:25:04] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [16:25:04] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [16:25:04] root INFO: Calculation complete: 3 steps.
ℹ️ [16:25:04] root INFO: Calculating the number of waterfall steps.
ℹ️ [16:25:04] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [16:25:04] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [16:25:04] root INFO: Calculating the number of output steps.
ℹ️ [16:25:04] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [16:25:04] root INFO: Preparing logic for channel 'email'
ℹ️ [16:25:04] root INFO: Preparing logic for channel 'sms'
ℹ️ [16:25:04] root INFO: Preparing logic for channel 'push'
ℹ️ [16:25:04] root INFO: Calculation complete: 3 steps (files).
ℹ️ [16:25:04] root INFO: Using cached SQL statements.
ℹ️ [16:25:04] root INFO: Dropping existing table eligibility_poc
ℹ️ [16:25:04] root INFO: Executing SQL statement
ℹ️ [16:25:06] root INFO: SQL execution finished in 1.26s
ℹ️ [16:25:06] root INFO: Executing eligibility SQL statement
ℹ️ [16:25:06] root INFO: Executing SQL statement
ℹ️ [16:25:06] root INFO: SQL execution finished in 0.46s
ℹ️ [16:25:06] root INFO: Executing eligibility SQL statement
ℹ️ [16:25:06] root INFO: Executing SQL statement
ℹ️ [16:25:06] root INFO: SQL execution finished in 0.17s
ℹ️ [16:25:06] root INFO: Using cached waterfall steps.
ℹ️ [16:25:06] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [16:25:06] root INFO: Fetching data to DataFrame
ℹ️ [16:25:07] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.67s
ℹ️ [16:25:07] root INFO: Fetching data to DataFrame
ℹ️ [16:25:07] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.43s
ℹ️ [16:25:07] root INFO: Fetching data to DataFrame
ℹ️ [16:25:08] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.88s
ℹ️ [16:25:08] root INFO: Fetching data to DataFrame
ℹ️ [16:25:09] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [16:25:09] root INFO: Fetching data to DataFrame
ℹ️ [16:25:09] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.59s
ℹ️ [16:25:09] root INFO: Fetching data to DataFrame
❌ [16:25:10] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        push_promotions_1, 
        push_promotions_2, 
        push_surveys_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
    ) r
) metrics;': [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        push_promotions_1, 
        push_promotions_2, 
        push_surveys_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
    ) r
) metrics;': [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:25:10] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [16:25:10] root INFO: Fetching data to DataFrame
ℹ️ [16:25:10] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.38s
ℹ️ [16:25:10] root INFO: Fetching data to DataFrame
ℹ️ [16:25:10] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [16:25:10] root INFO: Fetching data to DataFrame
ℹ️ [16:25:11] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.59s
ℹ️ [16:25:11] root INFO: Fetching data to DataFrame
ℹ️ [16:25:11] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [16:25:11] root INFO: Fetching data to DataFrame
ℹ️ [16:25:12] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.56s
ℹ️ [16:25:12] root INFO: Fetching data to DataFrame
❌ [16:25:12] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        account_id, 
        push_promotions_1, 
        push_promotions_2, 
        push_surveys_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
    ) r
) metrics;': [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        account_id, 
        push_promotions_1, 
        push_promotions_2, 
        push_surveys_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
    ) r
) metrics;': [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:25:12] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [16:25:12] root INFO: Fetching data to DataFrame
ℹ️ [16:25:13] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.56s
ℹ️ [16:25:13] root INFO: Fetching data to DataFrame
ℹ️ [16:25:13] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [16:25:13] root INFO: Fetching data to DataFrame
ℹ️ [16:25:13] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.33s
ℹ️ [16:25:13] root INFO: Fetching data to DataFrame
ℹ️ [16:25:13] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [16:25:13] root INFO: Fetching data to DataFrame
ℹ️ [16:25:14] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.34s
ℹ️ [16:25:14] root INFO: Fetching data to DataFrame
❌ [16:25:14] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        region_id, 
        segment_id, 
        push_promotions_1, 
        push_promotions_2, 
        push_surveys_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
    ) r
) metrics;': [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        region_id, 
        segment_id, 
        push_promotions_1, 
        push_promotions_2, 
        push_surveys_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
    ) r
) metrics;': [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:25:14] root INFO: Using cached output steps.
ℹ️ [16:25:14] root INFO: Running output job for channel email
ℹ️ [16:25:14] root INFO: Fetching data to DataFrame
ℹ️ [16:25:14] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [16:25:14] root INFO: Fetched 17 rows for channel email
ℹ️ [16:25:14] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [16:25:14] root INFO: Running output job for channel sms
ℹ️ [16:25:14] root INFO: Fetching data to DataFrame
ℹ️ [16:25:15] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [16:25:15] root INFO: Fetched 8 rows for channel sms
ℹ️ [16:25:15] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [16:25:15] root INFO: Running output job for channel push
ℹ️ [16:25:15] root INFO: Fetching data to DataFrame
ℹ️ [16:25:15] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [16:25:15] root INFO: Fetched 17 rows for channel push
ℹ️ [16:25:15] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [16:25:15] root INFO: Cleaning up DB connection
ℹ️ [17:40:45] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [17:40:45] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [17:40:45] root INFO: Calculation complete: 3 steps.
ℹ️ [17:40:45] root INFO: Calculating the number of waterfall steps.
ℹ️ [17:40:45] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [17:40:45] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [17:40:45] root INFO: Calculating the number of output steps.
ℹ️ [17:40:45] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [17:40:45] root INFO: Preparing logic for channel 'email'
ℹ️ [17:40:45] root INFO: Preparing logic for channel 'sms'
ℹ️ [17:40:45] root INFO: Preparing logic for channel 'push'
ℹ️ [17:40:45] root INFO: Calculation complete: 3 steps (files).
ℹ️ [17:40:45] root INFO: Using cached SQL statements.
ℹ️ [17:40:45] root INFO: Dropping existing table eligibility_poc
ℹ️ [17:40:45] root INFO: Executing SQL statement
ℹ️ [17:40:46] root INFO: SQL execution finished in 1.42s
ℹ️ [17:40:46] root INFO: Executing eligibility SQL statement
ℹ️ [17:40:46] root INFO: Executing SQL statement
ℹ️ [17:40:47] root INFO: SQL execution finished in 0.48s
ℹ️ [17:40:47] root INFO: Executing eligibility SQL statement
ℹ️ [17:40:47] root INFO: Executing SQL statement
ℹ️ [17:40:47] root INFO: SQL execution finished in 0.19s
ℹ️ [17:40:47] root INFO: Using cached waterfall steps.
ℹ️ [17:40:47] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [17:40:47] root INFO: Fetching data to DataFrame
ℹ️ [17:40:48] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.62s
ℹ️ [17:40:48] root INFO: Fetching data to DataFrame
ℹ️ [17:40:48] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [17:40:48] root INFO: Fetching data to DataFrame
ℹ️ [17:40:49] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.66s
ℹ️ [17:40:49] root INFO: Fetching data to DataFrame
ℹ️ [17:40:49] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [17:40:49] root INFO: Fetching data to DataFrame
ℹ️ [17:40:50] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.70s
ℹ️ [17:40:50] root INFO: Fetching data to DataFrame
ℹ️ [17:40:50] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.56s
ℹ️ [17:40:50] root INFO: Waterfall report for 'customer_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id.xlsx
ℹ️ [17:40:50] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [17:40:50] root INFO: Fetching data to DataFrame
ℹ️ [17:40:51] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.56s
ℹ️ [17:40:51] root INFO: Fetching data to DataFrame
ℹ️ [17:40:51] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.44s
ℹ️ [17:40:51] root INFO: Fetching data to DataFrame
ℹ️ [17:40:52] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.78s
ℹ️ [17:40:52] root INFO: Fetching data to DataFrame
ℹ️ [17:40:53] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [17:40:53] root INFO: Fetching data to DataFrame
ℹ️ [17:40:53] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.64s
ℹ️ [17:40:53] root INFO: Fetching data to DataFrame
ℹ️ [17:40:54] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.73s
ℹ️ [17:40:54] root INFO: Waterfall report for 'customer_id_account_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id_account_id.xlsx
ℹ️ [17:40:54] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [17:40:54] root INFO: Fetching data to DataFrame
ℹ️ [17:40:54] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.46s
ℹ️ [17:40:54] root INFO: Fetching data to DataFrame
ℹ️ [17:40:55] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [17:40:55] root INFO: Fetching data to DataFrame
ℹ️ [17:40:55] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.37s
ℹ️ [17:40:55] root INFO: Fetching data to DataFrame
ℹ️ [17:40:55] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [17:40:55] root INFO: Fetching data to DataFrame
ℹ️ [17:40:56] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.35s
ℹ️ [17:40:56] root INFO: Fetching data to DataFrame
ℹ️ [17:40:56] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.34s
ℹ️ [17:40:56] root INFO: Waterfall report for 'region_id_segment_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_region_id_segment_id.xlsx
ℹ️ [17:40:56] root INFO: Using cached output steps.
ℹ️ [17:40:56] root INFO: Running output job for channel email
ℹ️ [17:40:56] root INFO: Fetching data to DataFrame
ℹ️ [17:40:56] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [17:40:56] root INFO: Fetched 17 rows for channel email
ℹ️ [17:40:56] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [17:40:56] root INFO: Running output job for channel sms
ℹ️ [17:40:56] root INFO: Fetching data to DataFrame
ℹ️ [17:40:57] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [17:40:57] root INFO: Fetched 8 rows for channel sms
ℹ️ [17:40:57] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [17:40:57] root INFO: Running output job for channel push
ℹ️ [17:40:57] root INFO: Fetching data to DataFrame
ℹ️ [17:40:57] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [17:40:57] root INFO: Fetched 17 rows for channel push
ℹ️ [17:40:57] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [17:40:57] root INFO: Cleaning up DB connection
ℹ️ [19:06:07] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [19:06:07] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [19:06:07] root INFO: Calculation complete: 3 steps.
ℹ️ [19:06:07] root INFO: Calculating the number of waterfall steps.
ℹ️ [19:06:07] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [19:06:07] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [19:06:07] root INFO: Calculating the number of output steps.
ℹ️ [19:06:07] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [19:06:07] root INFO: Preparing logic for channel 'email'
ℹ️ [19:06:07] root INFO: Preparing logic for channel 'sms'
ℹ️ [19:06:07] root INFO: Preparing logic for channel 'push'
ℹ️ [19:06:07] root INFO: Calculation complete: 3 steps (files).
ℹ️ [19:06:07] root INFO: Using cached SQL statements.
ℹ️ [19:06:07] root INFO: Dropping existing table eligibility_poc
ℹ️ [19:06:07] root INFO: Executing SQL statement
ℹ️ [19:06:08] root INFO: SQL execution finished in 0.98s
ℹ️ [19:06:08] root INFO: Executing eligibility SQL statement
ℹ️ [19:06:08] root INFO: Executing SQL statement
ℹ️ [19:06:09] root INFO: SQL execution finished in 0.69s
ℹ️ [19:06:09] root INFO: Executing eligibility SQL statement
ℹ️ [19:06:09] root INFO: Executing SQL statement
ℹ️ [19:06:09] root INFO: SQL execution finished in 0.15s
ℹ️ [19:06:09] root INFO: Using cached waterfall steps.
ℹ️ [19:06:09] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [19:06:09] root INFO: Fetching data to DataFrame
ℹ️ [19:06:09] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.48s
ℹ️ [19:06:09] root INFO: Fetching data to DataFrame
ℹ️ [19:06:10] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [19:06:10] root INFO: Fetching data to DataFrame
ℹ️ [19:06:10] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.51s
ℹ️ [19:06:10] root INFO: Fetching data to DataFrame
ℹ️ [19:06:10] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [19:06:10] root INFO: Fetching data to DataFrame
ℹ️ [19:06:11] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.53s
ℹ️ [19:06:11] root INFO: Fetching data to DataFrame
ℹ️ [19:06:11] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.57s
ℹ️ [19:06:12] root INFO: Waterfall report for 'customer_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id.xlsx
ℹ️ [19:06:12] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [19:06:12] root INFO: Fetching data to DataFrame
ℹ️ [19:06:12] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.56s
ℹ️ [19:06:12] root INFO: Fetching data to DataFrame
ℹ️ [19:06:13] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.36s
ℹ️ [19:06:13] root INFO: Fetching data to DataFrame
ℹ️ [19:06:13] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.53s
ℹ️ [19:06:13] root INFO: Fetching data to DataFrame
ℹ️ [19:06:13] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [19:06:13] root INFO: Fetching data to DataFrame
ℹ️ [19:06:14] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.89s
ℹ️ [19:06:14] root INFO: Fetching data to DataFrame
ℹ️ [19:06:15] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.49s
ℹ️ [19:06:15] root INFO: Waterfall report for 'customer_id_account_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id_account_id.xlsx
ℹ️ [19:06:15] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [19:06:15] root INFO: Fetching data to DataFrame
ℹ️ [19:06:15] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.34s
ℹ️ [19:06:15] root INFO: Fetching data to DataFrame
ℹ️ [19:06:15] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [19:06:15] root INFO: Fetching data to DataFrame
ℹ️ [19:06:16] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.31s
ℹ️ [19:06:16] root INFO: Fetching data to DataFrame
ℹ️ [19:06:16] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.26s
ℹ️ [19:06:16] root INFO: Fetching data to DataFrame
ℹ️ [19:06:16] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.31s
ℹ️ [19:06:16] root INFO: Fetching data to DataFrame
ℹ️ [19:06:17] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.31s
ℹ️ [19:06:17] root INFO: Waterfall report for 'region_id_segment_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_region_id_segment_id.xlsx
ℹ️ [19:06:17] root INFO: Using cached output steps.
ℹ️ [19:06:17] root INFO: Running output job for channel email
ℹ️ [19:06:17] root INFO: Fetching data to DataFrame
ℹ️ [19:06:17] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [19:06:17] root INFO: Fetched 17 rows for channel email
ℹ️ [19:06:17] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [19:06:17] root INFO: Running output job for channel sms
ℹ️ [19:06:17] root INFO: Fetching data to DataFrame
ℹ️ [19:06:17] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.14s
ℹ️ [19:06:17] root INFO: Fetched 8 rows for channel sms
ℹ️ [19:06:17] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [19:06:17] root INFO: Running output job for channel push
ℹ️ [19:06:17] root INFO: Fetching data to DataFrame
ℹ️ [19:06:17] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [19:06:17] root INFO: Fetched 17 rows for channel push
ℹ️ [19:06:17] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [19:06:17] root INFO: Cleaning up DB connection
ℹ️ [19:36:26] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [19:36:26] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [19:36:26] root INFO: Calculation complete: 3 steps.
ℹ️ [19:36:26] root INFO: Calculating the number of waterfall steps.
ℹ️ [19:36:26] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [19:36:27] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [19:36:27] root INFO: Calculating the number of output steps.
ℹ️ [19:36:27] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [19:36:27] root INFO: Preparing logic for channel 'email'
ℹ️ [19:36:27] root INFO: Preparing logic for channel 'sms'
ℹ️ [19:36:27] root INFO: Preparing logic for channel 'push'
ℹ️ [19:36:27] root INFO: Calculation complete: 3 steps (files).
ℹ️ [19:36:27] root INFO: Using cached SQL statements.
ℹ️ [19:36:27] root INFO: Dropping existing table eligibility_poc
ℹ️ [19:36:27] root INFO: Executing SQL statement
ℹ️ [19:36:28] root INFO: SQL execution finished in 0.99s
ℹ️ [19:36:28] root INFO: Executing eligibility SQL statement
ℹ️ [19:36:28] root INFO: Executing SQL statement
ℹ️ [19:36:28] root INFO: SQL execution finished in 0.45s
ℹ️ [19:36:28] root INFO: Executing eligibility SQL statement
ℹ️ [19:36:28] root INFO: Executing SQL statement
ℹ️ [19:36:28] root INFO: SQL execution finished in 0.17s
ℹ️ [19:36:28] root INFO: Using cached waterfall steps.
ℹ️ [19:36:28] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [19:36:28] root INFO: Fetching data to DataFrame
ℹ️ [19:36:29] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.52s
ℹ️ [19:36:29] root INFO: Fetching data to DataFrame
ℹ️ [19:36:29] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.32s
ℹ️ [19:36:29] root INFO: Fetching data to DataFrame
ℹ️ [19:36:30] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.76s
ℹ️ [19:36:30] root INFO: Fetching data to DataFrame
ℹ️ [19:36:30] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.33s
ℹ️ [19:36:30] root INFO: Fetching data to DataFrame
ℹ️ [19:36:31] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.60s
ℹ️ [19:36:31] root INFO: Fetching data to DataFrame
ℹ️ [19:36:31] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.53s
ℹ️ [19:36:31] root INFO: Waterfall report for 'customer_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id.xlsx
ℹ️ [19:36:32] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [19:36:32] root INFO: Fetching data to DataFrame
ℹ️ [19:36:32] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.40s
ℹ️ [19:36:32] root INFO: Fetching data to DataFrame
ℹ️ [19:36:32] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [19:36:32] root INFO: Fetching data to DataFrame
ℹ️ [19:36:33] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.53s
ℹ️ [19:36:33] root INFO: Fetching data to DataFrame
ℹ️ [19:36:33] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [19:36:33] root INFO: Fetching data to DataFrame
ℹ️ [19:36:34] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.55s
ℹ️ [19:36:34] root INFO: Fetching data to DataFrame
ℹ️ [19:36:34] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.57s
ℹ️ [19:36:34] root INFO: Waterfall report for 'customer_id_account_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id_account_id.xlsx
ℹ️ [19:36:34] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [19:36:34] root INFO: Fetching data to DataFrame
ℹ️ [19:36:35] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.36s
ℹ️ [19:36:35] root INFO: Fetching data to DataFrame
ℹ️ [19:36:35] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [19:36:35] root INFO: Fetching data to DataFrame
ℹ️ [19:36:35] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.29s
ℹ️ [19:36:35] root INFO: Fetching data to DataFrame
ℹ️ [19:36:35] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [19:36:35] root INFO: Fetching data to DataFrame
ℹ️ [19:36:36] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.30s
ℹ️ [19:36:36] root INFO: Fetching data to DataFrame
ℹ️ [19:36:36] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.31s
ℹ️ [19:36:36] root INFO: Waterfall report for 'region_id_segment_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_region_id_segment_id.xlsx
ℹ️ [19:36:36] root INFO: Using cached output steps.
ℹ️ [19:36:36] root INFO: Running output job for channel email
ℹ️ [19:36:36] root INFO: Fetching data to DataFrame
ℹ️ [19:36:36] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [19:36:36] root INFO: Fetched 17 rows for channel email
ℹ️ [19:36:36] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [19:36:36] root INFO: Running output job for channel sms
ℹ️ [19:36:36] root INFO: Fetching data to DataFrame
ℹ️ [19:36:36] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.14s
ℹ️ [19:36:36] root INFO: Fetched 8 rows for channel sms
ℹ️ [19:36:36] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [19:36:36] root INFO: Running output job for channel push
ℹ️ [19:36:36] root INFO: Fetching data to DataFrame
ℹ️ [19:36:37] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [19:36:37] root INFO: Fetched 17 rows for channel push
ℹ️ [19:36:37] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [19:36:37] root INFO: Cleaning up DB connection
ℹ️ [19:55:45] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [19:55:45] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [19:55:45] root INFO: Calculation complete: 3 steps.
ℹ️ [19:55:45] root INFO: Calculating the number of waterfall steps.
ℹ️ [19:55:45] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [19:55:45] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [19:55:45] root INFO: Calculating the number of output steps.
ℹ️ [19:55:45] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [19:55:45] root INFO: Preparing logic for channel 'email'
ℹ️ [19:55:45] root INFO: Preparing logic for channel 'sms'
ℹ️ [19:55:45] root INFO: Preparing logic for channel 'push'
ℹ️ [19:55:45] root INFO: Calculation complete: 3 steps (files).
ℹ️ [19:55:45] root INFO: Using cached SQL statements.
ℹ️ [19:55:45] root INFO: Dropping existing table eligibility_poc
ℹ️ [19:55:45] root INFO: Executing SQL statement
ℹ️ [19:55:46] root INFO: SQL execution finished in 0.90s
ℹ️ [19:55:46] root INFO: Executing eligibility SQL statement
ℹ️ [19:55:46] root INFO: Executing SQL statement
ℹ️ [19:55:47] root INFO: SQL execution finished in 0.46s
ℹ️ [19:55:47] root INFO: Executing eligibility SQL statement
ℹ️ [19:55:47] root INFO: Executing SQL statement
ℹ️ [19:55:47] root INFO: SQL execution finished in 0.17s
ℹ️ [19:55:47] root INFO: Using cached waterfall steps.
ℹ️ [19:55:47] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [19:55:47] root INFO: Fetching data to DataFrame
ℹ️ [19:55:47] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.47s
ℹ️ [19:55:47] root INFO: Fetching data to DataFrame
ℹ️ [19:55:48] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.28s
ℹ️ [19:55:48] root INFO: Fetching data to DataFrame
ℹ️ [19:55:48] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.54s
ℹ️ [19:55:48] root INFO: Fetching data to DataFrame
ℹ️ [19:55:49] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.26s
ℹ️ [19:55:49] root INFO: Fetching data to DataFrame
ℹ️ [19:55:49] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.56s
ℹ️ [19:55:49] root INFO: Fetching data to DataFrame
ℹ️ [19:55:50] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.69s
ℹ️ [19:55:50] root INFO: Waterfall report for 'customer_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id.xlsx
ℹ️ [19:55:50] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [19:55:50] root INFO: Fetching data to DataFrame
ℹ️ [19:55:50] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.53s
ℹ️ [19:55:50] root INFO: Fetching data to DataFrame
ℹ️ [19:55:51] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.32s
ℹ️ [19:55:51] root INFO: Fetching data to DataFrame
ℹ️ [19:55:51] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.53s
ℹ️ [19:55:51] root INFO: Fetching data to DataFrame
ℹ️ [19:55:52] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.24s
ℹ️ [19:55:52] root INFO: Fetching data to DataFrame
ℹ️ [19:55:52] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.53s
ℹ️ [19:55:52] root INFO: Fetching data to DataFrame
ℹ️ [19:55:53] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.54s
ℹ️ [19:55:53] root INFO: Waterfall report for 'customer_id_account_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id_account_id.xlsx
ℹ️ [19:55:53] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [19:55:53] root INFO: Fetching data to DataFrame
ℹ️ [19:55:53] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.36s
ℹ️ [19:55:53] root INFO: Fetching data to DataFrame
ℹ️ [19:55:53] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [19:55:53] root INFO: Fetching data to DataFrame
ℹ️ [19:55:54] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.33s
ℹ️ [19:55:54] root INFO: Fetching data to DataFrame
ℹ️ [19:55:54] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [19:55:54] root INFO: Fetching data to DataFrame
ℹ️ [19:55:54] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.31s
ℹ️ [19:55:54] root INFO: Fetching data to DataFrame
ℹ️ [19:55:55] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.31s
ℹ️ [19:55:55] root INFO: Waterfall report for 'region_id_segment_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_region_id_segment_id.xlsx
ℹ️ [19:55:55] root INFO: Using cached output steps.
ℹ️ [19:55:55] root INFO: Running output job for channel email
ℹ️ [19:55:55] root INFO: Fetching data to DataFrame
ℹ️ [19:55:55] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [19:55:55] root INFO: Fetched 17 rows for channel email
ℹ️ [19:55:55] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [19:55:55] root INFO: Running output job for channel sms
ℹ️ [19:55:55] root INFO: Fetching data to DataFrame
ℹ️ [19:55:55] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.14s
ℹ️ [19:55:55] root INFO: Fetched 8 rows for channel sms
ℹ️ [19:55:55] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [19:55:55] root INFO: Running output job for channel push
ℹ️ [19:55:55] root INFO: Fetching data to DataFrame
ℹ️ [19:55:55] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [19:55:55] root INFO: Fetched 17 rows for channel push
ℹ️ [19:55:55] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [19:55:55] root INFO: Cleaning up DB connection
ℹ️ [22:23:46] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [22:23:46] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [22:23:47] root INFO: Calculation complete: 3 steps.
ℹ️ [22:23:47] root INFO: Calculating the number of waterfall steps.
ℹ️ [22:23:47] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [22:23:47] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [22:23:47] root INFO: Calculating the number of output steps.
ℹ️ [22:23:47] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [22:23:47] root INFO: Preparing logic for channel 'email'
ℹ️ [22:23:47] root INFO: Preparing logic for channel 'sms'
ℹ️ [22:23:47] root INFO: Preparing logic for channel 'push'
ℹ️ [22:23:47] root INFO: Calculation complete: 3 steps (files).
ℹ️ [22:23:47] root INFO: Using cached SQL statements.
ℹ️ [22:23:47] root INFO: Dropping existing table eligibility_poc
ℹ️ [22:23:47] root INFO: Executing SQL statement
ℹ️ [22:23:59] root INFO: No existing eligibility table to drop
ℹ️ [22:23:59] root INFO: Executing eligibility SQL statement
ℹ️ [22:23:59] root INFO: Executing SQL statement
ℹ️ [22:25:15] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [22:25:15] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [22:25:15] root INFO: Calculation complete: 3 steps.
ℹ️ [22:25:15] root INFO: Calculating the number of waterfall steps.
ℹ️ [22:25:15] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [22:25:15] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [22:25:15] root INFO: Calculating the number of output steps.
ℹ️ [22:25:15] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [22:25:15] root INFO: Preparing logic for channel 'email'
ℹ️ [22:25:15] root INFO: Preparing logic for channel 'sms'
ℹ️ [22:25:15] root INFO: Preparing logic for channel 'push'
ℹ️ [22:25:15] root INFO: Calculation complete: 3 steps (files).
ℹ️ [22:25:15] root INFO: Using cached SQL statements.
ℹ️ [22:25:15] root INFO: Dropping existing table eligibility_poc
ℹ️ [22:25:15] root INFO: Executing SQL statement
ℹ️ [22:25:16] root INFO: SQL execution finished in 1.30s
ℹ️ [22:25:16] root INFO: Executing eligibility SQL statement
ℹ️ [22:25:16] root INFO: Executing SQL statement
ℹ️ [22:25:17] root INFO: SQL execution finished in 1.13s
ℹ️ [22:25:18] root INFO: Executing eligibility SQL statement
ℹ️ [22:25:18] root INFO: Executing SQL statement
ℹ️ [22:25:18] root INFO: SQL execution finished in 0.17s
ℹ️ [22:25:18] root INFO: Using cached waterfall steps.
ℹ️ [22:25:18] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [22:25:18] root INFO: Fetching data to DataFrame
ℹ️ [22:25:18] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.55s
ℹ️ [22:25:18] root INFO: Fetching data to DataFrame
ℹ️ [22:25:19] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [22:25:19] root INFO: Fetching data to DataFrame
ℹ️ [22:25:19] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.57s
ℹ️ [22:25:19] root INFO: Fetching data to DataFrame
ℹ️ [22:25:19] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [22:25:19] root INFO: Fetching data to DataFrame
ℹ️ [22:25:20] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.72s
ℹ️ [22:25:20] root INFO: Fetching data to DataFrame
ℹ️ [22:25:21] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.75s
ℹ️ [22:25:21] root INFO: Waterfall report for 'customer_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id.xlsx
ℹ️ [22:25:21] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [22:25:21] root INFO: Fetching data to DataFrame
ℹ️ [22:25:22] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.44s
ℹ️ [22:25:22] root INFO: Fetching data to DataFrame
ℹ️ [22:25:22] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [22:25:22] root INFO: Fetching data to DataFrame
ℹ️ [22:25:22] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.58s
ℹ️ [22:25:22] root INFO: Fetching data to DataFrame
ℹ️ [22:25:23] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [22:25:23] root INFO: Fetching data to DataFrame
ℹ️ [22:25:23] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.64s
ℹ️ [22:25:23] root INFO: Fetching data to DataFrame
ℹ️ [22:25:24] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.71s
ℹ️ [22:25:24] root INFO: Waterfall report for 'customer_id_account_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id_account_id.xlsx
ℹ️ [22:25:24] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [22:25:24] root INFO: Fetching data to DataFrame
ℹ️ [22:25:25] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.60s
ℹ️ [22:25:25] root INFO: Fetching data to DataFrame
ℹ️ [22:25:25] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.37s
ℹ️ [22:25:25] root INFO: Fetching data to DataFrame
ℹ️ [22:25:26] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.45s
ℹ️ [22:25:26] root INFO: Fetching data to DataFrame
ℹ️ [22:25:26] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.41s
ℹ️ [22:25:26] root INFO: Fetching data to DataFrame
ℹ️ [22:25:26] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.42s
ℹ️ [22:25:26] root INFO: Fetching data to DataFrame
ℹ️ [22:25:27] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.52s
ℹ️ [22:25:27] root INFO: Waterfall report for 'region_id_segment_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_region_id_segment_id.xlsx
ℹ️ [22:25:27] root INFO: Using cached output steps.
ℹ️ [22:25:27] root INFO: Running output job for channel email
ℹ️ [22:25:27] root INFO: Fetching data to DataFrame
ℹ️ [22:25:27] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [22:25:27] root INFO: Fetched 17 rows for channel email
ℹ️ [22:25:27] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [22:25:27] root INFO: Running output job for channel sms
ℹ️ [22:25:27] root INFO: Fetching data to DataFrame
ℹ️ [22:25:28] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.26s
ℹ️ [22:25:28] root INFO: Fetched 8 rows for channel sms
ℹ️ [22:25:28] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [22:25:28] root INFO: Running output job for channel push
ℹ️ [22:25:28] root INFO: Fetching data to DataFrame
ℹ️ [22:25:28] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.34s
ℹ️ [22:25:28] root INFO: Fetched 17 rows for channel push
ℹ️ [22:25:28] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [22:25:28] root INFO: Cleaning up DB connection
ℹ️ [23:38:39] root INFO: Executing: DROP TABLE segments;
ℹ️ [23:38:39] root INFO: Executing SQL statement
ℹ️ [23:38:40] root INFO: SQL execution finished in 1.13s
ℹ️ [23:38:40] root INFO: Executing: DROP TABLE regions;
ℹ️ [23:38:40] root INFO: Executing SQL statement
ℹ️ [23:38:41] root INFO: SQL execution finished in 0.32s
ℹ️ [23:38:41] root INFO: Executing: DROP TABLE accounts;
ℹ️ [23:38:41] root INFO: Executing SQL statement
ℹ️ [23:38:41] root INFO: SQL execution finished in 0.28s
ℹ️ [23:38:41] root INFO: Executing: DROP TABLE customers;
ℹ️ [23:38:41] root INFO: Executing SQL statement
ℹ️ [23:38:41] root INFO: SQL execution finished in 0.24s
ℹ️ [23:38:41] root INFO: Executing: CREATE TABLE customers (customer_id INTEGER, status VARCHAR(20));
ℹ️ [23:38:41] root INFO: Executing SQL statement
ℹ️ [23:38:42] root INFO: SQL execution finished in 0.26s
ℹ️ [23:38:42] root INFO: Executing: CREATE TABLE accounts (customer_id INTEGER, account_id INTEGER, acct_type VARCHAR(20));
ℹ️ [23:38:42] root INFO: Executing SQL statement
ℹ️ [23:38:42] root INFO: SQL execution finished in 0.22s
ℹ️ [23:38:42] root INFO: Executing: CREATE TABLE regions (customer_id INTEGER, region_id INTEGER, region_type VARCHAR(20));
ℹ️ [23:38:42] root INFO: Executing SQL statement
ℹ️ [23:38:42] root INFO: SQL execution finished in 0.18s
ℹ️ [23:38:42] root INFO: Executing: CREATE TABLE segments (customer_id INTEGER, segment_id INTEGER, segment_flag VARCHAR(20));
ℹ️ [23:38:42] root INFO: Executing SQL statement
ℹ️ [23:38:42] root INFO: SQL execution finished in 0.36s
ℹ️ [23:38:42] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (6, 'Inactive');
ℹ️ [23:38:42] root INFO: Executing SQL statement
ℹ️ [23:38:42] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:42] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (7, 'Active');
ℹ️ [23:38:42] root INFO: Executing SQL statement
ℹ️ [23:38:43] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:43] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (8, 'Pending');
ℹ️ [23:38:43] root INFO: Executing SQL statement
ℹ️ [23:38:43] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:43] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (9, 'Inactive');
ℹ️ [23:38:43] root INFO: Executing SQL statement
ℹ️ [23:38:43] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:43] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (10, 'Active');
ℹ️ [23:38:43] root INFO: Executing SQL statement
ℹ️ [23:38:43] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:43] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (11, 'Pending');
ℹ️ [23:38:43] root INFO: Executing SQL statement
ℹ️ [23:38:43] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:43] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (12, 'Inactive');
ℹ️ [23:38:43] root INFO: Executing SQL statement
ℹ️ [23:38:43] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:43] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (13, 'Active');
ℹ️ [23:38:43] root INFO: Executing SQL statement
ℹ️ [23:38:43] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:43] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (14, 'Pending');
ℹ️ [23:38:43] root INFO: Executing SQL statement
ℹ️ [23:38:43] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:43] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (15, 'Inactive');
ℹ️ [23:38:43] root INFO: Executing SQL statement
ℹ️ [23:38:43] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:43] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (16, 'Active');
ℹ️ [23:38:43] root INFO: Executing SQL statement
ℹ️ [23:38:43] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:43] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (17, 'Pending');
ℹ️ [23:38:43] root INFO: Executing SQL statement
ℹ️ [23:38:43] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:43] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (18, 'Inactive');
ℹ️ [23:38:43] root INFO: Executing SQL statement
ℹ️ [23:38:43] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:43] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (19, 'Active');
ℹ️ [23:38:43] root INFO: Executing SQL statement
ℹ️ [23:38:44] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:44] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (20, 'Pending');
ℹ️ [23:38:44] root INFO: Executing SQL statement
ℹ️ [23:38:44] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:44] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (21, 'Inactive');
ℹ️ [23:38:44] root INFO: Executing SQL statement
ℹ️ [23:38:44] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:44] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (22, 'Active');
ℹ️ [23:38:44] root INFO: Executing SQL statement
ℹ️ [23:38:44] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:44] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (23, 'Pending');
ℹ️ [23:38:44] root INFO: Executing SQL statement
ℹ️ [23:38:44] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:44] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (24, 'Inactive');
ℹ️ [23:38:44] root INFO: Executing SQL statement
ℹ️ [23:38:44] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:44] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (25, 'Active');
ℹ️ [23:38:44] root INFO: Executing SQL statement
ℹ️ [23:38:44] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:44] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (26, 'Pending');
ℹ️ [23:38:44] root INFO: Executing SQL statement
ℹ️ [23:38:44] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:44] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (27, 'Inactive');
ℹ️ [23:38:44] root INFO: Executing SQL statement
ℹ️ [23:38:44] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:44] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (28, 'Active');
ℹ️ [23:38:44] root INFO: Executing SQL statement
ℹ️ [23:38:44] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:44] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (29, 'Pending');
ℹ️ [23:38:44] root INFO: Executing SQL statement
ℹ️ [23:38:44] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:44] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (30, 'Inactive');
ℹ️ [23:38:44] root INFO: Executing SQL statement
ℹ️ [23:38:44] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:44] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (31, 'Active');
ℹ️ [23:38:44] root INFO: Executing SQL statement
ℹ️ [23:38:45] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:45] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (32, 'Pending');
ℹ️ [23:38:45] root INFO: Executing SQL statement
ℹ️ [23:38:45] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:45] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (33, 'Inactive');
ℹ️ [23:38:45] root INFO: Executing SQL statement
ℹ️ [23:38:45] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:45] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (34, 'Active');
ℹ️ [23:38:45] root INFO: Executing SQL statement
ℹ️ [23:38:45] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:45] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (35, 'Pending');
ℹ️ [23:38:45] root INFO: Executing SQL statement
ℹ️ [23:38:45] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:45] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (36, 'Inactive');
ℹ️ [23:38:45] root INFO: Executing SQL statement
ℹ️ [23:38:45] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:45] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (37, 'Active');
ℹ️ [23:38:45] root INFO: Executing SQL statement
ℹ️ [23:38:45] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:45] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (38, 'Pending');
ℹ️ [23:38:45] root INFO: Executing SQL statement
ℹ️ [23:38:45] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:45] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (39, 'Inactive');
ℹ️ [23:38:45] root INFO: Executing SQL statement
ℹ️ [23:38:45] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:45] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (40, 'Active');
ℹ️ [23:38:45] root INFO: Executing SQL statement
ℹ️ [23:38:46] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:46] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (41, 'Pending');
ℹ️ [23:38:46] root INFO: Executing SQL statement
ℹ️ [23:38:46] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:46] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (42, 'Inactive');
ℹ️ [23:38:46] root INFO: Executing SQL statement
ℹ️ [23:38:46] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:46] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (43, 'Active');
ℹ️ [23:38:46] root INFO: Executing SQL statement
ℹ️ [23:38:46] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:46] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (44, 'Pending');
ℹ️ [23:38:46] root INFO: Executing SQL statement
ℹ️ [23:38:46] root INFO: SQL execution finished in 0.14s
ℹ️ [23:38:46] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (45, 'Inactive');
ℹ️ [23:38:46] root INFO: Executing SQL statement
ℹ️ [23:38:46] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:46] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (46, 'Active');
ℹ️ [23:38:46] root INFO: Executing SQL statement
ℹ️ [23:38:46] root INFO: SQL execution finished in 0.14s
ℹ️ [23:38:46] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (47, 'Pending');
ℹ️ [23:38:46] root INFO: Executing SQL statement
ℹ️ [23:38:46] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:46] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (48, 'Inactive');
ℹ️ [23:38:46] root INFO: Executing SQL statement
ℹ️ [23:38:46] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:46] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (49, 'Active');
ℹ️ [23:38:46] root INFO: Executing SQL statement
ℹ️ [23:38:47] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:47] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (50, 'Pending');
ℹ️ [23:38:47] root INFO: Executing SQL statement
ℹ️ [23:38:47] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:47] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (51, 'Inactive');
ℹ️ [23:38:47] root INFO: Executing SQL statement
ℹ️ [23:38:47] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:47] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (52, 'Active');
ℹ️ [23:38:47] root INFO: Executing SQL statement
ℹ️ [23:38:47] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:47] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (53, 'Pending');
ℹ️ [23:38:47] root INFO: Executing SQL statement
ℹ️ [23:38:47] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:47] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (54, 'Inactive');
ℹ️ [23:38:47] root INFO: Executing SQL statement
ℹ️ [23:38:47] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:47] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (55, 'Active');
ℹ️ [23:38:47] root INFO: Executing SQL statement
ℹ️ [23:38:47] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:47] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (6, 306, 'Savings');
ℹ️ [23:38:47] root INFO: Executing SQL statement
ℹ️ [23:38:47] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:47] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (7, 307, 'Checking');
ℹ️ [23:38:47] root INFO: Executing SQL statement
ℹ️ [23:38:47] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:47] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (8, 308, 'Savings');
ℹ️ [23:38:47] root INFO: Executing SQL statement
ℹ️ [23:38:47] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:47] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (9, 309, 'Checking');
ℹ️ [23:38:47] root INFO: Executing SQL statement
ℹ️ [23:38:48] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:48] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (10, 310, 'Savings');
ℹ️ [23:38:48] root INFO: Executing SQL statement
ℹ️ [23:38:48] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:48] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (11, 311, 'Checking');
ℹ️ [23:38:48] root INFO: Executing SQL statement
ℹ️ [23:38:48] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:48] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (12, 312, 'Savings');
ℹ️ [23:38:48] root INFO: Executing SQL statement
ℹ️ [23:38:48] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:48] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (13, 313, 'Checking');
ℹ️ [23:38:48] root INFO: Executing SQL statement
ℹ️ [23:38:48] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:48] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (14, 314, 'Savings');
ℹ️ [23:38:48] root INFO: Executing SQL statement
ℹ️ [23:38:48] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:48] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (15, 315, 'Checking');
ℹ️ [23:38:48] root INFO: Executing SQL statement
ℹ️ [23:38:48] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:48] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (16, 316, 'Savings');
ℹ️ [23:38:48] root INFO: Executing SQL statement
ℹ️ [23:38:48] root INFO: SQL execution finished in 0.14s
ℹ️ [23:38:48] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (17, 317, 'Checking');
ℹ️ [23:38:48] root INFO: Executing SQL statement
ℹ️ [23:38:48] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:48] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (18, 318, 'Savings');
ℹ️ [23:38:48] root INFO: Executing SQL statement
ℹ️ [23:38:49] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:49] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (19, 319, 'Checking');
ℹ️ [23:38:49] root INFO: Executing SQL statement
ℹ️ [23:38:49] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:49] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (20, 320, 'Savings');
ℹ️ [23:38:49] root INFO: Executing SQL statement
ℹ️ [23:38:49] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:49] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (21, 321, 'Checking');
ℹ️ [23:38:49] root INFO: Executing SQL statement
ℹ️ [23:38:49] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:49] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (22, 322, 'Savings');
ℹ️ [23:38:49] root INFO: Executing SQL statement
ℹ️ [23:38:49] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:49] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (23, 323, 'Checking');
ℹ️ [23:38:49] root INFO: Executing SQL statement
ℹ️ [23:38:49] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:49] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (24, 324, 'Savings');
ℹ️ [23:38:49] root INFO: Executing SQL statement
ℹ️ [23:38:49] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:49] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (25, 325, 'Checking');
ℹ️ [23:38:49] root INFO: Executing SQL statement
ℹ️ [23:38:49] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:49] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (26, 326, 'Savings');
ℹ️ [23:38:49] root INFO: Executing SQL statement
ℹ️ [23:38:49] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:49] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (27, 327, 'Checking');
ℹ️ [23:38:49] root INFO: Executing SQL statement
ℹ️ [23:38:50] root INFO: SQL execution finished in 0.16s
ℹ️ [23:38:50] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (28, 328, 'Savings');
ℹ️ [23:38:50] root INFO: Executing SQL statement
ℹ️ [23:38:50] root INFO: SQL execution finished in 0.14s
ℹ️ [23:38:50] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (29, 329, 'Checking');
ℹ️ [23:38:50] root INFO: Executing SQL statement
ℹ️ [23:38:50] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:50] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (30, 330, 'Savings');
ℹ️ [23:38:50] root INFO: Executing SQL statement
ℹ️ [23:38:50] root INFO: SQL execution finished in 0.14s
ℹ️ [23:38:50] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (31, 331, 'Checking');
ℹ️ [23:38:50] root INFO: Executing SQL statement
ℹ️ [23:38:50] root INFO: SQL execution finished in 0.16s
ℹ️ [23:38:50] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (32, 332, 'Savings');
ℹ️ [23:38:50] root INFO: Executing SQL statement
ℹ️ [23:38:50] root INFO: SQL execution finished in 0.14s
ℹ️ [23:38:50] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (33, 333, 'Checking');
ℹ️ [23:38:50] root INFO: Executing SQL statement
ℹ️ [23:38:51] root INFO: SQL execution finished in 0.16s
ℹ️ [23:38:51] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (34, 334, 'Savings');
ℹ️ [23:38:51] root INFO: Executing SQL statement
ℹ️ [23:38:51] root INFO: SQL execution finished in 0.16s
ℹ️ [23:38:51] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (35, 335, 'Checking');
ℹ️ [23:38:51] root INFO: Executing SQL statement
ℹ️ [23:38:51] root INFO: SQL execution finished in 0.14s
ℹ️ [23:38:51] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (36, 336, 'Savings');
ℹ️ [23:38:51] root INFO: Executing SQL statement
ℹ️ [23:38:51] root INFO: SQL execution finished in 0.18s
ℹ️ [23:38:51] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (37, 337, 'Checking');
ℹ️ [23:38:51] root INFO: Executing SQL statement
ℹ️ [23:38:51] root INFO: SQL execution finished in 0.16s
ℹ️ [23:38:51] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (38, 338, 'Savings');
ℹ️ [23:38:51] root INFO: Executing SQL statement
ℹ️ [23:38:51] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:51] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (39, 339, 'Checking');
ℹ️ [23:38:51] root INFO: Executing SQL statement
ℹ️ [23:38:51] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:51] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (40, 340, 'Savings');
ℹ️ [23:38:51] root INFO: Executing SQL statement
ℹ️ [23:38:52] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:52] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (41, 341, 'Checking');
ℹ️ [23:38:52] root INFO: Executing SQL statement
ℹ️ [23:38:52] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:52] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (42, 342, 'Savings');
ℹ️ [23:38:52] root INFO: Executing SQL statement
ℹ️ [23:38:52] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:52] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (43, 343, 'Checking');
ℹ️ [23:38:52] root INFO: Executing SQL statement
ℹ️ [23:38:52] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:52] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (44, 344, 'Savings');
ℹ️ [23:38:52] root INFO: Executing SQL statement
ℹ️ [23:38:52] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:52] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (45, 345, 'Checking');
ℹ️ [23:38:52] root INFO: Executing SQL statement
ℹ️ [23:38:52] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:52] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (46, 346, 'Savings');
ℹ️ [23:38:52] root INFO: Executing SQL statement
ℹ️ [23:38:52] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:52] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (47, 347, 'Checking');
ℹ️ [23:38:52] root INFO: Executing SQL statement
ℹ️ [23:38:52] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:52] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (48, 348, 'Savings');
ℹ️ [23:38:52] root INFO: Executing SQL statement
ℹ️ [23:38:52] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:52] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (49, 349, 'Checking');
ℹ️ [23:38:52] root INFO: Executing SQL statement
ℹ️ [23:38:52] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:52] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (50, 350, 'Savings');
ℹ️ [23:38:52] root INFO: Executing SQL statement
ℹ️ [23:38:53] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:53] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (51, 351, 'Checking');
ℹ️ [23:38:53] root INFO: Executing SQL statement
ℹ️ [23:38:53] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:53] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (52, 352, 'Savings');
ℹ️ [23:38:53] root INFO: Executing SQL statement
ℹ️ [23:38:53] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:53] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (53, 353, 'Checking');
ℹ️ [23:38:53] root INFO: Executing SQL statement
ℹ️ [23:38:53] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:53] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (54, 354, 'Savings');
ℹ️ [23:38:53] root INFO: Executing SQL statement
ℹ️ [23:38:53] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:53] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (55, 355, 'Checking');
ℹ️ [23:38:53] root INFO: Executing SQL statement
ℹ️ [23:38:53] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:53] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (6, 60, 'South');
ℹ️ [23:38:53] root INFO: Executing SQL statement
ℹ️ [23:38:53] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:53] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (7, 70, 'East');
ℹ️ [23:38:53] root INFO: Executing SQL statement
ℹ️ [23:38:53] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:53] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (8, 80, 'West');
ℹ️ [23:38:53] root INFO: Executing SQL statement
ℹ️ [23:38:53] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:53] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (9, 90, 'North');
ℹ️ [23:38:53] root INFO: Executing SQL statement
ℹ️ [23:38:54] root INFO: SQL execution finished in 0.18s
ℹ️ [23:38:54] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (10, 100, 'South');
ℹ️ [23:38:54] root INFO: Executing SQL statement
ℹ️ [23:38:54] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:54] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (11, 110, 'East');
ℹ️ [23:38:54] root INFO: Executing SQL statement
ℹ️ [23:38:54] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:54] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (12, 120, 'West');
ℹ️ [23:38:54] root INFO: Executing SQL statement
ℹ️ [23:38:54] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:54] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (13, 130, 'North');
ℹ️ [23:38:54] root INFO: Executing SQL statement
ℹ️ [23:38:54] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:54] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (14, 140, 'South');
ℹ️ [23:38:54] root INFO: Executing SQL statement
ℹ️ [23:38:54] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:54] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (15, 150, 'East');
ℹ️ [23:38:54] root INFO: Executing SQL statement
ℹ️ [23:38:54] root INFO: SQL execution finished in 0.16s
ℹ️ [23:38:54] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (16, 160, 'West');
ℹ️ [23:38:54] root INFO: Executing SQL statement
ℹ️ [23:38:54] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:54] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (17, 170, 'North');
ℹ️ [23:38:54] root INFO: Executing SQL statement
ℹ️ [23:38:54] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:54] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (18, 180, 'South');
ℹ️ [23:38:54] root INFO: Executing SQL statement
ℹ️ [23:38:55] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:55] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (19, 190, 'East');
ℹ️ [23:38:55] root INFO: Executing SQL statement
ℹ️ [23:38:56] root INFO: SQL execution finished in 1.10s
ℹ️ [23:38:56] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (20, 200, 'West');
ℹ️ [23:38:56] root INFO: Executing SQL statement
ℹ️ [23:38:56] root INFO: SQL execution finished in 0.14s
ℹ️ [23:38:56] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (21, 210, 'North');
ℹ️ [23:38:56] root INFO: Executing SQL statement
ℹ️ [23:38:56] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:56] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (22, 220, 'South');
ℹ️ [23:38:56] root INFO: Executing SQL statement
ℹ️ [23:38:56] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:56] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (23, 230, 'East');
ℹ️ [23:38:56] root INFO: Executing SQL statement
ℹ️ [23:38:56] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:56] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (24, 240, 'West');
ℹ️ [23:38:56] root INFO: Executing SQL statement
ℹ️ [23:38:56] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:56] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (25, 250, 'North');
ℹ️ [23:38:56] root INFO: Executing SQL statement
ℹ️ [23:38:56] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:56] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (26, 260, 'South');
ℹ️ [23:38:56] root INFO: Executing SQL statement
ℹ️ [23:38:56] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:56] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (27, 270, 'East');
ℹ️ [23:38:56] root INFO: Executing SQL statement
ℹ️ [23:38:56] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:56] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (28, 280, 'West');
ℹ️ [23:38:56] root INFO: Executing SQL statement
ℹ️ [23:38:57] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:57] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (29, 290, 'North');
ℹ️ [23:38:57] root INFO: Executing SQL statement
ℹ️ [23:38:57] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:57] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (30, 300, 'South');
ℹ️ [23:38:57] root INFO: Executing SQL statement
ℹ️ [23:38:57] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:57] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (31, 310, 'East');
ℹ️ [23:38:57] root INFO: Executing SQL statement
ℹ️ [23:38:57] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:57] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (32, 320, 'West');
ℹ️ [23:38:57] root INFO: Executing SQL statement
ℹ️ [23:38:57] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:57] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (33, 330, 'North');
ℹ️ [23:38:57] root INFO: Executing SQL statement
ℹ️ [23:38:57] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:57] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (34, 340, 'South');
ℹ️ [23:38:57] root INFO: Executing SQL statement
ℹ️ [23:38:57] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:57] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (35, 350, 'East');
ℹ️ [23:38:57] root INFO: Executing SQL statement
ℹ️ [23:38:57] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:57] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (36, 360, 'West');
ℹ️ [23:38:57] root INFO: Executing SQL statement
ℹ️ [23:38:57] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:57] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (37, 370, 'North');
ℹ️ [23:38:57] root INFO: Executing SQL statement
ℹ️ [23:38:57] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:57] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (38, 380, 'South');
ℹ️ [23:38:57] root INFO: Executing SQL statement
ℹ️ [23:38:57] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:57] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (39, 390, 'East');
ℹ️ [23:38:57] root INFO: Executing SQL statement
ℹ️ [23:38:58] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:58] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (40, 400, 'West');
ℹ️ [23:38:58] root INFO: Executing SQL statement
ℹ️ [23:38:58] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:58] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (41, 410, 'North');
ℹ️ [23:38:58] root INFO: Executing SQL statement
ℹ️ [23:38:58] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:58] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (42, 420, 'South');
ℹ️ [23:38:58] root INFO: Executing SQL statement
ℹ️ [23:38:58] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:58] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (43, 430, 'East');
ℹ️ [23:38:58] root INFO: Executing SQL statement
ℹ️ [23:38:58] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:58] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (44, 440, 'West');
ℹ️ [23:38:58] root INFO: Executing SQL statement
ℹ️ [23:38:58] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:58] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (45, 450, 'North');
ℹ️ [23:38:58] root INFO: Executing SQL statement
ℹ️ [23:38:58] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:58] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (46, 460, 'South');
ℹ️ [23:38:58] root INFO: Executing SQL statement
ℹ️ [23:38:58] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:58] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (47, 470, 'East');
ℹ️ [23:38:58] root INFO: Executing SQL statement
ℹ️ [23:38:58] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:58] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (48, 480, 'West');
ℹ️ [23:38:58] root INFO: Executing SQL statement
ℹ️ [23:38:58] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:58] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (49, 490, 'North');
ℹ️ [23:38:58] root INFO: Executing SQL statement
ℹ️ [23:38:58] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:58] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (50, 500, 'South');
ℹ️ [23:38:58] root INFO: Executing SQL statement
ℹ️ [23:38:59] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:59] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (51, 510, 'East');
ℹ️ [23:38:59] root INFO: Executing SQL statement
ℹ️ [23:38:59] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:59] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (52, 520, 'West');
ℹ️ [23:38:59] root INFO: Executing SQL statement
ℹ️ [23:38:59] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:59] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (53, 530, 'North');
ℹ️ [23:38:59] root INFO: Executing SQL statement
ℹ️ [23:38:59] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:59] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (54, 540, 'South');
ℹ️ [23:38:59] root INFO: Executing SQL statement
ℹ️ [23:38:59] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:59] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (55, 550, 'East');
ℹ️ [23:38:59] root INFO: Executing SQL statement
ℹ️ [23:38:59] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:59] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (6, 6001, 'Promo1');
ℹ️ [23:38:59] root INFO: Executing SQL statement
ℹ️ [23:38:59] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:59] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (7, 6002, 'Promo2');
ℹ️ [23:38:59] root INFO: Executing SQL statement
ℹ️ [23:38:59] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:59] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (8, 6003, 'HighTx');
ℹ️ [23:38:59] root INFO: Executing SQL statement
ℹ️ [23:38:59] root INFO: SQL execution finished in 0.08s
ℹ️ [23:38:59] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (9, 6004, 'LowTx');
ℹ️ [23:38:59] root INFO: Executing SQL statement
ℹ️ [23:38:59] root INFO: SQL execution finished in 0.10s
ℹ️ [23:38:59] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (10, 6005, 'PromoA');
ℹ️ [23:38:59] root INFO: Executing SQL statement
ℹ️ [23:38:59] root INFO: SQL execution finished in 0.12s
ℹ️ [23:38:59] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (11, 6006, 'PromoB');
ℹ️ [23:38:59] root INFO: Executing SQL statement
ℹ️ [23:39:00] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:00] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (12, 6007, 'FlagA');
ℹ️ [23:39:00] root INFO: Executing SQL statement
ℹ️ [23:39:00] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:00] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (13, 6008, 'FlagB');
ℹ️ [23:39:00] root INFO: Executing SQL statement
ℹ️ [23:39:00] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:00] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (14, 6009, 'Promo1');
ℹ️ [23:39:00] root INFO: Executing SQL statement
ℹ️ [23:39:00] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:00] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (15, 6010, 'Promo2');
ℹ️ [23:39:00] root INFO: Executing SQL statement
ℹ️ [23:39:00] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:00] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (16, 6011, 'HighTx');
ℹ️ [23:39:00] root INFO: Executing SQL statement
ℹ️ [23:39:00] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:00] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (17, 6012, 'LowTx');
ℹ️ [23:39:00] root INFO: Executing SQL statement
ℹ️ [23:39:00] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:00] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (18, 6013, 'PromoA');
ℹ️ [23:39:00] root INFO: Executing SQL statement
ℹ️ [23:39:00] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:00] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (19, 6014, 'PromoB');
ℹ️ [23:39:00] root INFO: Executing SQL statement
ℹ️ [23:39:00] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:00] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (20, 6015, 'FlagA');
ℹ️ [23:39:00] root INFO: Executing SQL statement
ℹ️ [23:39:00] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:00] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (21, 6016, 'FlagB');
ℹ️ [23:39:00] root INFO: Executing SQL statement
ℹ️ [23:39:01] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:01] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (22, 6017, 'Promo1');
ℹ️ [23:39:01] root INFO: Executing SQL statement
ℹ️ [23:39:01] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:01] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (23, 6018, 'Promo2');
ℹ️ [23:39:01] root INFO: Executing SQL statement
ℹ️ [23:39:01] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:01] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (24, 6019, 'HighTx');
ℹ️ [23:39:01] root INFO: Executing SQL statement
ℹ️ [23:39:01] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:01] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (25, 6020, 'LowTx');
ℹ️ [23:39:01] root INFO: Executing SQL statement
ℹ️ [23:39:01] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:01] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (26, 6021, 'PromoA');
ℹ️ [23:39:01] root INFO: Executing SQL statement
ℹ️ [23:39:01] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:01] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (27, 6022, 'PromoB');
ℹ️ [23:39:01] root INFO: Executing SQL statement
ℹ️ [23:39:01] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:01] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (28, 6023, 'FlagA');
ℹ️ [23:39:01] root INFO: Executing SQL statement
ℹ️ [23:39:01] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:01] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (29, 6024, 'FlagB');
ℹ️ [23:39:01] root INFO: Executing SQL statement
ℹ️ [23:39:01] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:01] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (30, 6025, 'Promo1');
ℹ️ [23:39:01] root INFO: Executing SQL statement
ℹ️ [23:39:01] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:01] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (31, 6026, 'Promo2');
ℹ️ [23:39:01] root INFO: Executing SQL statement
ℹ️ [23:39:01] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:01] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (32, 6027, 'HighTx');
ℹ️ [23:39:01] root INFO: Executing SQL statement
ℹ️ [23:39:02] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:02] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (33, 6028, 'LowTx');
ℹ️ [23:39:02] root INFO: Executing SQL statement
ℹ️ [23:39:02] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:02] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (34, 6029, 'PromoA');
ℹ️ [23:39:02] root INFO: Executing SQL statement
ℹ️ [23:39:02] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:02] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (35, 6030, 'PromoB');
ℹ️ [23:39:02] root INFO: Executing SQL statement
ℹ️ [23:39:02] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:02] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (36, 6031, 'FlagA');
ℹ️ [23:39:02] root INFO: Executing SQL statement
ℹ️ [23:39:02] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:02] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (37, 6032, 'FlagB');
ℹ️ [23:39:02] root INFO: Executing SQL statement
ℹ️ [23:39:02] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:02] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (38, 6033, 'Promo1');
ℹ️ [23:39:02] root INFO: Executing SQL statement
ℹ️ [23:39:02] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:02] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (39, 6034, 'Promo2');
ℹ️ [23:39:02] root INFO: Executing SQL statement
ℹ️ [23:39:02] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:02] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (40, 6035, 'HighTx');
ℹ️ [23:39:02] root INFO: Executing SQL statement
ℹ️ [23:39:02] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:02] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (41, 6036, 'LowTx');
ℹ️ [23:39:02] root INFO: Executing SQL statement
ℹ️ [23:39:02] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:02] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (42, 6037, 'PromoA');
ℹ️ [23:39:02] root INFO: Executing SQL statement
ℹ️ [23:39:02] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:02] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (43, 6038, 'PromoB');
ℹ️ [23:39:02] root INFO: Executing SQL statement
ℹ️ [23:39:02] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:02] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (44, 6039, 'FlagA');
ℹ️ [23:39:02] root INFO: Executing SQL statement
ℹ️ [23:39:03] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:03] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (45, 6040, 'FlagB');
ℹ️ [23:39:03] root INFO: Executing SQL statement
ℹ️ [23:39:03] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:03] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (46, 6041, 'Promo1');
ℹ️ [23:39:03] root INFO: Executing SQL statement
ℹ️ [23:39:03] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:03] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (47, 6042, 'Promo2');
ℹ️ [23:39:03] root INFO: Executing SQL statement
ℹ️ [23:39:03] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:03] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (48, 6043, 'HighTx');
ℹ️ [23:39:03] root INFO: Executing SQL statement
ℹ️ [23:39:03] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:03] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (49, 6044, 'LowTx');
ℹ️ [23:39:03] root INFO: Executing SQL statement
ℹ️ [23:39:03] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:03] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (50, 6045, 'PromoA');
ℹ️ [23:39:03] root INFO: Executing SQL statement
ℹ️ [23:39:03] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:03] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (51, 6046, 'PromoB');
ℹ️ [23:39:03] root INFO: Executing SQL statement
ℹ️ [23:39:03] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:03] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (52, 6047, 'FlagA');
ℹ️ [23:39:03] root INFO: Executing SQL statement
ℹ️ [23:39:03] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:03] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (53, 6048, 'FlagB');
ℹ️ [23:39:03] root INFO: Executing SQL statement
ℹ️ [23:39:03] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:03] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (54, 6049, 'Promo1');
ℹ️ [23:39:03] root INFO: Executing SQL statement
ℹ️ [23:39:03] root INFO: SQL execution finished in 0.10s
ℹ️ [23:39:03] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (55, 6050, 'Promo2');
ℹ️ [23:39:03] root INFO: Executing SQL statement
ℹ️ [23:39:04] root INFO: SQL execution finished in 0.08s
ℹ️ [23:39:04] root INFO: Cleaning up DB connection
ℹ️ [23:39:04] root INFO: Test POC tables have been prepared.
ℹ️ [23:39:21] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:39:21] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:39:21] root INFO: Executing SQL statement
ℹ️ [23:39:22] root INFO: SQL execution finished in 0.95s
ℹ️ [23:39:22] root INFO: Executing eligibility SQL statement
ℹ️ [23:39:22] root INFO: Executing SQL statement
ℹ️ [23:39:22] root INFO: SQL execution finished in 0.51s
ℹ️ [23:39:22] root INFO: Executing eligibility SQL statement
ℹ️ [23:39:22] root INFO: Executing SQL statement
ℹ️ [23:39:22] root INFO: SQL execution finished in 0.16s
ℹ️ [23:39:22] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:39:23] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:39:23] root INFO: Fetching data to DataFrame
❌ [23:39:23] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1278] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1278] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1278] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:39:23] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:39:23] root INFO: Fetching data to DataFrame
❌ [23:39:23] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,account_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1278] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1278] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,account_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1278] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:39:23] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:39:23] root INFO: Fetching data to DataFrame
❌ [23:39:24] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    region_id,segment_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1278] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1278] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    region_id,segment_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1278] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:39:24] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:39:24] root INFO: Preparing logic for channel 'email'
ℹ️ [23:39:24] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:39:24] root INFO: Preparing logic for channel 'push'
ℹ️ [23:39:24] root INFO: Running output job for channel email
ℹ️ [23:39:24] root INFO: Fetching data to DataFrame
ℹ️ [23:39:24] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [23:39:24] root INFO: Fetched 17 rows for channel email
ℹ️ [23:39:24] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:39:24] root INFO: Running output job for channel sms
ℹ️ [23:39:24] root INFO: Fetching data to DataFrame
ℹ️ [23:39:24] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.12s
ℹ️ [23:39:24] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:39:24] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:39:24] root INFO: Running output job for channel push
ℹ️ [23:39:24] root INFO: Fetching data to DataFrame
ℹ️ [23:39:24] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.12s
ℹ️ [23:39:24] root INFO: Fetched 17 rows for channel push
ℹ️ [23:39:24] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:39:24] root INFO: Cleaning up DB connection
ℹ️ [10:03:06] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [10:03:06] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [10:03:06] root INFO: Calculation complete: 3 steps.
ℹ️ [10:03:06] root INFO: Calculating the number of waterfall steps.
ℹ️ [10:03:06] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [10:03:06] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [10:03:06] root INFO: Calculating the number of output steps.
ℹ️ [10:03:06] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [10:03:06] root INFO: Preparing logic for channel 'email'
ℹ️ [10:03:06] root INFO: Preparing logic for channel 'sms'
ℹ️ [10:03:06] root INFO: Preparing logic for channel 'push'
ℹ️ [10:03:06] root INFO: Calculation complete: 3 steps (files).
ℹ️ [10:03:06] root INFO: Using cached SQL statements.
ℹ️ [10:03:06] root INFO: Dropping existing table eligibility_poc
ℹ️ [10:03:06] root INFO: Executing SQL statement
ℹ️ [10:03:08] root INFO: SQL execution finished in 1.71s
ℹ️ [10:03:08] root INFO: Executing eligibility SQL statement
ℹ️ [10:03:08] root INFO: Executing SQL statement
ℹ️ [10:03:08] root INFO: SQL execution finished in 0.75s
ℹ️ [10:03:08] root INFO: Executing eligibility SQL statement
ℹ️ [10:03:08] root INFO: Executing SQL statement
ℹ️ [10:03:09] root INFO: SQL execution finished in 0.21s
ℹ️ [10:03:09] root INFO: Using cached waterfall steps.
ℹ️ [10:03:09] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [10:03:09] root INFO: Fetching data to DataFrame
❌ [10:03:09] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1280] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1280] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1280] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [10:03:09] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [10:03:09] root INFO: Fetching data to DataFrame
❌ [10:03:09] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,account_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1280] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1280] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,account_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1280] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [10:03:09] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [10:03:09] root INFO: Fetching data to DataFrame
❌ [10:03:10] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    region_id,segment_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1280] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1280] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    region_id,segment_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1280] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [10:03:10] root INFO: Using cached output steps.
ℹ️ [10:03:10] root INFO: Running output job for channel email
ℹ️ [10:03:10] root INFO: Fetching data to DataFrame
ℹ️ [10:03:10] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.17s
ℹ️ [10:03:10] root INFO: Fetched 17 rows for channel email
ℹ️ [10:03:10] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [10:03:10] root INFO: Running output job for channel sms
ℹ️ [10:03:10] root INFO: Fetching data to DataFrame
ℹ️ [10:03:10] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [10:03:10] root INFO: Fetched 8 rows for channel sms
ℹ️ [10:03:10] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [10:03:10] root INFO: Running output job for channel push
ℹ️ [10:03:10] root INFO: Fetching data to DataFrame
ℹ️ [10:03:11] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.27s
ℹ️ [10:03:11] root INFO: Fetched 17 rows for channel push
ℹ️ [10:03:11] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [10:03:11] root INFO: Cleaning up DB connection
ℹ️ [10:04:04] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [10:04:04] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [10:04:04] root INFO: Calculation complete: 3 steps.
ℹ️ [10:04:04] root INFO: Calculating the number of waterfall steps.
ℹ️ [10:04:04] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [10:04:04] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [10:04:04] root INFO: Calculating the number of output steps.
ℹ️ [10:04:04] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [10:04:04] root INFO: Preparing logic for channel 'email'
ℹ️ [10:04:04] root INFO: Preparing logic for channel 'sms'
ℹ️ [10:04:04] root INFO: Preparing logic for channel 'push'
ℹ️ [10:04:04] root INFO: Calculation complete: 3 steps (files).
ℹ️ [10:04:04] root INFO: Using cached SQL statements.
ℹ️ [10:04:04] root INFO: Dropping existing table eligibility_poc
ℹ️ [10:04:04] root INFO: Executing SQL statement
ℹ️ [10:04:05] root INFO: SQL execution finished in 1.14s
ℹ️ [10:04:05] root INFO: Executing eligibility SQL statement
ℹ️ [10:04:05] root INFO: Executing SQL statement
ℹ️ [10:04:06] root INFO: SQL execution finished in 0.61s
ℹ️ [10:04:06] root INFO: Executing eligibility SQL statement
ℹ️ [10:04:06] root INFO: Executing SQL statement
ℹ️ [10:04:06] root INFO: SQL execution finished in 0.43s
ℹ️ [10:04:06] root INFO: Using cached waterfall steps.
ℹ️ [10:04:06] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [10:04:06] root INFO: Fetching data to DataFrame
❌ [10:04:06] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1282] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1282] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1282] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [10:04:07] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [10:04:07] root INFO: Fetching data to DataFrame
❌ [10:04:07] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,account_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1282] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1282] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,account_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1282] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [10:04:07] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [10:04:07] root INFO: Fetching data to DataFrame
❌ [10:04:07] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    region_id,segment_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1282] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1282] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    region_id,segment_id,
    main_BA_1,main_BA_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'main_BA_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 0
               AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'regain' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 0
               AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'main_BA_1' AS check_name,
      SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    SELECT
      'remaining' AS stat_name,
      'main_BA_2' AS check_name,
      SUM(CASE WHEN main_BA_2 = 1AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
) metrics;': [Version 20.0.0.32] [Session 1282] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [10:04:07] root INFO: Using cached output steps.
ℹ️ [10:04:07] root INFO: Running output job for channel email
ℹ️ [10:04:07] root INFO: Fetching data to DataFrame
ℹ️ [10:04:07] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [10:04:07] root INFO: Fetched 17 rows for channel email
ℹ️ [10:04:07] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [10:04:07] root INFO: Running output job for channel sms
ℹ️ [10:04:07] root INFO: Fetching data to DataFrame
ℹ️ [10:04:08] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [10:04:08] root INFO: Fetched 8 rows for channel sms
ℹ️ [10:04:08] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [10:04:08] root INFO: Running output job for channel push
ℹ️ [10:04:08] root INFO: Fetching data to DataFrame
ℹ️ [10:04:08] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [10:04:08] root INFO: Fetched 17 rows for channel push
ℹ️ [10:04:08] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [10:04:08] root INFO: Cleaning up DB connection
ℹ️ [11:20:02] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [11:20:03] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [11:20:03] root INFO: Calculation complete: 3 steps.
ℹ️ [11:20:03] root INFO: Calculating the number of waterfall steps.
ℹ️ [11:20:03] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [11:20:03] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [11:20:03] root INFO: Calculating the number of output steps.
ℹ️ [11:20:03] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [11:20:03] root INFO: Preparing logic for channel 'email'
ℹ️ [11:20:03] root INFO: Preparing logic for channel 'sms'
ℹ️ [11:20:03] root INFO: Preparing logic for channel 'push'
ℹ️ [11:20:03] root INFO: Calculation complete: 3 steps (files).
ℹ️ [11:20:03] root INFO: Using cached SQL statements.
ℹ️ [11:20:03] root INFO: Dropping existing table eligibility_poc
ℹ️ [11:20:03] root INFO: Executing SQL statement
ℹ️ [11:24:11] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [11:24:11] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [11:24:11] root INFO: Calculation complete: 3 steps.
ℹ️ [11:24:11] root INFO: Calculating the number of waterfall steps.
ℹ️ [11:24:11] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [11:24:11] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [11:24:11] root INFO: Calculating the number of output steps.
ℹ️ [11:24:11] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [11:24:11] root INFO: Preparing logic for channel 'email'
ℹ️ [11:24:11] root INFO: Preparing logic for channel 'sms'
ℹ️ [11:24:11] root INFO: Preparing logic for channel 'push'
ℹ️ [11:24:11] root INFO: Calculation complete: 3 steps (files).
ℹ️ [11:24:11] root INFO: Using cached SQL statements.
ℹ️ [11:24:11] root INFO: Dropping existing table eligibility_poc
ℹ️ [11:24:11] root INFO: Executing SQL statement
ℹ️ [11:24:12] root INFO: SQL execution finished in 0.95s
ℹ️ [11:24:12] root INFO: Executing eligibility SQL statement
ℹ️ [11:24:12] root INFO: Executing SQL statement
ℹ️ [11:24:12] root INFO: SQL execution finished in 0.48s
ℹ️ [11:24:12] root INFO: Executing eligibility SQL statement
ℹ️ [11:24:12] root INFO: Executing SQL statement
ℹ️ [11:24:13] root INFO: SQL execution finished in 0.19s
ℹ️ [11:24:13] root INFO: Using cached waterfall steps.
ℹ️ [11:24:13] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [11:24:13] root INFO: Fetching data to DataFrame
ℹ️ [11:24:13] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.53s
ℹ️ [11:24:13] root INFO: Fetching data to DataFrame
❌ [11:24:13] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
    
),
flags AS (
  SELECT
    customer_id,
    email_BA_1
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               AND ( )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               AND ( )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics;': [Version 20.0.0.32] [Session 1286] [Teradata Database] [Error 3706] Syntax error: expected something between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1286] [Teradata Database] [Error 3706] Syntax error: expected something between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
    
),
flags AS (
  SELECT
    customer_id,
    email_BA_1
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               AND ( )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               AND ( )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics;': [Version 20.0.0.32] [Session 1286] [Teradata Database] [Error 3706] Syntax error: expected something between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [11:24:14] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [11:24:14] root INFO: Fetching data to DataFrame
ℹ️ [11:24:14] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.44s
ℹ️ [11:24:14] root INFO: Fetching data to DataFrame
❌ [11:24:14] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
    
),
flags AS (
  SELECT
    customer_id,account_id,
    email_BA_1
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               AND ( )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               AND ( )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics;': [Version 20.0.0.32] [Session 1286] [Teradata Database] [Error 3706] Syntax error: expected something between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1286] [Teradata Database] [Error 3706] Syntax error: expected something between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
    
),
flags AS (
  SELECT
    customer_id,account_id,
    email_BA_1
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               AND ( )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               AND ( )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics;': [Version 20.0.0.32] [Session 1286] [Teradata Database] [Error 3706] Syntax error: expected something between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [11:24:14] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [11:24:14] root INFO: Fetching data to DataFrame
ℹ️ [11:24:15] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.44s
ℹ️ [11:24:15] root INFO: Fetching data to DataFrame
❌ [11:24:15] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
    
),
flags AS (
  SELECT
    region_id,segment_id,
    email_BA_1
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               AND ( )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               AND ( )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics;': [Version 20.0.0.32] [Session 1286] [Teradata Database] [Error 3706] Syntax error: expected something between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1286] [Teradata Database] [Error 3706] Syntax error: expected something between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
    
),
flags AS (
  SELECT
    region_id,segment_id,
    email_BA_1
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               AND ( )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_BA_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 0
               AND ( )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_BA_1' AS check_name,
      SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics;': [Version 20.0.0.32] [Session 1286] [Teradata Database] [Error 3706] Syntax error: expected something between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [11:24:15] root INFO: Using cached output steps.
ℹ️ [11:24:15] root INFO: Running output job for channel email
ℹ️ [11:24:15] root INFO: Fetching data to DataFrame
ℹ️ [11:24:15] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [11:24:15] root INFO: Fetched 17 rows for channel email
ℹ️ [11:24:15] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [11:24:15] root INFO: Running output job for channel sms
ℹ️ [11:24:15] root INFO: Fetching data to DataFrame
ℹ️ [11:24:15] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.28s
ℹ️ [11:24:15] root INFO: Fetched 8 rows for channel sms
ℹ️ [11:24:15] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [11:24:16] root INFO: Running output job for channel push
ℹ️ [11:24:16] root INFO: Fetching data to DataFrame
ℹ️ [11:24:16] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.26s
ℹ️ [11:24:16] root INFO: Fetched 17 rows for channel push
ℹ️ [11:24:16] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [11:24:16] root INFO: Cleaning up DB connection
ℹ️ [11:31:10] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [11:31:10] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [11:31:10] root INFO: Calculation complete: 3 steps.
ℹ️ [11:31:10] root INFO: Calculating the number of waterfall steps.
ℹ️ [11:31:10] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [11:31:10] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [11:31:10] root INFO: Calculating the number of output steps.
ℹ️ [11:31:10] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [11:31:10] root INFO: Preparing logic for channel 'email'
ℹ️ [11:31:10] root INFO: Preparing logic for channel 'sms'
ℹ️ [11:31:10] root INFO: Preparing logic for channel 'push'
ℹ️ [11:31:10] root INFO: Calculation complete: 3 steps (files).
ℹ️ [11:31:10] root INFO: Using cached SQL statements.
ℹ️ [11:31:10] root INFO: Dropping existing table eligibility_poc
ℹ️ [11:31:10] root INFO: Executing SQL statement
ℹ️ [11:31:11] root INFO: SQL execution finished in 1.01s
ℹ️ [11:31:11] root INFO: Executing eligibility SQL statement
ℹ️ [11:31:11] root INFO: Executing SQL statement
ℹ️ [11:31:11] root INFO: SQL execution finished in 0.54s
ℹ️ [11:31:11] root INFO: Executing eligibility SQL statement
ℹ️ [11:31:11] root INFO: Executing SQL statement
ℹ️ [11:31:12] root INFO: SQL execution finished in 0.15s
ℹ️ [11:31:12] root INFO: Using cached waterfall steps.
ℹ️ [11:31:12] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [11:31:12] root INFO: Fetching data to DataFrame
ℹ️ [11:31:12] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.49s
ℹ️ [11:31:12] root INFO: Fetching data to DataFrame
ℹ️ [11:31:12] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.21s
ℹ️ [11:31:12] root INFO: Fetching data to DataFrame
❌ [11:31:13] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics;': [Version 20.0.0.32] [Session 1288] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1288] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics;': [Version 20.0.0.32] [Session 1288] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [11:31:13] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [11:31:13] root INFO: Fetching data to DataFrame
ℹ️ [11:31:13] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.36s
ℹ️ [11:31:13] root INFO: Fetching data to DataFrame
ℹ️ [11:31:13] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.21s
ℹ️ [11:31:13] root INFO: Fetching data to DataFrame
❌ [11:31:14] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics;': [Version 20.0.0.32] [Session 1288] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1288] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics;': [Version 20.0.0.32] [Session 1288] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [11:31:14] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [11:31:14] root INFO: Fetching data to DataFrame
ℹ️ [11:31:14] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.32s
ℹ️ [11:31:14] root INFO: Fetching data to DataFrame
ℹ️ [11:31:14] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [11:31:14] root INFO: Fetching data to DataFrame
❌ [11:31:15] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics;': [Version 20.0.0.32] [Session 1288] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1288] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) metrics;': [Version 20.0.0.32] [Session 1288] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [11:31:15] root INFO: Using cached output steps.
ℹ️ [11:31:15] root INFO: Running output job for channel email
ℹ️ [11:31:15] root INFO: Fetching data to DataFrame
ℹ️ [11:31:15] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [11:31:15] root INFO: Fetched 17 rows for channel email
ℹ️ [11:31:15] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [11:31:15] root INFO: Running output job for channel sms
ℹ️ [11:31:15] root INFO: Fetching data to DataFrame
ℹ️ [11:31:15] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [11:31:15] root INFO: Fetched 8 rows for channel sms
ℹ️ [11:31:15] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [11:31:15] root INFO: Running output job for channel push
ℹ️ [11:31:15] root INFO: Fetching data to DataFrame
ℹ️ [11:31:15] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [11:31:15] root INFO: Fetched 17 rows for channel push
ℹ️ [11:31:15] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [11:31:15] root INFO: Cleaning up DB connection
ℹ️ [11:44:29] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [11:44:29] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [11:44:29] root INFO: Calculation complete: 3 steps.
ℹ️ [11:44:29] root INFO: Calculating the number of waterfall steps.
ℹ️ [11:44:29] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [11:44:29] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [11:44:29] root INFO: Calculating the number of output steps.
ℹ️ [11:44:29] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [11:44:29] root INFO: Preparing logic for channel 'email'
ℹ️ [11:44:29] root INFO: Preparing logic for channel 'sms'
ℹ️ [11:44:29] root INFO: Preparing logic for channel 'push'
ℹ️ [11:44:29] root INFO: Calculation complete: 3 steps (files).
ℹ️ [11:44:29] root INFO: Using cached SQL statements.
ℹ️ [11:44:29] root INFO: Dropping existing table eligibility_poc
ℹ️ [11:44:29] root INFO: Executing SQL statement
ℹ️ [11:44:49] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [11:44:49] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [11:44:49] root INFO: Calculation complete: 3 steps.
ℹ️ [11:44:49] root INFO: Calculating the number of waterfall steps.
ℹ️ [11:44:49] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [11:44:49] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [11:44:49] root INFO: Calculating the number of output steps.
ℹ️ [11:44:49] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [11:44:49] root INFO: Preparing logic for channel 'email'
ℹ️ [11:44:49] root INFO: Preparing logic for channel 'sms'
ℹ️ [11:44:49] root INFO: Preparing logic for channel 'push'
ℹ️ [11:44:49] root INFO: Calculation complete: 3 steps (files).
ℹ️ [11:44:49] root INFO: Using cached SQL statements.
ℹ️ [11:44:49] root INFO: Dropping existing table eligibility_poc
ℹ️ [11:44:49] root INFO: Executing SQL statement
ℹ️ [11:44:50] root INFO: SQL execution finished in 0.90s
ℹ️ [11:44:50] root INFO: Executing eligibility SQL statement
ℹ️ [11:44:50] root INFO: Executing SQL statement
ℹ️ [11:44:51] root INFO: SQL execution finished in 0.48s
ℹ️ [11:44:51] root INFO: Executing eligibility SQL statement
ℹ️ [11:44:51] root INFO: Executing SQL statement
ℹ️ [11:44:51] root INFO: SQL execution finished in 0.19s
ℹ️ [11:44:51] root INFO: Using cached waterfall steps.
ℹ️ [11:44:51] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [11:44:51] root INFO: Fetching data to DataFrame
ℹ️ [11:44:51] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.51s
ℹ️ [11:44:51] root INFO: Fetching data to DataFrame
ℹ️ [11:44:52] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [11:44:52] root INFO: Fetching data to DataFrame
❌ [11:44:52] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1294] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1294] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1294] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [11:44:52] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [11:44:52] root INFO: Fetching data to DataFrame
ℹ️ [11:44:53] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.50s
ℹ️ [11:44:53] root INFO: Fetching data to DataFrame
ℹ️ [11:44:53] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.45s
ℹ️ [11:44:53] root INFO: Fetching data to DataFrame
❌ [11:44:53] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1294] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1294] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1294] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [11:44:54] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [11:44:54] root INFO: Fetching data to DataFrame
ℹ️ [11:44:54] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.34s
ℹ️ [11:44:54] root INFO: Fetching data to DataFrame
ℹ️ [11:44:54] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [11:44:54] root INFO: Fetching data to DataFrame
❌ [11:44:54] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1294] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1294] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1294] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [11:44:55] root INFO: Using cached output steps.
ℹ️ [11:44:55] root INFO: Running output job for channel email
ℹ️ [11:44:55] root INFO: Fetching data to DataFrame
ℹ️ [11:44:55] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [11:44:55] root INFO: Fetched 17 rows for channel email
ℹ️ [11:44:55] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [11:44:55] root INFO: Running output job for channel sms
ℹ️ [11:44:55] root INFO: Fetching data to DataFrame
ℹ️ [11:44:55] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [11:44:55] root INFO: Fetched 8 rows for channel sms
ℹ️ [11:44:55] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [11:44:55] root INFO: Running output job for channel push
ℹ️ [11:44:55] root INFO: Fetching data to DataFrame
ℹ️ [11:44:55] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [11:44:55] root INFO: Fetched 17 rows for channel push
ℹ️ [11:44:55] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [11:44:55] root INFO: Cleaning up DB connection
ℹ️ [11:56:28] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [11:56:28] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [11:56:28] root INFO: Calculation complete: 3 steps.
ℹ️ [11:56:28] root INFO: Calculating the number of waterfall steps.
ℹ️ [11:56:28] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [11:56:29] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [11:56:29] root INFO: Calculating the number of output steps.
ℹ️ [11:56:29] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [11:56:29] root INFO: Preparing logic for channel 'email'
ℹ️ [11:56:29] root INFO: Preparing logic for channel 'sms'
ℹ️ [11:56:29] root INFO: Preparing logic for channel 'push'
ℹ️ [11:56:29] root INFO: Calculation complete: 3 steps (files).
ℹ️ [11:56:29] root INFO: Using cached SQL statements.
ℹ️ [11:56:29] root INFO: Dropping existing table eligibility_poc
ℹ️ [11:56:29] root INFO: Executing SQL statement
ℹ️ [11:56:30] root INFO: SQL execution finished in 1.34s
ℹ️ [11:56:30] root INFO: Executing eligibility SQL statement
ℹ️ [11:56:30] root INFO: Executing SQL statement
ℹ️ [11:56:30] root INFO: SQL execution finished in 0.58s
ℹ️ [11:56:30] root INFO: Executing eligibility SQL statement
ℹ️ [11:56:30] root INFO: Executing SQL statement
ℹ️ [11:56:31] root INFO: SQL execution finished in 0.17s
ℹ️ [11:56:31] root INFO: Using cached waterfall steps.
ℹ️ [11:56:31] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [11:56:31] root INFO: Fetching data to DataFrame
ℹ️ [11:56:31] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.50s
ℹ️ [11:56:31] root INFO: Fetching data to DataFrame
ℹ️ [11:56:31] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [11:56:31] root INFO: Fetching data to DataFrame
❌ [11:56:32] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1298] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1298] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1298] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [11:56:32] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [11:56:32] root INFO: Fetching data to DataFrame
ℹ️ [11:56:32] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.34s
ℹ️ [11:56:32] root INFO: Fetching data to DataFrame
ℹ️ [11:56:32] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [11:56:32] root INFO: Fetching data to DataFrame
❌ [11:56:33] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1298] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1298] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1298] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [11:56:33] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [11:56:33] root INFO: Fetching data to DataFrame
ℹ️ [11:56:33] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.38s
ℹ️ [11:56:33] root INFO: Fetching data to DataFrame
ℹ️ [11:56:34] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [11:56:34] root INFO: Fetching data to DataFrame
❌ [11:56:34] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1298] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1298] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1298] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [11:56:34] root INFO: Using cached output steps.
ℹ️ [11:56:34] root INFO: Running output job for channel email
ℹ️ [11:56:34] root INFO: Fetching data to DataFrame
ℹ️ [11:56:34] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [11:56:34] root INFO: Fetched 17 rows for channel email
ℹ️ [11:56:34] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [11:56:34] root INFO: Running output job for channel sms
ℹ️ [11:56:34] root INFO: Fetching data to DataFrame
ℹ️ [11:56:34] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.14s
ℹ️ [11:56:34] root INFO: Fetched 8 rows for channel sms
ℹ️ [11:56:34] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [11:56:35] root INFO: Running output job for channel push
ℹ️ [11:56:35] root INFO: Fetching data to DataFrame
ℹ️ [11:56:35] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [11:56:35] root INFO: Fetched 17 rows for channel push
ℹ️ [11:56:35] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [11:56:35] root INFO: Cleaning up DB connection
ℹ️ [12:06:36] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [12:06:36] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [12:06:36] root INFO: Calculation complete: 3 steps.
ℹ️ [12:06:36] root INFO: Calculating the number of waterfall steps.
ℹ️ [12:06:36] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [12:06:36] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [12:06:36] root INFO: Calculating the number of output steps.
ℹ️ [12:06:36] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [12:06:36] root INFO: Preparing logic for channel 'email'
ℹ️ [12:06:36] root INFO: Preparing logic for channel 'sms'
ℹ️ [12:06:36] root INFO: Preparing logic for channel 'push'
ℹ️ [12:06:36] root INFO: Calculation complete: 3 steps (files).
ℹ️ [12:06:36] root INFO: Using cached SQL statements.
ℹ️ [12:06:36] root INFO: Dropping existing table eligibility_poc
ℹ️ [12:06:36] root INFO: Executing SQL statement
ℹ️ [12:06:37] root INFO: SQL execution finished in 0.92s
ℹ️ [12:06:37] root INFO: Executing eligibility SQL statement
ℹ️ [12:06:37] root INFO: Executing SQL statement
ℹ️ [12:06:37] root INFO: SQL execution finished in 0.50s
ℹ️ [12:06:37] root INFO: Executing eligibility SQL statement
ℹ️ [12:06:37] root INFO: Executing SQL statement
ℹ️ [12:06:37] root INFO: SQL execution finished in 0.17s
ℹ️ [12:06:37] root INFO: Using cached waterfall steps.
ℹ️ [12:06:37] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [12:06:37] root INFO: Fetching data to DataFrame
ℹ️ [12:06:38] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.48s
ℹ️ [12:06:38] root INFO: Fetching data to DataFrame
ℹ️ [12:06:38] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [12:06:38] root INFO: Fetching data to DataFrame
❌ [12:06:38] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1301] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1301] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1301] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [12:06:39] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [12:06:39] root INFO: Fetching data to DataFrame
ℹ️ [12:06:39] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.38s
ℹ️ [12:06:39] root INFO: Fetching data to DataFrame
ℹ️ [12:06:39] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [12:06:39] root INFO: Fetching data to DataFrame
❌ [12:06:40] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1301] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1301] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        customer_id,account_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1301] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [12:06:40] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [12:06:40] root INFO: Fetching data to DataFrame
ℹ️ [12:06:40] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.34s
ℹ️ [12:06:40] root INFO: Fetching data to DataFrame
ℹ️ [12:06:40] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [12:06:40] root INFO: Fetching data to DataFrame
❌ [12:06:41] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1301] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1301] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 167, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_loyalty_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 0
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_loyalty_1' AS check_name,
      SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_loyalty_1
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- This is the standard waterfall calculation block, rebuilt for five metrics.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    -- Drop If Only This Scrub
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Incremental
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'incremental_drops' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Drop Cumulative
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_1' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'cumulative_drops' AS stat_name,
      'email_promo_2' AS check_name,
      COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Regain If No Scrub
    SELECT
      'regain' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 0
      
               AND (email_promo_2 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'regain' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 0
      
               AND (email_promo_1 = 1 )
      
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    

    UNION ALL

    -- Remaining
    SELECT
      'remaining' AS stat_name,
      'email_promo_1' AS check_name,
      SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
    ) flags
    UNION ALL
    SELECT
      'remaining' AS stat_name,
      'email_promo_2' AS check_name,
      SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM (
      SELECT
        region_id,segment_id, 
        email_promo_1,email_promo_2
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      
        
      AND NOT (c.email_loyalty_1 = 1)
        
      
    ) flags
    
) metrics;': [Version 20.0.0.32] [Session 1301] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [12:06:41] root INFO: Using cached output steps.
ℹ️ [12:06:41] root INFO: Running output job for channel email
ℹ️ [12:06:41] root INFO: Fetching data to DataFrame
ℹ️ [12:06:41] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [12:06:41] root INFO: Fetched 17 rows for channel email
ℹ️ [12:06:41] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [12:06:41] root INFO: Running output job for channel sms
ℹ️ [12:06:41] root INFO: Fetching data to DataFrame
ℹ️ [12:06:41] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [12:06:41] root INFO: Fetched 8 rows for channel sms
ℹ️ [12:06:41] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [12:06:41] root INFO: Running output job for channel push
ℹ️ [12:06:41] root INFO: Fetching data to DataFrame
ℹ️ [12:06:41] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [12:06:41] root INFO: Fetched 17 rows for channel push
ℹ️ [12:06:41] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [12:06:41] root INFO: Cleaning up DB connection
ℹ️ [20:50:27] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [20:50:27] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [20:50:27] root INFO: Calculation complete: 3 steps.
ℹ️ [20:50:27] root INFO: Calculating the number of waterfall steps.
ℹ️ [20:50:27] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [20:50:27] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [20:50:27] root INFO: Calculating the number of output steps.
ℹ️ [20:50:27] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [20:50:27] root INFO: Preparing logic for channel 'email'
ℹ️ [20:50:27] root INFO: Preparing logic for channel 'sms'
ℹ️ [20:50:27] root INFO: Preparing logic for channel 'push'
ℹ️ [20:50:27] root INFO: Calculation complete: 3 steps (files).
ℹ️ [20:50:27] root INFO: Using cached SQL statements.
ℹ️ [20:50:27] root INFO: Dropping existing table eligibility_poc
ℹ️ [20:50:27] root INFO: Executing SQL statement
ℹ️ [20:50:29] root INFO: SQL execution finished in 1.47s
ℹ️ [20:50:29] root INFO: Executing eligibility SQL statement
ℹ️ [20:50:29] root INFO: Executing SQL statement
ℹ️ [20:50:30] root INFO: SQL execution finished in 0.92s
ℹ️ [20:50:30] root INFO: Executing eligibility SQL statement
ℹ️ [20:50:30] root INFO: Executing SQL statement
ℹ️ [20:50:30] root INFO: SQL execution finished in 0.29s
ℹ️ [20:50:30] root INFO: Using cached waterfall steps.
ℹ️ [20:50:30] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [20:50:30] root INFO: Fetching data to DataFrame
❌ [20:50:31] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    



WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) AS metrics;': [Version 20.0.0.32] [Session 1303] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1303] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 179, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    



WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) AS metrics;': [Version 20.0.0.32] [Session 1303] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:50:31] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [20:50:31] root INFO: Fetching data to DataFrame
❌ [20:50:31] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    



WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) AS metrics;': [Version 20.0.0.32] [Session 1303] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1303] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 179, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    



WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) AS metrics;': [Version 20.0.0.32] [Session 1303] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:50:31] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [20:50:31] root INFO: Fetching data to DataFrame
❌ [20:50:31] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    



WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) AS metrics;': [Version 20.0.0.32] [Session 1303] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1303] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 179, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    



WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flagsUNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
) AS metrics;': [Version 20.0.0.32] [Session 1303] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'flagsUNION' and the 'ALL' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:50:32] root INFO: Using cached output steps.
ℹ️ [20:50:32] root INFO: Running output job for channel email
ℹ️ [20:50:32] root INFO: Fetching data to DataFrame
ℹ️ [20:50:32] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [20:50:32] root INFO: Fetched 17 rows for channel email
ℹ️ [20:50:32] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [20:50:32] root INFO: Running output job for channel sms
ℹ️ [20:50:32] root INFO: Fetching data to DataFrame
ℹ️ [20:50:32] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.14s
ℹ️ [20:50:32] root INFO: Fetched 8 rows for channel sms
ℹ️ [20:50:32] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [20:50:32] root INFO: Running output job for channel push
ℹ️ [20:50:32] root INFO: Fetching data to DataFrame
ℹ️ [20:50:32] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [20:50:32] root INFO: Fetched 17 rows for channel push
ℹ️ [20:50:32] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [20:50:32] root INFO: Cleaning up DB connection
ℹ️ [21:31:56] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [21:31:56] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [21:31:56] root INFO: Calculation complete: 3 steps.
ℹ️ [21:31:56] root INFO: Calculating the number of waterfall steps.
ℹ️ [21:31:56] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [21:31:57] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [21:31:57] root INFO: Calculating the number of output steps.
ℹ️ [21:31:57] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [21:31:57] root INFO: Preparing logic for channel 'email'
ℹ️ [21:31:57] root INFO: Preparing logic for channel 'sms'
ℹ️ [21:31:57] root INFO: Preparing logic for channel 'push'
ℹ️ [21:31:57] root INFO: Calculation complete: 3 steps (files).
ℹ️ [21:31:57] root INFO: Using cached SQL statements.
ℹ️ [21:31:57] root INFO: Dropping existing table eligibility_poc
ℹ️ [21:31:57] root INFO: Executing SQL statement
ℹ️ [21:31:58] root INFO: SQL execution finished in 1.16s
ℹ️ [21:31:58] root INFO: Executing eligibility SQL statement
ℹ️ [21:31:58] root INFO: Executing SQL statement
ℹ️ [21:31:58] root INFO: SQL execution finished in 0.64s
ℹ️ [21:31:58] root INFO: Executing eligibility SQL statement
ℹ️ [21:31:58] root INFO: Executing SQL statement
ℹ️ [21:31:59] root INFO: SQL execution finished in 0.17s
ℹ️ [21:31:59] root INFO: Using cached waterfall steps.
ℹ️ [21:31:59] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [21:31:59] root INFO: Fetching data to DataFrame
ℹ️ [21:31:59] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.75s
ℹ️ [21:31:59] root INFO: Fetching data to DataFrame
❌ [21:32:00] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    



WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        email_BA_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_loyalty_1 = 1)) OR ((email_promo_1 = 1 AND email_promo_2 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;': [Version 20.0.0.32] [Session 1311] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1311] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 179, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    



WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        email_BA_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_loyalty_1 = 1)) OR ((email_promo_1 = 1 AND email_promo_2 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;': [Version 20.0.0.32] [Session 1311] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:32:00] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [21:32:00] root INFO: Fetching data to DataFrame
ℹ️ [21:32:01] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.93s
ℹ️ [21:32:01] root INFO: Fetching data to DataFrame
❌ [21:32:01] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    



WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        email_BA_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_loyalty_1 = 1)) OR ((email_promo_1 = 1 AND email_promo_2 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;': [Version 20.0.0.32] [Session 1311] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1311] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 179, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    



WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        email_BA_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_loyalty_1 = 1)) OR ((email_promo_1 = 1 AND email_promo_2 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;': [Version 20.0.0.32] [Session 1311] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:32:01] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [21:32:01] root INFO: Fetching data to DataFrame
ℹ️ [21:32:02] root INFO: Fetched DataFrame with 11 rows and 3 columns in 1.07s
ℹ️ [21:32:02] root INFO: Fetching data to DataFrame
❌ [21:32:02] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    



WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        email_BA_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_loyalty_1 = 1)) OR ((email_promo_1 = 1 AND email_promo_2 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;': [Version 20.0.0.32] [Session 1311] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1311] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 179, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    



WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        email_BA_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_loyalty_1 = 1)) OR ((email_promo_1 = 1 AND email_promo_2 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;': [Version 20.0.0.32] [Session 1311] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:32:03] root INFO: Using cached output steps.
ℹ️ [21:32:03] root INFO: Running output job for channel email
ℹ️ [21:32:03] root INFO: Fetching data to DataFrame
ℹ️ [21:32:03] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.24s
ℹ️ [21:32:03] root INFO: Fetched 17 rows for channel email
ℹ️ [21:32:03] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [21:32:03] root INFO: Running output job for channel sms
ℹ️ [21:32:03] root INFO: Fetching data to DataFrame
ℹ️ [21:32:03] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.20s
ℹ️ [21:32:03] root INFO: Fetched 8 rows for channel sms
ℹ️ [21:32:03] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [21:32:03] root INFO: Running output job for channel push
ℹ️ [21:32:03] root INFO: Fetching data to DataFrame
ℹ️ [21:32:03] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [21:32:03] root INFO: Fetched 17 rows for channel push
ℹ️ [21:32:03] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [21:32:03] root INFO: Cleaning up DB connection
ℹ️ [21:40:05] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [21:40:05] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [21:40:05] root INFO: Calculation complete: 3 steps.
ℹ️ [21:40:05] root INFO: Calculating the number of waterfall steps.
ℹ️ [21:40:05] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [21:40:05] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [21:40:05] root INFO: Calculating the number of output steps.
ℹ️ [21:40:05] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [21:40:05] root INFO: Preparing logic for channel 'email'
ℹ️ [21:40:05] root INFO: Preparing logic for channel 'sms'
ℹ️ [21:40:05] root INFO: Preparing logic for channel 'push'
ℹ️ [21:40:05] root INFO: Calculation complete: 3 steps (files).
ℹ️ [21:40:05] root INFO: Using cached SQL statements.
ℹ️ [21:40:05] root INFO: Dropping existing table eligibility_poc
ℹ️ [21:40:05] root INFO: Executing SQL statement
ℹ️ [21:40:06] root INFO: SQL execution finished in 0.92s
ℹ️ [21:40:06] root INFO: Executing eligibility SQL statement
ℹ️ [21:40:06] root INFO: Executing SQL statement
ℹ️ [21:40:06] root INFO: SQL execution finished in 0.48s
ℹ️ [21:40:06] root INFO: Executing eligibility SQL statement
ℹ️ [21:40:06] root INFO: Executing SQL statement
ℹ️ [21:40:07] root INFO: SQL execution finished in 0.17s
ℹ️ [21:40:07] root INFO: Using cached waterfall steps.
ℹ️ [21:40:07] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [21:40:07] root INFO: Fetching data to DataFrame
ℹ️ [21:40:07] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.85s
ℹ️ [21:40:08] root INFO: Fetching data to DataFrame
ℹ️ [21:40:08] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.59s
ℹ️ [21:40:08] root INFO: Fetching data to DataFrame
❌ [21:40:08] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
)

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),


seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
),


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1315] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between ')' and the word 'seg_0'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1315] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between ')' and the word 'seg_0'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
)

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),


seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
),


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1315] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between ')' and the word 'seg_0'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:40:09] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [21:40:09] root INFO: Fetching data to DataFrame
ℹ️ [21:40:09] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.59s
ℹ️ [21:40:09] root INFO: Fetching data to DataFrame
ℹ️ [21:40:10] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.35s
ℹ️ [21:40:10] root INFO: Fetching data to DataFrame
❌ [21:40:10] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
)

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),


seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
),


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1315] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between ')' and the word 'seg_0'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1315] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between ')' and the word 'seg_0'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
)

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),


seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
),


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1315] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between ')' and the word 'seg_0'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:40:10] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [21:40:10] root INFO: Fetching data to DataFrame
ℹ️ [21:40:11] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.59s
ℹ️ [21:40:11] root INFO: Fetching data to DataFrame
ℹ️ [21:40:11] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.37s
ℹ️ [21:40:11] root INFO: Fetching data to DataFrame
❌ [21:40:12] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
)

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),


seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
),


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1315] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between ')' and the word 'seg_0'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1315] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between ')' and the word 'seg_0'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
)

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),


seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
),


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1315] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between ')' and the word 'seg_0'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:40:12] root INFO: Using cached output steps.
ℹ️ [21:40:12] root INFO: Running output job for channel email
ℹ️ [21:40:12] root INFO: Fetching data to DataFrame
ℹ️ [21:40:12] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [21:40:12] root INFO: Fetched 17 rows for channel email
ℹ️ [21:40:12] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [21:40:12] root INFO: Running output job for channel sms
ℹ️ [21:40:12] root INFO: Fetching data to DataFrame
ℹ️ [21:40:12] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [21:40:12] root INFO: Fetched 8 rows for channel sms
ℹ️ [21:40:12] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [21:40:12] root INFO: Running output job for channel push
ℹ️ [21:40:12] root INFO: Fetching data to DataFrame
ℹ️ [21:40:12] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [21:40:12] root INFO: Fetched 17 rows for channel push
ℹ️ [21:40:12] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [21:40:13] root INFO: Cleaning up DB connection
ℹ️ [21:43:22] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [21:43:22] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [21:43:22] root INFO: Calculation complete: 3 steps.
ℹ️ [21:43:22] root INFO: Calculating the number of waterfall steps.
ℹ️ [21:43:22] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [21:43:22] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [21:43:22] root INFO: Calculating the number of output steps.
ℹ️ [21:43:22] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [21:43:22] root INFO: Preparing logic for channel 'email'
ℹ️ [21:43:22] root INFO: Preparing logic for channel 'sms'
ℹ️ [21:43:22] root INFO: Preparing logic for channel 'push'
ℹ️ [21:43:22] root INFO: Calculation complete: 3 steps (files).
ℹ️ [21:43:22] root INFO: Using cached SQL statements.
ℹ️ [21:43:22] root INFO: Dropping existing table eligibility_poc
ℹ️ [21:43:22] root INFO: Executing SQL statement
ℹ️ [21:43:23] root INFO: SQL execution finished in 0.87s
ℹ️ [21:43:23] root INFO: Executing eligibility SQL statement
ℹ️ [21:43:23] root INFO: Executing SQL statement
ℹ️ [21:43:24] root INFO: SQL execution finished in 0.50s
ℹ️ [21:43:24] root INFO: Executing eligibility SQL statement
ℹ️ [21:43:24] root INFO: Executing SQL statement
ℹ️ [21:43:24] root INFO: SQL execution finished in 0.17s
ℹ️ [21:43:24] root INFO: Using cached waterfall steps.
ℹ️ [21:43:24] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [21:43:24] root INFO: Fetching data to DataFrame
ℹ️ [21:43:24] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.71s
ℹ️ [21:43:24] root INFO: Fetching data to DataFrame
ℹ️ [21:43:25] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.35s
ℹ️ [21:43:25] root INFO: Fetching data to DataFrame
❌ [21:43:25] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1316] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1316] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1316] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:43:26] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [21:43:26] root INFO: Fetching data to DataFrame
ℹ️ [21:43:26] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.73s
ℹ️ [21:43:26] root INFO: Fetching data to DataFrame
ℹ️ [21:43:27] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.58s
ℹ️ [21:43:27] root INFO: Fetching data to DataFrame
❌ [21:43:27] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1316] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1316] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1316] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:43:28] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [21:43:28] root INFO: Fetching data to DataFrame
ℹ️ [21:43:28] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.55s
ℹ️ [21:43:28] root INFO: Fetching data to DataFrame
ℹ️ [21:43:28] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.35s
ℹ️ [21:43:28] root INFO: Fetching data to DataFrame
❌ [21:43:29] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1316] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1316] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1316] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:43:29] root INFO: Using cached output steps.
ℹ️ [21:43:29] root INFO: Running output job for channel email
ℹ️ [21:43:29] root INFO: Fetching data to DataFrame
ℹ️ [21:43:29] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [21:43:29] root INFO: Fetched 17 rows for channel email
ℹ️ [21:43:29] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [21:43:29] root INFO: Running output job for channel sms
ℹ️ [21:43:29] root INFO: Fetching data to DataFrame
ℹ️ [21:43:29] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [21:43:29] root INFO: Fetched 8 rows for channel sms
ℹ️ [21:43:29] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [21:43:29] root INFO: Running output job for channel push
ℹ️ [21:43:29] root INFO: Fetching data to DataFrame
ℹ️ [21:43:30] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [21:43:30] root INFO: Fetched 17 rows for channel push
ℹ️ [21:43:30] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [21:43:30] root INFO: Cleaning up DB connection
ℹ️ [21:46:57] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [21:46:57] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [21:46:57] root INFO: Calculation complete: 3 steps.
ℹ️ [21:46:57] root INFO: Calculating the number of waterfall steps.
ℹ️ [21:46:57] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [21:46:57] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [21:46:57] root INFO: Calculating the number of output steps.
ℹ️ [21:46:57] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [21:46:57] root INFO: Preparing logic for channel 'email'
ℹ️ [21:46:57] root INFO: Preparing logic for channel 'sms'
ℹ️ [21:46:57] root INFO: Preparing logic for channel 'push'
ℹ️ [21:46:57] root INFO: Calculation complete: 3 steps (files).
ℹ️ [21:46:57] root INFO: Using cached SQL statements.
ℹ️ [21:46:57] root INFO: Dropping existing table eligibility_poc
ℹ️ [21:46:57] root INFO: Executing SQL statement
ℹ️ [21:46:58] root INFO: SQL execution finished in 1.08s
ℹ️ [21:46:58] root INFO: Executing eligibility SQL statement
ℹ️ [21:46:58] root INFO: Executing SQL statement
ℹ️ [21:46:59] root INFO: SQL execution finished in 0.56s
ℹ️ [21:46:59] root INFO: Executing eligibility SQL statement
ℹ️ [21:46:59] root INFO: Executing SQL statement
ℹ️ [21:46:59] root INFO: SQL execution finished in 0.17s
ℹ️ [21:46:59] root INFO: Using cached waterfall steps.
ℹ️ [21:46:59] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [21:46:59] root INFO: Fetching data to DataFrame
ℹ️ [21:46:59] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.76s
ℹ️ [21:46:59] root INFO: Fetching data to DataFrame
ℹ️ [21:47:00] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.35s
ℹ️ [21:47:00] root INFO: Fetching data to DataFrame
❌ [21:47:00] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1318] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1318] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1318] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:47:01] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [21:47:01] root INFO: Fetching data to DataFrame
ℹ️ [21:47:01] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.65s
ℹ️ [21:47:01] root INFO: Fetching data to DataFrame
ℹ️ [21:47:02] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.46s
ℹ️ [21:47:02] root INFO: Fetching data to DataFrame
❌ [21:47:02] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1318] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1318] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1318] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:47:02] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [21:47:02] root INFO: Fetching data to DataFrame
ℹ️ [21:47:03] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.55s
ℹ️ [21:47:03] root INFO: Fetching data to DataFrame
ℹ️ [21:47:03] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.37s
ℹ️ [21:47:03] root INFO: Fetching data to DataFrame
❌ [21:47:04] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1318] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1318] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) flags
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) flags
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1318] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:47:04] root INFO: Using cached output steps.
ℹ️ [21:47:04] root INFO: Running output job for channel email
ℹ️ [21:47:04] root INFO: Fetching data to DataFrame
ℹ️ [21:47:04] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [21:47:04] root INFO: Fetched 17 rows for channel email
ℹ️ [21:47:04] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [21:47:04] root INFO: Running output job for channel sms
ℹ️ [21:47:04] root INFO: Fetching data to DataFrame
ℹ️ [21:47:04] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [21:47:04] root INFO: Fetched 8 rows for channel sms
ℹ️ [21:47:04] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [21:47:04] root INFO: Running output job for channel push
ℹ️ [21:47:04] root INFO: Fetching data to DataFrame
ℹ️ [21:47:05] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [21:47:05] root INFO: Fetched 17 rows for channel push
ℹ️ [21:47:05] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [21:47:05] root INFO: Cleaning up DB connection
ℹ️ [21:51:32] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [21:51:32] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [21:51:32] root INFO: Calculation complete: 3 steps.
ℹ️ [21:51:32] root INFO: Calculating the number of waterfall steps.
ℹ️ [21:51:32] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [21:51:32] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [21:51:32] root INFO: Calculating the number of output steps.
ℹ️ [21:51:32] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [21:51:32] root INFO: Preparing logic for channel 'email'
ℹ️ [21:51:32] root INFO: Preparing logic for channel 'sms'
ℹ️ [21:51:32] root INFO: Preparing logic for channel 'push'
ℹ️ [21:51:32] root INFO: Calculation complete: 3 steps (files).
ℹ️ [21:51:32] root INFO: Using cached SQL statements.
ℹ️ [21:51:32] root INFO: Dropping existing table eligibility_poc
ℹ️ [21:51:32] root INFO: Executing SQL statement
ℹ️ [21:51:33] root INFO: SQL execution finished in 0.96s
ℹ️ [21:51:33] root INFO: Executing eligibility SQL statement
ℹ️ [21:51:33] root INFO: Executing SQL statement
ℹ️ [21:51:34] root INFO: SQL execution finished in 0.60s
ℹ️ [21:51:34] root INFO: Executing eligibility SQL statement
ℹ️ [21:51:34] root INFO: Executing SQL statement
ℹ️ [21:51:34] root INFO: SQL execution finished in 0.19s
ℹ️ [21:51:34] root INFO: Using cached waterfall steps.
ℹ️ [21:51:34] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [21:51:34] root INFO: Fetching data to DataFrame
ℹ️ [21:51:35] root INFO: Fetched DataFrame with 11 rows and 3 columns in 1.02s
ℹ️ [21:51:35] root INFO: Fetching data to DataFrame
ℹ️ [21:51:36] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.39s
ℹ️ [21:51:36] root INFO: Fetching data to DataFrame
❌ [21:51:36] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1320] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1320] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1320] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:51:36] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [21:51:36] root INFO: Fetching data to DataFrame
ℹ️ [21:51:37] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.56s
ℹ️ [21:51:37] root INFO: Fetching data to DataFrame
ℹ️ [21:51:37] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.38s
ℹ️ [21:51:37] root INFO: Fetching data to DataFrame
❌ [21:51:38] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1320] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1320] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1320] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:51:38] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [21:51:38] root INFO: Fetching data to DataFrame
ℹ️ [21:51:39] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.52s
ℹ️ [21:51:39] root INFO: Fetching data to DataFrame
ℹ️ [21:51:39] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.36s
ℹ️ [21:51:39] root INFO: Fetching data to DataFrame
❌ [21:51:39] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1320] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1320] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_loyalty_1',
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_loyalty_1',
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops', 'email_promo_1',
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops', 'email_promo_2',
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining', 'email_promo_1',
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'remaining', 'email_promo_2',
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1320] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:51:40] root INFO: Using cached output steps.
ℹ️ [21:51:40] root INFO: Running output job for channel email
ℹ️ [21:51:40] root INFO: Fetching data to DataFrame
ℹ️ [21:51:40] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [21:51:40] root INFO: Fetched 17 rows for channel email
ℹ️ [21:51:40] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [21:51:40] root INFO: Running output job for channel sms
ℹ️ [21:51:40] root INFO: Fetching data to DataFrame
ℹ️ [21:51:40] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.14s
ℹ️ [21:51:40] root INFO: Fetched 8 rows for channel sms
ℹ️ [21:51:40] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [21:51:40] root INFO: Running output job for channel push
ℹ️ [21:51:40] root INFO: Fetching data to DataFrame
ℹ️ [21:51:40] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [21:51:40] root INFO: Fetched 17 rows for channel push
ℹ️ [21:51:40] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [21:51:41] root INFO: Cleaning up DB connection
ℹ️ [21:54:39] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [21:54:39] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [21:54:39] root INFO: Calculation complete: 3 steps.
ℹ️ [21:54:39] root INFO: Calculating the number of waterfall steps.
ℹ️ [21:54:39] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [21:54:39] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [21:54:39] root INFO: Calculating the number of output steps.
ℹ️ [21:54:39] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [21:54:39] root INFO: Preparing logic for channel 'email'
ℹ️ [21:54:39] root INFO: Preparing logic for channel 'sms'
ℹ️ [21:54:39] root INFO: Preparing logic for channel 'push'
ℹ️ [21:54:39] root INFO: Calculation complete: 3 steps (files).
ℹ️ [21:54:39] root INFO: Using cached SQL statements.
ℹ️ [21:54:39] root INFO: Dropping existing table eligibility_poc
ℹ️ [21:54:39] root INFO: Executing SQL statement
ℹ️ [21:54:40] root INFO: SQL execution finished in 1.44s
ℹ️ [21:54:40] root INFO: Executing eligibility SQL statement
ℹ️ [21:54:40] root INFO: Executing SQL statement
ℹ️ [21:54:41] root INFO: SQL execution finished in 0.69s
ℹ️ [21:54:41] root INFO: Executing eligibility SQL statement
ℹ️ [21:54:41] root INFO: Executing SQL statement
ℹ️ [21:54:41] root INFO: SQL execution finished in 0.17s
ℹ️ [21:54:41] root INFO: Using cached waterfall steps.
ℹ️ [21:54:41] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [21:54:41] root INFO: Fetching data to DataFrame
ℹ️ [21:54:42] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.75s
ℹ️ [21:54:42] root INFO: Fetching data to DataFrame
ℹ️ [21:54:42] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.37s
ℹ️ [21:54:42] root INFO: Fetching data to DataFrame
❌ [21:54:43] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops' AS stat_name, 'email_promo_1' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name, 'email_promo_2' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'remaining' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1321] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1321] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, email_loyalty_1)
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops' AS stat_name, 'email_promo_1' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name, 'email_promo_2' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'remaining' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1321] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:54:43] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [21:54:43] root INFO: Fetching data to DataFrame
ℹ️ [21:54:44] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.57s
ℹ️ [21:54:44] root INFO: Fetching data to DataFrame
ℹ️ [21:54:44] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.38s
ℹ️ [21:54:44] root INFO: Fetching data to DataFrame
❌ [21:54:44] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops' AS stat_name, 'email_promo_1' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name, 'email_promo_2' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'remaining' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1321] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1321] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops' AS stat_name, 'email_promo_1' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name, 'email_promo_2' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'remaining' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1321] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:54:45] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [21:54:45] root INFO: Fetching data to DataFrame
ℹ️ [21:54:46] root INFO: Fetched DataFrame with 11 rows and 3 columns in 1.02s
ℹ️ [21:54:46] root INFO: Fetching data to DataFrame
ℹ️ [21:54:46] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.40s
ℹ️ [21:54:46] root INFO: Fetching data to DataFrame
❌ [21:54:47] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops' AS stat_name, 'email_promo_1' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name, 'email_promo_2' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'remaining' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1321] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1321] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 189, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (Claim-and-Exclude pattern)
-- ---------------------------------------------------------------------------
-- For a set of ordered *segments* we need to:
--   •  Claim the population for each segment sequentially (i.e., once a record
--      is claimed by an earlier segment it is *excluded* from later ones).
--   •  Within the unclaimed pool, run the 5-metric waterfall on that segment’s
--      check list.
--   •  All statistics are produced on a *deduplicated* view of the
--      eligibility table using the same heuristic as waterfall_full.sql.j2.
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table : smart eligibility table (alias c)
--   unique_identifiers: list[str] id columns
--   pre_filter        : SQL predicate that EVERY row in this channel must meet
--   segments          : list[dict]  Each element contains
--                         • name             – display label
--                         • checks           – list[str] of flag columns
--                         • summary_column   – full SQL predicate that defines
--                                              the *bucket* for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- Deduplicate on unique identifiers (same strategy as full waterfall).
-- Build an overall OR-condition to flag if a row is bucketable by *any* segment


deduped AS (
    SELECT *
    FROM (
        SELECT bp.*,
               
                   (email_loyalty_1 ) + 
                   (email_promo_1 + email_promo_2 ) AS pass_cnt,
               CASE WHEN (email_loyalty_1 = 1) OR (email_promo_1 = 1 AND email_promo_2 = 1) THEN 1 ELSE 0 END AS bucketable,
               -- Longest unbroken streak of passes across all segment checks (left-to-right within each seg order)
               (
                   
                   
                   email_loyalty_1 + 
                   email_loyalty_1 * email_promo_1 + 
                   email_loyalty_1 * email_promo_1 * email_promo_2
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY bucketable DESC, pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

-- Helper CTE to expose a “claimed_by” flag for every segment so that later
-- segments can exclude previously claimed rows.


seg_0 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_loyalty_1 = 1)
),



seg_1 AS (
    SELECT d.*
    FROM deduped d
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
        AND NOT (email_loyalty_1 = 1)
)


-- ---------------------------------------------------------------------------
-- The final SELECTs – for each segment output:
--   •  Row 0  – “Records Claimed” (size of pool claimed by the segment)
--   •  Rows 1+ – 5 waterfall metrics for each check (duplicated logic from
--                waterfall_full template but scoped to the segment)
-- ---------------------------------------------------------------------------



-- >>> Segment: email - loyalty -------------------------------------------------
-- Claim size
SELECT 'email - loyalty'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_0

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - loyalty' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops' AS stat_name, 'email_loyalty_1' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 0
                    
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining' AS stat_name, 'email_loyalty_1' AS check_name,
           SUM(CASE WHEN email_loyalty_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_0
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    
) AS metrics

UNION ALL



-- >>> Segment: email - promo -------------------------------------------------
-- Claim size
SELECT 'email - promo'   AS section,
       'Records Claimed'  AS stat_name,
       NULL               AS check_name,
       COUNT(*)           AS cntr
FROM seg_1

UNION ALL

-- Waterfall metrics for the segment’s checks




SELECT stat_name,
       check_name,
       cntr,
       'email - promo' AS section
FROM (
    -- unique_drops
    
    SELECT 'unique_drops' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- incremental_drops
    
    SELECT 'incremental_drops' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- cumulative_drops
    
    SELECT 'cumulative_drops' AS stat_name, 'email_promo_1' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name, 'email_promo_2' AS check_name,
           COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
                         THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- regain
    
    SELECT 'regain' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 0
                    AND (email_promo_2 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'regain' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 0
                    AND (email_promo_1 = 1 )
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    

    UNION ALL

    -- remaining
    
    SELECT 'remaining' AS stat_name, 'email_promo_1' AS check_name,
           SUM(CASE WHEN email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    UNION ALL
    
    SELECT 'remaining' AS stat_name, 'email_promo_2' AS check_name,
           SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1
               THEN 1 ELSE 0 END)
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_1
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1321] [Teradata Database] [Error 3706] Syntax error: All expressions in a derived table must have an explicit name.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [21:54:47] root INFO: Using cached output steps.
ℹ️ [21:54:47] root INFO: Running output job for channel email
ℹ️ [21:54:47] root INFO: Fetching data to DataFrame
ℹ️ [21:54:47] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [21:54:47] root INFO: Fetched 17 rows for channel email
ℹ️ [21:54:47] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [21:54:47] root INFO: Running output job for channel sms
ℹ️ [21:54:47] root INFO: Fetching data to DataFrame
ℹ️ [21:54:47] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.14s
ℹ️ [21:54:47] root INFO: Fetched 8 rows for channel sms
ℹ️ [21:54:47] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [21:54:47] root INFO: Running output job for channel push
ℹ️ [21:54:47] root INFO: Fetching data to DataFrame
ℹ️ [21:54:48] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [21:54:48] root INFO: Fetched 17 rows for channel push
ℹ️ [21:54:48] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [21:54:48] root INFO: Cleaning up DB connection
ℹ️ [08:22:56] root INFO: ================================================================================
TLPTACO RUN START 2025-07-24 08:22:56
================================================================================
ℹ️ [08:22:56] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [08:22:56] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [08:22:56] root INFO: Calculation complete: 3 steps.
ℹ️ [08:22:56] root INFO: Calculating the number of waterfall steps.
ℹ️ [08:22:56] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [08:23:15] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [08:23:15] root INFO: Calculating the number of output steps.
ℹ️ [08:23:15] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [08:23:15] root INFO: Preparing logic for channel 'email'
ℹ️ [08:23:15] root INFO: Preparing logic for channel 'sms'
ℹ️ [08:23:15] root INFO: Preparing logic for channel 'push'
ℹ️ [08:23:15] root INFO: Calculation complete: 3 steps (files).
ℹ️ [08:23:15] root INFO: Using cached SQL statements.
ℹ️ [08:23:15] root INFO: Dropping existing table eligibility_poc
ℹ️ [08:23:15] root INFO: Executing SQL statement
ℹ️ [08:23:16] root INFO: SQL execution finished in 1.14s
ℹ️ [08:23:16] root INFO: Executing eligibility SQL statement
ℹ️ [08:23:16] root INFO: Executing SQL statement
ℹ️ [08:23:16] root INFO: SQL execution finished in 0.56s
ℹ️ [08:23:16] root INFO: Executing eligibility SQL statement
ℹ️ [08:23:16] root INFO: Executing SQL statement
ℹ️ [08:23:17] root INFO: SQL execution finished in 0.17s
ℹ️ [08:23:17] root INFO: Using cached waterfall steps.
ℹ️ [08:23:17] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [08:23:17] root INFO: Fetching data to DataFrame
ℹ️ [08:23:17] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.71s
ℹ️ [08:23:17] root INFO: Fetching data to DataFrame
ℹ️ [08:23:18] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.38s
ℹ️ [08:23:18] root INFO: Fetching data to DataFrame
❌ [08:23:18] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  • Process the ordered list of *segments* for a channel.
--  • For each segment N
--        – Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, …).
--        – Claimed rows     = subset of candidate pool that passes the
--                              segment’s summary condition.
--        – Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   – smart table (aliased as c in conditions)
--    unique_identifiers  – list[str]  id columns (possibly qualified)
--    pre_filter          – SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            – ordered list of dicts
--                            name           – display label
--                            checks         – list[str] flag column names
--                            summary_column – SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ▼ added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ▼ opening tag no “-”
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ▼ added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ▼ added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ▼ added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ▼ added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ▼ added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block – emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 – records claimed by the segment
SELECT 'email - promo'  AS section,
       'Records Claimed' AS stat_name,
       NULL              AS check_name,
       COUNT(*)          AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 – records claimed by the segment
SELECT 'email - loyalty'  AS section,
       'Records Claimed' AS stat_name,
       NULL              AS check_name,
       COUNT(*)          AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1325] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1325] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 195, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  • Process the ordered list of *segments* for a channel.
--  • For each segment N
--        – Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, …).
--        – Claimed rows     = subset of candidate pool that passes the
--                              segment’s summary condition.
--        – Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   – smart table (aliased as c in conditions)
--    unique_identifiers  – list[str]  id columns (possibly qualified)
--    pre_filter          – SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            – ordered list of dicts
--                            name           – display label
--                            checks         – list[str] flag column names
--                            summary_column – SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ▼ added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ▼ opening tag no “-”
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ▼ added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ▼ added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ▼ added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ▼ added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ▼ added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block – emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 – records claimed by the segment
SELECT 'email - promo'  AS section,
       'Records Claimed' AS stat_name,
       NULL              AS check_name,
       COUNT(*)          AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 – records claimed by the segment
SELECT 'email - loyalty'  AS section,
       'Records Claimed' AS stat_name,
       NULL              AS check_name,
       COUNT(*)          AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1325] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [08:23:19] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [08:23:19] root INFO: Fetching data to DataFrame
ℹ️ [08:23:19] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.53s
ℹ️ [08:23:19] root INFO: Fetching data to DataFrame
ℹ️ [08:23:20] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.38s
ℹ️ [08:23:20] root INFO: Fetching data to DataFrame
❌ [08:23:20] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  • Process the ordered list of *segments* for a channel.
--  • For each segment N
--        – Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, …).
--        – Claimed rows     = subset of candidate pool that passes the
--                              segment’s summary condition.
--        – Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   – smart table (aliased as c in conditions)
--    unique_identifiers  – list[str]  id columns (possibly qualified)
--    pre_filter          – SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            – ordered list of dicts
--                            name           – display label
--                            checks         – list[str] flag column names
--                            summary_column – SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ▼ added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ▼ opening tag no “-”
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ▼ added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ▼ added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ▼ added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ▼ added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ▼ added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block – emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 – records claimed by the segment
SELECT 'email - promo'  AS section,
       'Records Claimed' AS stat_name,
       NULL              AS check_name,
       COUNT(*)          AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 – records claimed by the segment
SELECT 'email - loyalty'  AS section,
       'Records Claimed' AS stat_name,
       NULL              AS check_name,
       COUNT(*)          AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1325] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1325] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 195, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  • Process the ordered list of *segments* for a channel.
--  • For each segment N
--        – Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, …).
--        – Claimed rows     = subset of candidate pool that passes the
--                              segment’s summary condition.
--        – Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   – smart table (aliased as c in conditions)
--    unique_identifiers  – list[str]  id columns (possibly qualified)
--    pre_filter          – SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            – ordered list of dicts
--                            name           – display label
--                            checks         – list[str] flag column names
--                            summary_column – SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ▼ added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ▼ opening tag no “-”
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ▼ added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ▼ added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ▼ added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ▼ added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ▼ added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block – emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 – records claimed by the segment
SELECT 'email - promo'  AS section,
       'Records Claimed' AS stat_name,
       NULL              AS check_name,
       COUNT(*)          AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 – records claimed by the segment
SELECT 'email - loyalty'  AS section,
       'Records Claimed' AS stat_name,
       NULL              AS check_name,
       COUNT(*)          AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1325] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [08:23:21] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [08:23:21] root INFO: Fetching data to DataFrame
ℹ️ [08:23:21] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.61s
ℹ️ [08:23:21] root INFO: Fetching data to DataFrame
ℹ️ [08:23:22] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.34s
ℹ️ [08:23:22] root INFO: Fetching data to DataFrame
❌ [08:23:22] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Waterfall Report – Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  • Process the ordered list of *segments* for a channel.
--  • For each segment N
--        – Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, …).
--        – Claimed rows     = subset of candidate pool that passes the
--                              segment’s summary condition.
--        – Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   – smart table (aliased as c in conditions)
--    unique_identifiers  – list[str]  id columns (possibly qualified)
--    pre_filter          – SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            – ordered list of dicts
--                            name           – display label
--                            checks         – list[str] flag column names
--                            summary_column – SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ▼ added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ▼ opening tag no “-”
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ▼ added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ▼ added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ▼ added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ▼ added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ▼ added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block – emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 – records claimed by the segment
SELECT 'email - promo'  AS section,
       'Records Claimed' AS stat_name,
       NULL              AS check_name,
       COUNT(*)          AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 – records claimed by the segment
SELECT 'email - loyalty'  AS section,
       'Records Claimed' AS stat_name,
       NULL              AS check_name,
       COUNT(*)          AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1325] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1325] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 195, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall Report – Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  • Process the ordered list of *segments* for a channel.
--  • For each segment N
--        – Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, …).
--        – Claimed rows     = subset of candidate pool that passes the
--                              segment’s summary condition.
--        – Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   – smart table (aliased as c in conditions)
--    unique_identifiers  – list[str]  id columns (possibly qualified)
--    pre_filter          – SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            – ordered list of dicts
--                            name           – display label
--                            checks         – list[str] flag column names
--                            summary_column – SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ▼ added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ▼ opening tag no “-”
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ▼ added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ▼ added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ▼ added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ▼ added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ▼ added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block – emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 – records claimed by the segment
SELECT 'email - promo'  AS section,
       'Records Claimed' AS stat_name,
       NULL              AS check_name,
       COUNT(*)          AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 – records claimed by the segment
SELECT 'email - loyalty'  AS section,
       'Records Claimed' AS stat_name,
       NULL              AS check_name,
       COUNT(*)          AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    
    
) AS metrics




;': [Version 20.0.0.32] [Session 1325] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [08:23:23] root INFO: Using cached output steps.
ℹ️ [08:23:23] root INFO: Running output job for channel email
ℹ️ [08:23:23] root INFO: Fetching data to DataFrame
ℹ️ [08:23:23] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [08:23:23] root INFO: Fetched 17 rows for channel email
ℹ️ [08:23:23] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [08:23:23] root INFO: Running output job for channel sms
ℹ️ [08:23:23] root INFO: Fetching data to DataFrame
ℹ️ [08:23:23] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [08:23:23] root INFO: Fetched 8 rows for channel sms
ℹ️ [08:23:23] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [08:23:23] root INFO: Running output job for channel push
ℹ️ [08:23:23] root INFO: Fetching data to DataFrame
ℹ️ [08:23:23] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [08:23:23] root INFO: Fetched 17 rows for channel push
ℹ️ [08:23:23] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [08:23:24] root INFO: Cleaning up DB connection
ℹ️ [08:46:02] root INFO: ================================================================================
TLPTACO RUN START 2025-07-24 08:46:02
================================================================================
ℹ️ [08:46:02] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [08:46:02] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [08:46:02] root INFO: Calculation complete: 3 steps.
ℹ️ [08:46:02] root INFO: Calculating the number of waterfall steps.
ℹ️ [08:46:02] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [08:46:02] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [08:46:02] root INFO: Calculating the number of output steps.
ℹ️ [08:46:02] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [08:46:02] root INFO: Preparing logic for channel 'email'
ℹ️ [08:46:02] root INFO: Preparing logic for channel 'sms'
ℹ️ [08:46:02] root INFO: Preparing logic for channel 'push'
ℹ️ [08:46:02] root INFO: Calculation complete: 3 steps (files).
ℹ️ [08:46:02] root INFO: Using cached SQL statements.
ℹ️ [08:46:02] root INFO: Dropping existing table eligibility_poc
ℹ️ [08:46:02] root INFO: Executing SQL statement
ℹ️ [08:46:13] root INFO: No existing eligibility table to drop
ℹ️ [08:46:13] root INFO: Executing eligibility SQL statement
ℹ️ [08:46:13] root INFO: Executing SQL statement
ℹ️ [08:46:54] root INFO: ================================================================================
TLPTACO RUN START 2025-07-24 08:46:54
================================================================================
ℹ️ [08:46:54] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [08:46:54] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [08:46:54] root INFO: Calculation complete: 3 steps.
ℹ️ [08:46:54] root INFO: Calculating the number of waterfall steps.
ℹ️ [08:46:54] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [08:46:54] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [08:46:54] root INFO: Calculating the number of output steps.
ℹ️ [08:46:54] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [08:46:54] root INFO: Preparing logic for channel 'email'
ℹ️ [08:46:54] root INFO: Preparing logic for channel 'sms'
ℹ️ [08:46:54] root INFO: Preparing logic for channel 'push'
ℹ️ [08:46:54] root INFO: Calculation complete: 3 steps (files).
ℹ️ [08:46:54] root INFO: Using cached SQL statements.
ℹ️ [08:46:54] root INFO: Dropping existing table eligibility_poc
ℹ️ [08:46:54] root INFO: Executing SQL statement
ℹ️ [08:46:57] root INFO: SQL execution finished in 2.87s
ℹ️ [08:46:57] root INFO: Executing eligibility SQL statement
ℹ️ [08:46:57] root INFO: Executing SQL statement
ℹ️ [08:46:58] root INFO: SQL execution finished in 0.61s
ℹ️ [08:46:58] root INFO: Executing eligibility SQL statement
ℹ️ [08:46:58] root INFO: Executing SQL statement
ℹ️ [08:46:58] root INFO: SQL execution finished in 0.14s
ℹ️ [08:46:58] root INFO: Using cached waterfall steps.
ℹ️ [08:46:58] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [08:46:58] root INFO: Fetching data to DataFrame
ℹ️ [08:46:59] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.71s
ℹ️ [08:46:59] root INFO: Fetching data to DataFrame
ℹ️ [08:46:59] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.35s
ℹ️ [08:46:59] root INFO: Fetching data to DataFrame
ℹ️ [08:47:00] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.36s
ℹ️ [08:47:00] root INFO: Fetching data to DataFrame
ℹ️ [08:47:01] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.55s
ℹ️ [08:47:01] root INFO: Fetching data to DataFrame
ℹ️ [08:47:02] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.15s
ℹ️ [08:47:02] root INFO: Fetching data to DataFrame
ℹ️ [08:47:03] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.24s
ℹ️ [08:47:04] root INFO: Waterfall report for 'customer_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id.xlsx
ℹ️ [08:47:04] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [08:47:04] root INFO: Fetching data to DataFrame
ℹ️ [08:47:04] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.82s
ℹ️ [08:47:04] root INFO: Fetching data to DataFrame
ℹ️ [08:47:05] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.45s
ℹ️ [08:47:05] root INFO: Fetching data to DataFrame
ℹ️ [08:47:07] root INFO: Fetched DataFrame with 17 rows and 4 columns in 2.51s
ℹ️ [08:47:07] root INFO: Fetching data to DataFrame
ℹ️ [08:47:08] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.47s
ℹ️ [08:47:08] root INFO: Fetching data to DataFrame
ℹ️ [08:47:09] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.11s
ℹ️ [08:47:09] root INFO: Fetching data to DataFrame
ℹ️ [08:47:10] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.34s
ℹ️ [08:47:10] root INFO: Waterfall report for 'customer_id_account_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id_account_id.xlsx
ℹ️ [08:47:10] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [08:47:10] root INFO: Fetching data to DataFrame
ℹ️ [08:47:11] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.60s
ℹ️ [08:47:11] root INFO: Fetching data to DataFrame
ℹ️ [08:47:11] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.33s
ℹ️ [08:47:11] root INFO: Fetching data to DataFrame
ℹ️ [08:47:12] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.03s
ℹ️ [08:47:12] root INFO: Fetching data to DataFrame
ℹ️ [08:47:13] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.33s
ℹ️ [08:47:13] root INFO: Fetching data to DataFrame
ℹ️ [08:47:14] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.03s
ℹ️ [08:47:14] root INFO: Fetching data to DataFrame
ℹ️ [08:47:15] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.39s
ℹ️ [08:47:15] root INFO: Waterfall report for 'region_id_segment_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_region_id_segment_id.xlsx
ℹ️ [08:47:15] root INFO: Using cached output steps.
ℹ️ [08:47:15] root INFO: Running output job for channel email
ℹ️ [08:47:15] root INFO: Fetching data to DataFrame
ℹ️ [08:47:15] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.19s
ℹ️ [08:47:15] root INFO: Fetched 17 rows for channel email
ℹ️ [08:47:15] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [08:47:15] root INFO: Running output job for channel sms
ℹ️ [08:47:15] root INFO: Fetching data to DataFrame
ℹ️ [08:47:15] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.19s
ℹ️ [08:47:15] root INFO: Fetched 8 rows for channel sms
ℹ️ [08:47:15] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [08:47:15] root INFO: Running output job for channel push
ℹ️ [08:47:15] root INFO: Fetching data to DataFrame
ℹ️ [08:47:16] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.17s
ℹ️ [08:47:16] root INFO: Fetched 17 rows for channel push
ℹ️ [08:47:16] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [08:47:16] root INFO: Cleaning up DB connection
ℹ️ [08:54:51] root INFO: ================================================================================
TLPTACO RUN START 2025-07-24 08:54:51
================================================================================
ℹ️ [08:54:51] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [08:54:51] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [08:54:51] root INFO: Calculation complete: 3 steps.
ℹ️ [08:54:51] root INFO: Calculating the number of waterfall steps.
ℹ️ [08:54:51] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [08:54:51] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [08:54:51] root INFO: Calculating the number of output steps.
ℹ️ [08:54:51] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [08:54:51] root INFO: Preparing logic for channel 'email'
ℹ️ [08:54:51] root INFO: Preparing logic for channel 'sms'
ℹ️ [08:54:51] root INFO: Preparing logic for channel 'push'
ℹ️ [08:54:51] root INFO: Calculation complete: 3 steps (files).
ℹ️ [08:54:51] root INFO: Using cached SQL statements.
ℹ️ [08:54:51] root INFO: Dropping existing table eligibility_poc
ℹ️ [08:54:51] root INFO: Executing SQL statement
ℹ️ [08:54:55] root INFO: SQL execution finished in 3.36s
ℹ️ [08:54:55] root INFO: Executing eligibility SQL statement
ℹ️ [08:54:55] root INFO: Executing SQL statement
ℹ️ [08:54:56] root INFO: SQL execution finished in 0.89s
ℹ️ [08:54:56] root INFO: Executing eligibility SQL statement
ℹ️ [08:54:56] root INFO: Executing SQL statement
ℹ️ [08:54:56] root INFO: SQL execution finished in 0.25s
ℹ️ [08:54:56] root INFO: Using cached waterfall steps.
ℹ️ [08:54:56] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [08:54:56] root INFO: Fetching data to DataFrame
ℹ️ [08:54:57] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.59s
ℹ️ [08:54:57] root INFO: Fetching data to DataFrame
ℹ️ [08:54:57] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.33s
ℹ️ [08:54:57] root INFO: Fetching data to DataFrame
ℹ️ [08:54:58] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.03s
ℹ️ [08:58:12] root INFO: ================================================================================
TLPTACO RUN START 2025-07-24 08:58:12
================================================================================
ℹ️ [08:58:12] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [08:58:12] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [08:58:12] root INFO: Calculation complete: 3 steps.
ℹ️ [08:58:12] root INFO: Calculating the number of waterfall steps.
ℹ️ [08:58:12] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [08:58:13] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [08:58:13] root INFO: Calculating the number of output steps.
ℹ️ [08:58:13] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [08:58:13] root INFO: Preparing logic for channel 'email'
ℹ️ [08:58:13] root INFO: Preparing logic for channel 'sms'
ℹ️ [08:58:13] root INFO: Preparing logic for channel 'push'
ℹ️ [08:58:13] root INFO: Calculation complete: 3 steps (files).
ℹ️ [08:58:13] root INFO: Using cached SQL statements.
ℹ️ [08:58:13] root INFO: Dropping existing table eligibility_poc
ℹ️ [08:58:13] root INFO: Executing SQL statement
ℹ️ [08:58:14] root INFO: SQL execution finished in 0.94s
ℹ️ [08:58:14] root INFO: Executing eligibility SQL statement
ℹ️ [08:58:14] root INFO: Executing SQL statement
ℹ️ [08:58:14] root INFO: SQL execution finished in 0.48s
ℹ️ [08:58:14] root INFO: Executing eligibility SQL statement
ℹ️ [08:58:14] root INFO: Executing SQL statement
ℹ️ [08:58:14] root INFO: SQL execution finished in 0.15s
ℹ️ [08:58:14] root INFO: Using cached waterfall steps.
ℹ️ [08:58:14] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [08:58:14] root INFO: Fetching data to DataFrame
ℹ️ [08:58:15] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.59s
ℹ️ [08:58:15] root INFO: Fetching data to DataFrame
ℹ️ [08:58:15] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.35s
ℹ️ [08:58:15] root INFO: Fetching data to DataFrame
ℹ️ [08:58:16] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.14s
ℹ️ [08:59:31] root INFO: Fetching data to DataFrame
ℹ️ [08:59:31] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.43s
ℹ️ [08:59:31] root INFO: Fetching data to DataFrame
ℹ️ [08:59:32] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.12s
ℹ️ [09:00:46] root INFO: Fetching data to DataFrame
ℹ️ [09:00:47] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.06s
ℹ️ [09:35:07] root INFO: Waterfall report for 'customer_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id.xlsx
ℹ️ [09:35:07] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [09:35:07] root INFO: Fetching data to DataFrame
❌ [09:35:07] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
[Version 20.0.0.32] [Session 1336] [Teradata SQL Driver] Failure sending Start Request message
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).makeDriverError ErrorUtil.go:176
 at gosqldriver/teradatasql.(*teradataConnection).socketSendMessage NetworkIO.go:291
 at gosqldriver/teradatasql.(*teradataConnection).socketSendAndReceiveContext NetworkIO.go:70
 at gosqldriver/teradatasql.(*teradataConnection).sendAndReceiveContext NetworkIO.go:50
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:942
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Caused by write tcp 172.19.90.77:39194->34.61.19.128:443: write: connection timed out
unable to rollback
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1336] [Teradata SQL Driver] Failure sending Start Request message
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).makeDriverError ErrorUtil.go:176
 at gosqldriver/teradatasql.(*teradataConnection).socketSendMessage NetworkIO.go:291
 at gosqldriver/teradatasql.(*teradataConnection).socketSendAndReceiveContext NetworkIO.go:70
 at gosqldriver/teradatasql.(*teradataConnection).sendAndReceiveContext NetworkIO.go:50
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:942
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Caused by write tcp 172.19.90.77:39194->34.61.19.128:443: write: connection timed out

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2668, in execute
    self.con.rollback()
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 260, in rollback
    cur.execute ("{fn teradata_rollback}")
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1336] [Teradata SQL Driver] Failure sending Start Request message
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).makeDriverError ErrorUtil.go:176
 at gosqldriver/teradatasql.(*teradataConnection).socketSendMessage NetworkIO.go:291
 at gosqldriver/teradatasql.(*teradataConnection).socketSendAndReceiveContext NetworkIO.go:70
 at gosqldriver/teradatasql.(*teradataConnection).sendAndReceiveContext NetworkIO.go:50
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:942
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Caused by write tcp 172.19.90.77:39194->34.61.19.128:443: write: connection timed out

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 195, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2673, in execute
    raise ex from inner_exc
pandas.errors.DatabaseError: Execution failed on sql: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
[Version 20.0.0.32] [Session 1336] [Teradata SQL Driver] Failure sending Start Request message
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).makeDriverError ErrorUtil.go:176
 at gosqldriver/teradatasql.(*teradataConnection).socketSendMessage NetworkIO.go:291
 at gosqldriver/teradatasql.(*teradataConnection).socketSendAndReceiveContext NetworkIO.go:70
 at gosqldriver/teradatasql.(*teradataConnection).sendAndReceiveContext NetworkIO.go:50
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:942
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Caused by write tcp 172.19.90.77:39194->34.61.19.128:443: write: connection timed out
unable to rollback
ℹ️ [09:35:08] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [09:35:08] root INFO: Fetching data to DataFrame
❌ [09:35:08] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
[Version 20.0.0.32] [Session 1336] [Teradata SQL Driver] Failure sending Start Request message
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).makeDriverError ErrorUtil.go:176
 at gosqldriver/teradatasql.(*teradataConnection).socketSendMessage NetworkIO.go:291
 at gosqldriver/teradatasql.(*teradataConnection).socketSendAndReceiveContext NetworkIO.go:70
 at gosqldriver/teradatasql.(*teradataConnection).sendAndReceiveContext NetworkIO.go:50
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:942
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Caused by write tcp 172.19.90.77:39194->34.61.19.128:443: write: connection timed out
unable to rollback
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1336] [Teradata SQL Driver] Failure sending Start Request message
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).makeDriverError ErrorUtil.go:176
 at gosqldriver/teradatasql.(*teradataConnection).socketSendMessage NetworkIO.go:291
 at gosqldriver/teradatasql.(*teradataConnection).socketSendAndReceiveContext NetworkIO.go:70
 at gosqldriver/teradatasql.(*teradataConnection).sendAndReceiveContext NetworkIO.go:50
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:942
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Caused by write tcp 172.19.90.77:39194->34.61.19.128:443: write: connection timed out

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2668, in execute
    self.con.rollback()
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 260, in rollback
    cur.execute ("{fn teradata_rollback}")
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1336] [Teradata SQL Driver] Failure sending Start Request message
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).makeDriverError ErrorUtil.go:176
 at gosqldriver/teradatasql.(*teradataConnection).socketSendMessage NetworkIO.go:291
 at gosqldriver/teradatasql.(*teradataConnection).socketSendAndReceiveContext NetworkIO.go:70
 at gosqldriver/teradatasql.(*teradataConnection).sendAndReceiveContext NetworkIO.go:50
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:942
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Caused by write tcp 172.19.90.77:39194->34.61.19.128:443: write: connection timed out

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 195, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2673, in execute
    raise ex from inner_exc
pandas.errors.DatabaseError: Execution failed on sql: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] – fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT 'initial_population' AS stat_name,
           'Total'            AS check_name,
           COUNT(*)           AS cntr
    FROM flags

    UNION ALL

    -- ①  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ②  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ③  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ④  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ⑤  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
[Version 20.0.0.32] [Session 1336] [Teradata SQL Driver] Failure sending Start Request message
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).makeDriverError ErrorUtil.go:176
 at gosqldriver/teradatasql.(*teradataConnection).socketSendMessage NetworkIO.go:291
 at gosqldriver/teradatasql.(*teradataConnection).socketSendAndReceiveContext NetworkIO.go:70
 at gosqldriver/teradatasql.(*teradataConnection).sendAndReceiveContext NetworkIO.go:50
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:942
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Caused by write tcp 172.19.90.77:39194->34.61.19.128:443: write: connection timed out
unable to rollback
ℹ️ [09:35:08] root INFO: Using cached output steps.
ℹ️ [09:35:08] root INFO: Running output job for channel email
ℹ️ [09:35:08] root INFO: Fetching data to DataFrame
ℹ️ [09:36:01] root INFO: ================================================================================
TLPTACO RUN START 2025-07-24 09:36:01
================================================================================
ℹ️ [09:36:01] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [09:36:01] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [09:36:01] root INFO: Calculation complete: 3 steps.
ℹ️ [09:36:01] root INFO: Calculating the number of waterfall steps.
ℹ️ [09:36:01] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [09:36:01] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [09:36:01] root INFO: Calculating the number of output steps.
ℹ️ [09:36:01] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [09:36:01] root INFO: Preparing logic for channel 'email'
ℹ️ [09:36:01] root INFO: Preparing logic for channel 'sms'
ℹ️ [09:36:01] root INFO: Preparing logic for channel 'push'
ℹ️ [09:36:01] root INFO: Calculation complete: 3 steps (files).
ℹ️ [09:36:01] root INFO: Using cached SQL statements.
ℹ️ [09:36:01] root INFO: Dropping existing table eligibility_poc
ℹ️ [09:36:01] root INFO: Executing SQL statement
ℹ️ [09:36:02] root INFO: SQL execution finished in 0.99s
ℹ️ [09:36:02] root INFO: Executing eligibility SQL statement
ℹ️ [09:36:02] root INFO: Executing SQL statement
ℹ️ [09:36:03] root INFO: SQL execution finished in 0.53s
ℹ️ [09:36:03] root INFO: Executing eligibility SQL statement
ℹ️ [09:36:03] root INFO: Executing SQL statement
ℹ️ [09:36:03] root INFO: SQL execution finished in 0.16s
ℹ️ [09:36:03] root INFO: Using cached waterfall steps.
ℹ️ [09:36:03] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [09:36:03] root INFO: Fetching data to DataFrame
ℹ️ [09:36:03] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.58s
ℹ️ [09:36:03] root INFO: Fetching data to DataFrame
ℹ️ [09:36:04] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.35s
ℹ️ [09:36:04] root INFO: Fetching data to DataFrame
ℹ️ [09:36:07] root INFO: Fetched DataFrame with 17 rows and 4 columns in 3.58s
ℹ️ [09:36:07] root INFO: Fetching data to DataFrame
ℹ️ [09:36:08] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.88s
ℹ️ [09:36:08] root INFO: Fetching data to DataFrame
ℹ️ [09:36:10] root INFO: Fetched DataFrame with 17 rows and 4 columns in 2.00s
ℹ️ [09:36:10] root INFO: Fetching data to DataFrame
ℹ️ [09:36:11] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.20s
ℹ️ [09:36:12] root INFO: Waterfall report for 'customer_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id.xlsx
ℹ️ [09:36:12] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [09:36:12] root INFO: Fetching data to DataFrame
ℹ️ [09:36:12] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.72s
ℹ️ [09:36:12] root INFO: Fetching data to DataFrame
ℹ️ [09:36:13] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.47s
ℹ️ [09:36:13] root INFO: Fetching data to DataFrame
ℹ️ [09:36:14] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.64s
ℹ️ [09:36:14] root INFO: Fetching data to DataFrame
ℹ️ [09:36:15] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.35s
ℹ️ [09:36:15] root INFO: Fetching data to DataFrame
ℹ️ [09:36:16] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.09s
ℹ️ [09:36:16] root INFO: Fetching data to DataFrame
ℹ️ [09:36:17] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.16s
ℹ️ [09:36:17] root INFO: Waterfall report for 'customer_id_account_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id_account_id.xlsx
ℹ️ [09:36:17] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [09:36:17] root INFO: Fetching data to DataFrame
ℹ️ [09:36:18] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.71s
ℹ️ [09:36:18] root INFO: Fetching data to DataFrame
ℹ️ [09:36:18] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.43s
ℹ️ [09:36:18] root INFO: Fetching data to DataFrame
ℹ️ [09:36:19] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.17s
ℹ️ [09:36:19] root INFO: Fetching data to DataFrame
ℹ️ [09:36:20] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.45s
ℹ️ [09:36:20] root INFO: Fetching data to DataFrame
ℹ️ [09:36:21] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.60s
ℹ️ [09:36:21] root INFO: Fetching data to DataFrame
ℹ️ [09:36:23] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.15s
ℹ️ [09:36:23] root INFO: Waterfall report for 'region_id_segment_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_region_id_segment_id.xlsx
ℹ️ [09:36:23] root INFO: Using cached output steps.
ℹ️ [09:36:23] root INFO: Running output job for channel email
ℹ️ [09:36:23] root INFO: Fetching data to DataFrame
ℹ️ [09:36:23] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.15s
ℹ️ [09:36:23] root INFO: Fetched 17 rows for channel email
ℹ️ [09:36:23] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [09:36:23] root INFO: Running output job for channel sms
ℹ️ [09:36:23] root INFO: Fetching data to DataFrame
ℹ️ [09:36:23] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.17s
ℹ️ [09:36:23] root INFO: Fetched 8 rows for channel sms
ℹ️ [09:36:23] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [09:36:23] root INFO: Running output job for channel push
ℹ️ [09:36:23] root INFO: Fetching data to DataFrame
ℹ️ [09:36:23] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.15s
ℹ️ [09:36:23] root INFO: Fetched 17 rows for channel push
ℹ️ [09:36:23] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [09:36:23] root INFO: Cleaning up DB connection
ℹ️ [11:54:50] root INFO: ================================================================================
TLPTACO RUN START 2025-07-24 11:54:50
================================================================================
ℹ️ [11:54:50] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [11:54:50] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [11:54:50] root INFO: Calculation complete: 3 steps.
ℹ️ [11:54:50] root INFO: Calculating the number of waterfall steps.
ℹ️ [11:54:50] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [11:54:50] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [11:54:50] root INFO: Calculating the number of output steps.
ℹ️ [11:54:50] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [11:54:50] root INFO: Preparing logic for channel 'email'
ℹ️ [11:54:50] root INFO: Preparing logic for channel 'sms'
ℹ️ [11:54:50] root INFO: Preparing logic for channel 'push'
ℹ️ [11:54:50] root INFO: Calculation complete: 3 steps (files).
ℹ️ [11:54:50] root INFO: Using cached SQL statements.
ℹ️ [11:54:50] root INFO: Dropping existing table eligibility_poc
ℹ️ [11:54:50] root INFO: Executing SQL statement
ℹ️ [11:54:51] root INFO: SQL execution finished in 0.95s
ℹ️ [11:54:51] root INFO: Executing eligibility SQL statement
ℹ️ [11:54:51] root INFO: Executing SQL statement
ℹ️ [11:54:52] root INFO: SQL execution finished in 0.47s
ℹ️ [11:54:52] root INFO: Executing eligibility SQL statement
ℹ️ [11:54:52] root INFO: Executing SQL statement
ℹ️ [11:54:52] root INFO: SQL execution finished in 0.14s
ℹ️ [11:54:52] root INFO: Using cached waterfall steps.
ℹ️ [11:54:52] root INFO: Fetching data to DataFrame
ℹ️ [11:54:52] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.51s
ℹ️ [11:54:52] root INFO: Fetching data to DataFrame
ℹ️ [11:54:53] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [11:54:53] root INFO: Fetching data to DataFrame
ℹ️ [11:54:54] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.22s
ℹ️ [11:54:54] root INFO: Fetching data to DataFrame
ℹ️ [11:54:54] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.41s
ℹ️ [11:54:54] root INFO: Fetching data to DataFrame
ℹ️ [11:54:56] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.41s
ℹ️ [11:54:56] root INFO: Fetching data to DataFrame
ℹ️ [11:54:57] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.30s
ℹ️ [11:54:57] root INFO: Fetching data to DataFrame
ℹ️ [11:54:58] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.56s
ℹ️ [11:54:58] root INFO: Fetching data to DataFrame
ℹ️ [11:54:58] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [11:54:58] root INFO: Fetching data to DataFrame
ℹ️ [11:54:59] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.87s
ℹ️ [11:54:59] root INFO: Fetching data to DataFrame
ℹ️ [11:54:59] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [11:54:59] root INFO: Fetching data to DataFrame
ℹ️ [11:55:01] root INFO: Fetched DataFrame with 17 rows and 4 columns in 2.11s
ℹ️ [11:55:01] root INFO: Fetching data to DataFrame
ℹ️ [11:55:02] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.25s
ℹ️ [11:55:03] root INFO: Fetching data to DataFrame
ℹ️ [11:55:03] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.55s
ℹ️ [11:55:03] root INFO: Fetching data to DataFrame
ℹ️ [11:55:03] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.33s
ℹ️ [11:55:03] root INFO: Fetching data to DataFrame
ℹ️ [11:55:05] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.18s
ℹ️ [11:55:05] root INFO: Fetching data to DataFrame
ℹ️ [11:55:05] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.35s
ℹ️ [11:55:05] root INFO: Fetching data to DataFrame
ℹ️ [11:55:06] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.42s
ℹ️ [11:55:06] root INFO: Fetching data to DataFrame
ℹ️ [11:55:08] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.50s
ℹ️ [11:55:08] root INFO: Consolidated waterfall report written to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_all_groups.xlsx
ℹ️ [11:55:08] root INFO: Using cached output steps.
ℹ️ [11:55:08] root INFO: Running output job for channel email
ℹ️ [11:55:08] root INFO: Fetching data to DataFrame
ℹ️ [11:55:08] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.23s
ℹ️ [11:55:08] root INFO: Fetched 17 rows for channel email
ℹ️ [11:55:08] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [11:55:08] root INFO: Running output job for channel sms
ℹ️ [11:55:08] root INFO: Fetching data to DataFrame
ℹ️ [11:55:08] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.15s
ℹ️ [11:55:08] root INFO: Fetched 8 rows for channel sms
ℹ️ [11:55:08] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [11:55:08] root INFO: Running output job for channel push
ℹ️ [11:55:08] root INFO: Fetching data to DataFrame
ℹ️ [11:55:09] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.23s
ℹ️ [11:55:09] root INFO: Fetched 17 rows for channel push
ℹ️ [11:55:09] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [11:55:09] root INFO: Cleaning up DB connection
ℹ️ [13:30:29] root INFO: ================================================================================
TLPTACO RUN START 2025-07-24 13:30:29
================================================================================
ℹ️ [13:30:29] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [13:30:29] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [13:30:29] root INFO: Calculation complete: 3 steps.
ℹ️ [13:30:29] root INFO: Calculating the number of waterfall steps.
ℹ️ [13:30:29] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [13:30:29] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [13:30:29] root INFO: Calculating the number of output steps.
ℹ️ [13:30:29] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [13:30:29] root INFO: Preparing logic for channel 'email'
ℹ️ [13:30:29] root INFO: Preparing logic for channel 'sms'
ℹ️ [13:30:29] root INFO: Preparing logic for channel 'push'
ℹ️ [13:30:29] root INFO: Calculation complete: 3 steps (files).
ℹ️ [13:30:29] root INFO: Using cached SQL statements.
ℹ️ [13:30:29] root INFO: Dropping existing table eligibility_poc
ℹ️ [13:30:29] root INFO: Executing SQL statement
ℹ️ [13:30:30] root INFO: No existing eligibility table to drop
ℹ️ [13:30:30] root INFO: Executing eligibility SQL statement
ℹ️ [13:30:30] root INFO: Executing SQL statement
ℹ️ [13:30:45] root INFO: ================================================================================
TLPTACO RUN START 2025-07-24 13:30:45
================================================================================
ℹ️ [13:30:45] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [13:30:45] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [13:30:45] root INFO: Calculation complete: 3 steps.
ℹ️ [13:30:45] root INFO: Calculating the number of waterfall steps.
ℹ️ [13:30:45] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [13:30:45] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [13:30:45] root INFO: Calculating the number of output steps.
ℹ️ [13:30:45] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [13:30:45] root INFO: Preparing logic for channel 'email'
ℹ️ [13:30:45] root INFO: Preparing logic for channel 'sms'
ℹ️ [13:30:45] root INFO: Preparing logic for channel 'push'
ℹ️ [13:30:45] root INFO: Calculation complete: 3 steps (files).
ℹ️ [13:30:45] root INFO: Using cached SQL statements.
ℹ️ [13:30:45] root INFO: Dropping existing table eligibility_poc
ℹ️ [13:30:45] root INFO: Executing SQL statement
ℹ️ [13:30:46] root INFO: No existing eligibility table to drop
ℹ️ [13:30:46] root INFO: Executing eligibility SQL statement
ℹ️ [13:30:46] root INFO: Executing SQL statement
ℹ️ [13:30:50] root INFO: ================================================================================
TLPTACO RUN START 2025-07-24 13:30:50
================================================================================
ℹ️ [13:30:50] root INFO: Executing: DROP TABLE segments;
ℹ️ [13:30:50] root INFO: Executing SQL statement
⚠️ [13:30:51] root WARNING: Ignoring error: [Version 20.0.0.32] [Session 1010] [Teradata Database] [Error 3807] Object 'segments' does not exist.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [13:30:51] root INFO: Executing: DROP TABLE regions;
ℹ️ [13:30:51] root INFO: Executing SQL statement
⚠️ [13:30:51] root WARNING: Ignoring error: [Version 20.0.0.32] [Session 1010] [Teradata Database] [Error 3807] Object 'regions' does not exist.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [13:30:51] root INFO: Executing: DROP TABLE accounts;
ℹ️ [13:30:51] root INFO: Executing SQL statement
⚠️ [13:30:51] root WARNING: Ignoring error: [Version 20.0.0.32] [Session 1010] [Teradata Database] [Error 3807] Object 'accounts' does not exist.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [13:30:51] root INFO: Executing: DROP TABLE customers;
ℹ️ [13:30:51] root INFO: Executing SQL statement
⚠️ [13:30:51] root WARNING: Ignoring error: [Version 20.0.0.32] [Session 1010] [Teradata Database] [Error 3807] Object 'customers' does not exist.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [13:30:51] root INFO: Executing: CREATE TABLE customers (customer_id INTEGER, status VARCHAR(20));
ℹ️ [13:30:51] root INFO: Executing SQL statement
ℹ️ [13:30:51] root INFO: SQL execution finished in 0.48s
ℹ️ [13:30:51] root INFO: Executing: CREATE TABLE accounts (customer_id INTEGER, account_id INTEGER, acct_type VARCHAR(20));
ℹ️ [13:30:51] root INFO: Executing SQL statement
ℹ️ [13:30:52] root INFO: SQL execution finished in 0.57s
ℹ️ [13:30:52] root INFO: Executing: CREATE TABLE regions (customer_id INTEGER, region_id INTEGER, region_type VARCHAR(20));
ℹ️ [13:30:52] root INFO: Executing SQL statement
ℹ️ [13:30:53] root INFO: SQL execution finished in 0.67s
ℹ️ [13:30:53] root INFO: Executing: CREATE TABLE segments (customer_id INTEGER, segment_id INTEGER, segment_flag VARCHAR(20));
ℹ️ [13:30:53] root INFO: Executing SQL statement
ℹ️ [13:30:53] root INFO: SQL execution finished in 0.63s
ℹ️ [13:30:53] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (6, 'Inactive');
ℹ️ [13:30:53] root INFO: Executing SQL statement
ℹ️ [13:30:53] root INFO: SQL execution finished in 0.30s
ℹ️ [13:30:53] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (7, 'Active');
ℹ️ [13:30:53] root INFO: Executing SQL statement
ℹ️ [13:30:54] root INFO: SQL execution finished in 0.24s
ℹ️ [13:30:54] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (8, 'Pending');
ℹ️ [13:30:54] root INFO: Executing SQL statement
ℹ️ [13:30:54] root INFO: SQL execution finished in 0.30s
ℹ️ [13:30:54] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (9, 'Inactive');
ℹ️ [13:30:54] root INFO: Executing SQL statement
ℹ️ [13:30:54] root INFO: SQL execution finished in 0.28s
ℹ️ [13:30:54] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (10, 'Active');
ℹ️ [13:30:54] root INFO: Executing SQL statement
ℹ️ [13:30:54] root INFO: SQL execution finished in 0.20s
ℹ️ [13:30:54] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (11, 'Pending');
ℹ️ [13:30:54] root INFO: Executing SQL statement
ℹ️ [13:30:55] root INFO: SQL execution finished in 0.28s
ℹ️ [13:30:55] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (12, 'Inactive');
ℹ️ [13:30:55] root INFO: Executing SQL statement
ℹ️ [13:30:55] root INFO: SQL execution finished in 0.20s
ℹ️ [13:30:55] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (13, 'Active');
ℹ️ [13:30:55] root INFO: Executing SQL statement
ℹ️ [13:30:55] root INFO: SQL execution finished in 0.22s
ℹ️ [13:30:55] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (14, 'Pending');
ℹ️ [13:30:55] root INFO: Executing SQL statement
ℹ️ [13:30:55] root INFO: SQL execution finished in 0.16s
ℹ️ [13:30:55] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (15, 'Inactive');
ℹ️ [13:30:55] root INFO: Executing SQL statement
ℹ️ [13:30:56] root INFO: SQL execution finished in 0.22s
ℹ️ [13:30:56] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (16, 'Active');
ℹ️ [13:30:56] root INFO: Executing SQL statement
ℹ️ [13:30:56] root INFO: SQL execution finished in 0.14s
ℹ️ [13:30:56] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (17, 'Pending');
ℹ️ [13:30:56] root INFO: Executing SQL statement
ℹ️ [13:30:56] root INFO: SQL execution finished in 0.12s
ℹ️ [13:30:56] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (18, 'Inactive');
ℹ️ [13:30:56] root INFO: Executing SQL statement
ℹ️ [13:30:56] root INFO: SQL execution finished in 0.16s
ℹ️ [13:30:56] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (19, 'Active');
ℹ️ [13:30:56] root INFO: Executing SQL statement
ℹ️ [13:30:56] root INFO: SQL execution finished in 0.14s
ℹ️ [13:30:56] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (20, 'Pending');
ℹ️ [13:30:56] root INFO: Executing SQL statement
ℹ️ [13:30:56] root INFO: SQL execution finished in 0.16s
ℹ️ [13:30:56] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (21, 'Inactive');
ℹ️ [13:30:56] root INFO: Executing SQL statement
ℹ️ [13:30:56] root INFO: SQL execution finished in 0.12s
ℹ️ [13:30:56] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (22, 'Active');
ℹ️ [13:30:56] root INFO: Executing SQL statement
ℹ️ [13:30:57] root INFO: SQL execution finished in 0.12s
ℹ️ [13:30:57] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (23, 'Pending');
ℹ️ [13:30:57] root INFO: Executing SQL statement
ℹ️ [13:30:57] root INFO: SQL execution finished in 0.14s
ℹ️ [13:30:57] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (24, 'Inactive');
ℹ️ [13:30:57] root INFO: Executing SQL statement
ℹ️ [13:30:57] root INFO: SQL execution finished in 0.14s
ℹ️ [13:30:57] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (25, 'Active');
ℹ️ [13:30:57] root INFO: Executing SQL statement
ℹ️ [13:30:57] root INFO: SQL execution finished in 0.12s
ℹ️ [13:30:57] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (26, 'Pending');
ℹ️ [13:30:57] root INFO: Executing SQL statement
ℹ️ [13:30:57] root INFO: SQL execution finished in 0.14s
ℹ️ [13:30:57] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (27, 'Inactive');
ℹ️ [13:30:57] root INFO: Executing SQL statement
ℹ️ [13:30:57] root INFO: SQL execution finished in 0.12s
ℹ️ [13:30:57] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (28, 'Active');
ℹ️ [13:30:57] root INFO: Executing SQL statement
ℹ️ [13:30:57] root INFO: SQL execution finished in 0.20s
ℹ️ [13:30:57] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (29, 'Pending');
ℹ️ [13:30:57] root INFO: Executing SQL statement
ℹ️ [13:30:58] root INFO: SQL execution finished in 0.18s
ℹ️ [13:30:58] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (30, 'Inactive');
ℹ️ [13:30:58] root INFO: Executing SQL statement
ℹ️ [13:30:58] root INFO: SQL execution finished in 0.18s
ℹ️ [13:30:58] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (31, 'Active');
ℹ️ [13:30:58] root INFO: Executing SQL statement
ℹ️ [13:30:58] root INFO: SQL execution finished in 0.16s
ℹ️ [13:30:58] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (32, 'Pending');
ℹ️ [13:30:58] root INFO: Executing SQL statement
ℹ️ [13:30:58] root INFO: SQL execution finished in 0.18s
ℹ️ [13:30:58] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (33, 'Inactive');
ℹ️ [13:30:58] root INFO: Executing SQL statement
ℹ️ [13:30:58] root INFO: SQL execution finished in 0.22s
ℹ️ [13:30:58] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (34, 'Active');
ℹ️ [13:30:58] root INFO: Executing SQL statement
ℹ️ [13:30:59] root INFO: SQL execution finished in 0.16s
ℹ️ [13:30:59] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (35, 'Pending');
ℹ️ [13:30:59] root INFO: Executing SQL statement
ℹ️ [13:30:59] root INFO: SQL execution finished in 0.18s
ℹ️ [13:30:59] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (36, 'Inactive');
ℹ️ [13:30:59] root INFO: Executing SQL statement
ℹ️ [13:30:59] root INFO: SQL execution finished in 0.22s
ℹ️ [13:30:59] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (37, 'Active');
ℹ️ [13:30:59] root INFO: Executing SQL statement
ℹ️ [13:30:59] root INFO: SQL execution finished in 0.20s
ℹ️ [13:30:59] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (38, 'Pending');
ℹ️ [13:30:59] root INFO: Executing SQL statement
ℹ️ [13:30:59] root INFO: SQL execution finished in 0.18s
ℹ️ [13:30:59] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (39, 'Inactive');
ℹ️ [13:30:59] root INFO: Executing SQL statement
ℹ️ [13:30:59] root INFO: SQL execution finished in 0.16s
ℹ️ [13:30:59] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (40, 'Active');
ℹ️ [13:30:59] root INFO: Executing SQL statement
ℹ️ [13:31:00] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:00] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (41, 'Pending');
ℹ️ [13:31:00] root INFO: Executing SQL statement
ℹ️ [13:31:00] root INFO: SQL execution finished in 0.12s
ℹ️ [13:31:00] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (42, 'Inactive');
ℹ️ [13:31:00] root INFO: Executing SQL statement
ℹ️ [13:31:00] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:00] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (43, 'Active');
ℹ️ [13:31:00] root INFO: Executing SQL statement
ℹ️ [13:31:00] root INFO: SQL execution finished in 0.12s
ℹ️ [13:31:00] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (44, 'Pending');
ℹ️ [13:31:00] root INFO: Executing SQL statement
ℹ️ [13:31:00] root INFO: SQL execution finished in 0.12s
ℹ️ [13:31:00] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (45, 'Inactive');
ℹ️ [13:31:00] root INFO: Executing SQL statement
ℹ️ [13:31:00] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:00] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (46, 'Active');
ℹ️ [13:31:00] root INFO: Executing SQL statement
ℹ️ [13:31:00] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:00] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (47, 'Pending');
ℹ️ [13:31:00] root INFO: Executing SQL statement
ℹ️ [13:31:01] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:01] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (48, 'Inactive');
ℹ️ [13:31:01] root INFO: Executing SQL statement
ℹ️ [13:31:01] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:01] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (49, 'Active');
ℹ️ [13:31:01] root INFO: Executing SQL statement
ℹ️ [13:31:01] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:01] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (50, 'Pending');
ℹ️ [13:31:01] root INFO: Executing SQL statement
ℹ️ [13:31:01] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:01] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (51, 'Inactive');
ℹ️ [13:31:01] root INFO: Executing SQL statement
ℹ️ [13:31:01] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:01] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (52, 'Active');
ℹ️ [13:31:01] root INFO: Executing SQL statement
ℹ️ [13:31:01] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:01] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (53, 'Pending');
ℹ️ [13:31:01] root INFO: Executing SQL statement
ℹ️ [13:31:02] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:02] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (54, 'Inactive');
ℹ️ [13:31:02] root INFO: Executing SQL statement
ℹ️ [13:31:02] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:02] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (55, 'Active');
ℹ️ [13:31:02] root INFO: Executing SQL statement
ℹ️ [13:31:02] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:02] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (6, 306, 'Savings');
ℹ️ [13:31:02] root INFO: Executing SQL statement
ℹ️ [13:31:02] root INFO: SQL execution finished in 0.22s
ℹ️ [13:31:02] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (7, 307, 'Checking');
ℹ️ [13:31:02] root INFO: Executing SQL statement
ℹ️ [13:31:02] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:02] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (8, 308, 'Savings');
ℹ️ [13:31:02] root INFO: Executing SQL statement
ℹ️ [13:31:02] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:02] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (9, 309, 'Checking');
ℹ️ [13:31:02] root INFO: Executing SQL statement
ℹ️ [13:31:03] root INFO: SQL execution finished in 0.22s
ℹ️ [13:31:03] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (10, 310, 'Savings');
ℹ️ [13:31:03] root INFO: Executing SQL statement
ℹ️ [13:31:03] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:03] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (11, 311, 'Checking');
ℹ️ [13:31:03] root INFO: Executing SQL statement
ℹ️ [13:31:03] root INFO: SQL execution finished in 0.20s
ℹ️ [13:31:03] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (12, 312, 'Savings');
ℹ️ [13:31:03] root INFO: Executing SQL statement
ℹ️ [13:31:03] root INFO: SQL execution finished in 0.20s
ℹ️ [13:31:03] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (13, 313, 'Checking');
ℹ️ [13:31:03] root INFO: Executing SQL statement
ℹ️ [13:31:03] root INFO: SQL execution finished in 0.20s
ℹ️ [13:31:03] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (14, 314, 'Savings');
ℹ️ [13:31:03] root INFO: Executing SQL statement
ℹ️ [13:31:04] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:04] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (15, 315, 'Checking');
ℹ️ [13:31:04] root INFO: Executing SQL statement
ℹ️ [13:31:04] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:04] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (16, 316, 'Savings');
ℹ️ [13:31:04] root INFO: Executing SQL statement
ℹ️ [13:31:04] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:04] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (17, 317, 'Checking');
ℹ️ [13:31:04] root INFO: Executing SQL statement
ℹ️ [13:31:04] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:04] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (18, 318, 'Savings');
ℹ️ [13:31:04] root INFO: Executing SQL statement
ℹ️ [13:31:04] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:04] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (19, 319, 'Checking');
ℹ️ [13:31:04] root INFO: Executing SQL statement
ℹ️ [13:31:04] root INFO: SQL execution finished in 0.12s
ℹ️ [13:31:04] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (20, 320, 'Savings');
ℹ️ [13:31:04] root INFO: Executing SQL statement
ℹ️ [13:31:04] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:04] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (21, 321, 'Checking');
ℹ️ [13:31:04] root INFO: Executing SQL statement
ℹ️ [13:31:05] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:05] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (22, 322, 'Savings');
ℹ️ [13:31:05] root INFO: Executing SQL statement
ℹ️ [13:31:05] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:05] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (23, 323, 'Checking');
ℹ️ [13:31:05] root INFO: Executing SQL statement
ℹ️ [13:31:05] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:05] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (24, 324, 'Savings');
ℹ️ [13:31:05] root INFO: Executing SQL statement
ℹ️ [13:31:05] root INFO: SQL execution finished in 0.20s
ℹ️ [13:31:05] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (25, 325, 'Checking');
ℹ️ [13:31:05] root INFO: Executing SQL statement
ℹ️ [13:31:05] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:05] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (26, 326, 'Savings');
ℹ️ [13:31:05] root INFO: Executing SQL statement
ℹ️ [13:31:05] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:05] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (27, 327, 'Checking');
ℹ️ [13:31:05] root INFO: Executing SQL statement
ℹ️ [13:31:06] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:06] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (28, 328, 'Savings');
ℹ️ [13:31:06] root INFO: Executing SQL statement
ℹ️ [13:31:06] root INFO: SQL execution finished in 0.20s
ℹ️ [13:31:06] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (29, 329, 'Checking');
ℹ️ [13:31:06] root INFO: Executing SQL statement
ℹ️ [13:31:06] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:06] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (30, 330, 'Savings');
ℹ️ [13:31:06] root INFO: Executing SQL statement
ℹ️ [13:31:06] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:06] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (31, 331, 'Checking');
ℹ️ [13:31:06] root INFO: Executing SQL statement
ℹ️ [13:31:06] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:06] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (32, 332, 'Savings');
ℹ️ [13:31:06] root INFO: Executing SQL statement
ℹ️ [13:31:06] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:06] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (33, 333, 'Checking');
ℹ️ [13:31:06] root INFO: Executing SQL statement
ℹ️ [13:31:10] root INFO: SQL execution finished in 3.13s
ℹ️ [13:31:10] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (34, 334, 'Savings');
ℹ️ [13:31:10] root INFO: Executing SQL statement
ℹ️ [13:31:10] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:10] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (35, 335, 'Checking');
ℹ️ [13:31:10] root INFO: Executing SQL statement
ℹ️ [13:31:10] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:10] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (36, 336, 'Savings');
ℹ️ [13:31:10] root INFO: Executing SQL statement
ℹ️ [13:31:10] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:10] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (37, 337, 'Checking');
ℹ️ [13:31:10] root INFO: Executing SQL statement
ℹ️ [13:31:10] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:10] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (38, 338, 'Savings');
ℹ️ [13:31:10] root INFO: Executing SQL statement
ℹ️ [13:31:10] root INFO: SQL execution finished in 0.20s
ℹ️ [13:31:10] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (39, 339, 'Checking');
ℹ️ [13:31:10] root INFO: Executing SQL statement
ℹ️ [13:31:11] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:11] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (40, 340, 'Savings');
ℹ️ [13:31:11] root INFO: Executing SQL statement
ℹ️ [13:31:11] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:11] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (41, 341, 'Checking');
ℹ️ [13:31:11] root INFO: Executing SQL statement
ℹ️ [13:31:11] root INFO: SQL execution finished in 0.22s
ℹ️ [13:31:11] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (42, 342, 'Savings');
ℹ️ [13:31:11] root INFO: Executing SQL statement
ℹ️ [13:31:11] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:11] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (43, 343, 'Checking');
ℹ️ [13:31:11] root INFO: Executing SQL statement
ℹ️ [13:31:11] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:11] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (44, 344, 'Savings');
ℹ️ [13:31:11] root INFO: Executing SQL statement
ℹ️ [13:31:12] root INFO: SQL execution finished in 0.20s
ℹ️ [13:31:12] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (45, 345, 'Checking');
ℹ️ [13:31:12] root INFO: Executing SQL statement
ℹ️ [13:31:12] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:12] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (46, 346, 'Savings');
ℹ️ [13:31:12] root INFO: Executing SQL statement
ℹ️ [13:31:12] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:12] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (47, 347, 'Checking');
ℹ️ [13:31:12] root INFO: Executing SQL statement
ℹ️ [13:31:12] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:12] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (48, 348, 'Savings');
ℹ️ [13:31:12] root INFO: Executing SQL statement
ℹ️ [13:31:12] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:12] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (49, 349, 'Checking');
ℹ️ [13:31:12] root INFO: Executing SQL statement
ℹ️ [13:31:12] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:12] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (50, 350, 'Savings');
ℹ️ [13:31:12] root INFO: Executing SQL statement
ℹ️ [13:31:13] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:13] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (51, 351, 'Checking');
ℹ️ [13:31:13] root INFO: Executing SQL statement
ℹ️ [13:31:13] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:13] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (52, 352, 'Savings');
ℹ️ [13:31:13] root INFO: Executing SQL statement
ℹ️ [13:31:13] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:13] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (53, 353, 'Checking');
ℹ️ [13:31:13] root INFO: Executing SQL statement
ℹ️ [13:31:13] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:13] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (54, 354, 'Savings');
ℹ️ [13:31:13] root INFO: Executing SQL statement
ℹ️ [13:31:13] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:13] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (55, 355, 'Checking');
ℹ️ [13:31:13] root INFO: Executing SQL statement
ℹ️ [13:31:13] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:13] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (6, 60, 'South');
ℹ️ [13:31:13] root INFO: Executing SQL statement
ℹ️ [13:31:13] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:13] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (7, 70, 'East');
ℹ️ [13:31:13] root INFO: Executing SQL statement
ℹ️ [13:31:14] root INFO: SQL execution finished in 0.20s
ℹ️ [13:31:14] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (8, 80, 'West');
ℹ️ [13:31:14] root INFO: Executing SQL statement
ℹ️ [13:31:14] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:14] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (9, 90, 'North');
ℹ️ [13:31:14] root INFO: Executing SQL statement
ℹ️ [13:31:14] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:14] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (10, 100, 'South');
ℹ️ [13:31:14] root INFO: Executing SQL statement
ℹ️ [13:31:14] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:14] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (11, 110, 'East');
ℹ️ [13:31:14] root INFO: Executing SQL statement
ℹ️ [13:31:14] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:14] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (12, 120, 'West');
ℹ️ [13:31:14] root INFO: Executing SQL statement
ℹ️ [13:31:14] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:14] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (13, 130, 'North');
ℹ️ [13:31:14] root INFO: Executing SQL statement
ℹ️ [13:31:15] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:15] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (14, 140, 'South');
ℹ️ [13:31:15] root INFO: Executing SQL statement
ℹ️ [13:31:15] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:15] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (15, 150, 'East');
ℹ️ [13:31:15] root INFO: Executing SQL statement
ℹ️ [13:31:15] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:15] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (16, 160, 'West');
ℹ️ [13:31:15] root INFO: Executing SQL statement
ℹ️ [13:31:15] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:15] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (17, 170, 'North');
ℹ️ [13:31:15] root INFO: Executing SQL statement
ℹ️ [13:31:15] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:15] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (18, 180, 'South');
ℹ️ [13:31:15] root INFO: Executing SQL statement
ℹ️ [13:31:16] root INFO: SQL execution finished in 0.22s
ℹ️ [13:31:16] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (19, 190, 'East');
ℹ️ [13:31:16] root INFO: Executing SQL statement
ℹ️ [13:31:16] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:16] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (20, 200, 'West');
ℹ️ [13:31:16] root INFO: Executing SQL statement
ℹ️ [13:31:16] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:16] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (21, 210, 'North');
ℹ️ [13:31:16] root INFO: Executing SQL statement
ℹ️ [13:31:16] root INFO: SQL execution finished in 0.12s
ℹ️ [13:31:16] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (22, 220, 'South');
ℹ️ [13:31:16] root INFO: Executing SQL statement
ℹ️ [13:31:16] root INFO: SQL execution finished in 0.12s
ℹ️ [13:31:16] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (23, 230, 'East');
ℹ️ [13:31:16] root INFO: Executing SQL statement
ℹ️ [13:31:16] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:16] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (24, 240, 'West');
ℹ️ [13:31:16] root INFO: Executing SQL statement
ℹ️ [13:31:16] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:16] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (25, 250, 'North');
ℹ️ [13:31:16] root INFO: Executing SQL statement
ℹ️ [13:31:17] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:17] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (26, 260, 'South');
ℹ️ [13:31:17] root INFO: Executing SQL statement
ℹ️ [13:31:17] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:17] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (27, 270, 'East');
ℹ️ [13:31:17] root INFO: Executing SQL statement
ℹ️ [13:31:17] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:17] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (28, 280, 'West');
ℹ️ [13:31:17] root INFO: Executing SQL statement
ℹ️ [13:31:17] root INFO: SQL execution finished in 0.12s
ℹ️ [13:31:17] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (29, 290, 'North');
ℹ️ [13:31:17] root INFO: Executing SQL statement
ℹ️ [13:31:17] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:17] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (30, 300, 'South');
ℹ️ [13:31:17] root INFO: Executing SQL statement
ℹ️ [13:31:17] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:17] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (31, 310, 'East');
ℹ️ [13:31:17] root INFO: Executing SQL statement
ℹ️ [13:31:17] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:17] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (32, 320, 'West');
ℹ️ [13:31:17] root INFO: Executing SQL statement
ℹ️ [13:31:18] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:18] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (33, 330, 'North');
ℹ️ [13:31:18] root INFO: Executing SQL statement
ℹ️ [13:31:18] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:18] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (34, 340, 'South');
ℹ️ [13:31:18] root INFO: Executing SQL statement
ℹ️ [13:31:18] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:18] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (35, 350, 'East');
ℹ️ [13:31:18] root INFO: Executing SQL statement
ℹ️ [13:31:18] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:18] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (36, 360, 'West');
ℹ️ [13:31:18] root INFO: Executing SQL statement
ℹ️ [13:31:18] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:18] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (37, 370, 'North');
ℹ️ [13:31:18] root INFO: Executing SQL statement
ℹ️ [13:31:18] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:18] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (38, 380, 'South');
ℹ️ [13:31:18] root INFO: Executing SQL statement
ℹ️ [13:31:19] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:19] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (39, 390, 'East');
ℹ️ [13:31:19] root INFO: Executing SQL statement
ℹ️ [13:31:19] root INFO: SQL execution finished in 0.12s
ℹ️ [13:31:19] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (40, 400, 'West');
ℹ️ [13:31:19] root INFO: Executing SQL statement
ℹ️ [13:31:19] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:19] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (41, 410, 'North');
ℹ️ [13:31:19] root INFO: Executing SQL statement
ℹ️ [13:31:19] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:19] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (42, 420, 'South');
ℹ️ [13:31:19] root INFO: Executing SQL statement
ℹ️ [13:31:19] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:19] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (43, 430, 'East');
ℹ️ [13:31:19] root INFO: Executing SQL statement
ℹ️ [13:31:19] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:19] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (44, 440, 'West');
ℹ️ [13:31:19] root INFO: Executing SQL statement
ℹ️ [13:31:19] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:19] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (45, 450, 'North');
ℹ️ [13:31:19] root INFO: Executing SQL statement
ℹ️ [13:31:19] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:19] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (46, 460, 'South');
ℹ️ [13:31:19] root INFO: Executing SQL statement
ℹ️ [13:31:20] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:20] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (47, 470, 'East');
ℹ️ [13:31:20] root INFO: Executing SQL statement
ℹ️ [13:31:20] root INFO: SQL execution finished in 0.12s
ℹ️ [13:31:20] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (48, 480, 'West');
ℹ️ [13:31:20] root INFO: Executing SQL statement
ℹ️ [13:31:20] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:20] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (49, 490, 'North');
ℹ️ [13:31:20] root INFO: Executing SQL statement
ℹ️ [13:31:20] root INFO: SQL execution finished in 0.12s
ℹ️ [13:31:20] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (50, 500, 'South');
ℹ️ [13:31:20] root INFO: Executing SQL statement
ℹ️ [13:31:20] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:20] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (51, 510, 'East');
ℹ️ [13:31:20] root INFO: Executing SQL statement
ℹ️ [13:31:20] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:20] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (52, 520, 'West');
ℹ️ [13:31:20] root INFO: Executing SQL statement
ℹ️ [13:31:21] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:21] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (53, 530, 'North');
ℹ️ [13:31:21] root INFO: Executing SQL statement
ℹ️ [13:31:21] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:21] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (54, 540, 'South');
ℹ️ [13:31:21] root INFO: Executing SQL statement
ℹ️ [13:31:21] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:21] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (55, 550, 'East');
ℹ️ [13:31:21] root INFO: Executing SQL statement
ℹ️ [13:31:21] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:21] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (6, 6001, 'Promo1');
ℹ️ [13:31:21] root INFO: Executing SQL statement
ℹ️ [13:31:21] root INFO: SQL execution finished in 0.24s
ℹ️ [13:31:21] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (7, 6002, 'Promo2');
ℹ️ [13:31:21] root INFO: Executing SQL statement
ℹ️ [13:31:21] root INFO: SQL execution finished in 0.22s
ℹ️ [13:31:21] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (8, 6003, 'HighTx');
ℹ️ [13:31:21] root INFO: Executing SQL statement
ℹ️ [13:31:22] root INFO: SQL execution finished in 0.24s
ℹ️ [13:31:22] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (9, 6004, 'LowTx');
ℹ️ [13:31:22] root INFO: Executing SQL statement
ℹ️ [13:31:22] root INFO: SQL execution finished in 0.20s
ℹ️ [13:31:22] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (10, 6005, 'PromoA');
ℹ️ [13:31:22] root INFO: Executing SQL statement
ℹ️ [13:31:22] root INFO: SQL execution finished in 0.22s
ℹ️ [13:31:22] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (11, 6006, 'PromoB');
ℹ️ [13:31:22] root INFO: Executing SQL statement
ℹ️ [13:31:22] root INFO: SQL execution finished in 0.20s
ℹ️ [13:31:22] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (12, 6007, 'FlagA');
ℹ️ [13:31:22] root INFO: Executing SQL statement
ℹ️ [13:31:22] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:22] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (13, 6008, 'FlagB');
ℹ️ [13:31:22] root INFO: Executing SQL statement
ℹ️ [13:31:23] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:23] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (14, 6009, 'Promo1');
ℹ️ [13:31:23] root INFO: Executing SQL statement
ℹ️ [13:31:23] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:23] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (15, 6010, 'Promo2');
ℹ️ [13:31:23] root INFO: Executing SQL statement
ℹ️ [13:31:23] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:23] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (16, 6011, 'HighTx');
ℹ️ [13:31:23] root INFO: Executing SQL statement
ℹ️ [13:31:23] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:23] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (17, 6012, 'LowTx');
ℹ️ [13:31:23] root INFO: Executing SQL statement
ℹ️ [13:31:23] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:23] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (18, 6013, 'PromoA');
ℹ️ [13:31:23] root INFO: Executing SQL statement
ℹ️ [13:31:23] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:23] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (19, 6014, 'PromoB');
ℹ️ [13:31:23] root INFO: Executing SQL statement
ℹ️ [13:31:24] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:24] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (20, 6015, 'FlagA');
ℹ️ [13:31:24] root INFO: Executing SQL statement
ℹ️ [13:31:24] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:24] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (21, 6016, 'FlagB');
ℹ️ [13:31:24] root INFO: Executing SQL statement
ℹ️ [13:31:24] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:24] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (22, 6017, 'Promo1');
ℹ️ [13:31:24] root INFO: Executing SQL statement
ℹ️ [13:31:24] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:24] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (23, 6018, 'Promo2');
ℹ️ [13:31:24] root INFO: Executing SQL statement
ℹ️ [13:31:24] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:24] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (24, 6019, 'HighTx');
ℹ️ [13:31:24] root INFO: Executing SQL statement
ℹ️ [13:31:24] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:24] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (25, 6020, 'LowTx');
ℹ️ [13:31:24] root INFO: Executing SQL statement
ℹ️ [13:31:25] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:25] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (26, 6021, 'PromoA');
ℹ️ [13:31:25] root INFO: Executing SQL statement
ℹ️ [13:31:25] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:25] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (27, 6022, 'PromoB');
ℹ️ [13:31:25] root INFO: Executing SQL statement
ℹ️ [13:31:25] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:25] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (28, 6023, 'FlagA');
ℹ️ [13:31:25] root INFO: Executing SQL statement
ℹ️ [13:31:25] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:25] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (29, 6024, 'FlagB');
ℹ️ [13:31:25] root INFO: Executing SQL statement
ℹ️ [13:31:25] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:25] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (30, 6025, 'Promo1');
ℹ️ [13:31:25] root INFO: Executing SQL statement
ℹ️ [13:31:25] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:25] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (31, 6026, 'Promo2');
ℹ️ [13:31:25] root INFO: Executing SQL statement
ℹ️ [13:31:26] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:26] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (32, 6027, 'HighTx');
ℹ️ [13:31:26] root INFO: Executing SQL statement
ℹ️ [13:31:26] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:26] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (33, 6028, 'LowTx');
ℹ️ [13:31:26] root INFO: Executing SQL statement
ℹ️ [13:31:26] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:26] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (34, 6029, 'PromoA');
ℹ️ [13:31:26] root INFO: Executing SQL statement
ℹ️ [13:31:26] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:26] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (35, 6030, 'PromoB');
ℹ️ [13:31:26] root INFO: Executing SQL statement
ℹ️ [13:31:26] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:26] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (36, 6031, 'FlagA');
ℹ️ [13:31:26] root INFO: Executing SQL statement
ℹ️ [13:31:26] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:26] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (37, 6032, 'FlagB');
ℹ️ [13:31:26] root INFO: Executing SQL statement
ℹ️ [13:31:27] root INFO: SQL execution finished in 0.18s
ℹ️ [13:31:27] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (38, 6033, 'Promo1');
ℹ️ [13:31:27] root INFO: Executing SQL statement
ℹ️ [13:31:27] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:27] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (39, 6034, 'Promo2');
ℹ️ [13:31:27] root INFO: Executing SQL statement
ℹ️ [13:31:27] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:27] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (40, 6035, 'HighTx');
ℹ️ [13:31:27] root INFO: Executing SQL statement
ℹ️ [13:31:27] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:27] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (41, 6036, 'LowTx');
ℹ️ [13:31:27] root INFO: Executing SQL statement
ℹ️ [13:31:27] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:27] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (42, 6037, 'PromoA');
ℹ️ [13:31:27] root INFO: Executing SQL statement
ℹ️ [13:31:27] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:27] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (43, 6038, 'PromoB');
ℹ️ [13:31:27] root INFO: Executing SQL statement
ℹ️ [13:31:27] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:27] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (44, 6039, 'FlagA');
ℹ️ [13:31:27] root INFO: Executing SQL statement
ℹ️ [13:31:28] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:28] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (45, 6040, 'FlagB');
ℹ️ [13:31:28] root INFO: Executing SQL statement
ℹ️ [13:31:28] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:28] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (46, 6041, 'Promo1');
ℹ️ [13:31:28] root INFO: Executing SQL statement
ℹ️ [13:31:28] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:28] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (47, 6042, 'Promo2');
ℹ️ [13:31:28] root INFO: Executing SQL statement
ℹ️ [13:31:28] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:28] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (48, 6043, 'HighTx');
ℹ️ [13:31:28] root INFO: Executing SQL statement
ℹ️ [13:31:28] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:28] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (49, 6044, 'LowTx');
ℹ️ [13:31:28] root INFO: Executing SQL statement
ℹ️ [13:31:28] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:28] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (50, 6045, 'PromoA');
ℹ️ [13:31:28] root INFO: Executing SQL statement
ℹ️ [13:31:29] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:29] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (51, 6046, 'PromoB');
ℹ️ [13:31:29] root INFO: Executing SQL statement
ℹ️ [13:31:29] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:29] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (52, 6047, 'FlagA');
ℹ️ [13:31:29] root INFO: Executing SQL statement
ℹ️ [13:31:29] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:29] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (53, 6048, 'FlagB');
ℹ️ [13:31:29] root INFO: Executing SQL statement
ℹ️ [13:31:29] root INFO: SQL execution finished in 0.14s
ℹ️ [13:31:29] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (54, 6049, 'Promo1');
ℹ️ [13:31:29] root INFO: Executing SQL statement
ℹ️ [13:31:29] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:29] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (55, 6050, 'Promo2');
ℹ️ [13:31:29] root INFO: Executing SQL statement
ℹ️ [13:31:29] root INFO: SQL execution finished in 0.16s
ℹ️ [13:31:29] root INFO: Cleaning up DB connection
ℹ️ [13:31:29] root INFO: Test POC tables have been prepared.
ℹ️ [13:31:36] root INFO: ================================================================================
TLPTACO RUN START 2025-07-24 13:31:36
================================================================================
ℹ️ [13:31:36] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [13:31:36] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [13:31:36] root INFO: Calculation complete: 3 steps.
ℹ️ [13:31:36] root INFO: Calculating the number of waterfall steps.
ℹ️ [13:31:36] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [13:31:36] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [13:31:36] root INFO: Calculating the number of output steps.
ℹ️ [13:31:36] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [13:31:36] root INFO: Preparing logic for channel 'email'
ℹ️ [13:31:36] root INFO: Preparing logic for channel 'sms'
ℹ️ [13:31:36] root INFO: Preparing logic for channel 'push'
ℹ️ [13:31:36] root INFO: Calculation complete: 3 steps (files).
ℹ️ [13:31:36] root INFO: Using cached SQL statements.
ℹ️ [13:31:36] root INFO: Dropping existing table eligibility_poc
ℹ️ [13:31:36] root INFO: Executing SQL statement
ℹ️ [13:31:37] root INFO: No existing eligibility table to drop
ℹ️ [13:31:37] root INFO: Executing eligibility SQL statement
ℹ️ [13:31:37] root INFO: Executing SQL statement
ℹ️ [13:31:40] root INFO: SQL execution finished in 2.26s
ℹ️ [13:31:40] root INFO: Executing eligibility SQL statement
ℹ️ [13:31:40] root INFO: Executing SQL statement
ℹ️ [13:31:40] root INFO: SQL execution finished in 0.43s
ℹ️ [13:31:40] root INFO: Using cached waterfall steps.
ℹ️ [13:31:40] root INFO: Fetching data to DataFrame
ℹ️ [13:31:45] root INFO: Fetched DataFrame with 11 rows and 3 columns in 5.33s
ℹ️ [13:31:45] root INFO: Fetching data to DataFrame
ℹ️ [13:31:47] root INFO: Fetched DataFrame with 6 rows and 3 columns in 1.24s
ℹ️ [13:31:47] root INFO: Fetching data to DataFrame
ℹ️ [13:31:52] root INFO: Fetched DataFrame with 17 rows and 4 columns in 5.05s
ℹ️ [13:31:52] root INFO: Fetching data to DataFrame
ℹ️ [13:31:53] root INFO: Fetched DataFrame with 6 rows and 3 columns in 1.46s
ℹ️ [13:31:53] root INFO: Fetching data to DataFrame
ℹ️ [13:31:57] root INFO: Fetched DataFrame with 17 rows and 4 columns in 4.32s
ℹ️ [13:31:57] root INFO: Fetching data to DataFrame
ℹ️ [13:31:59] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.82s
ℹ️ [13:31:59] root INFO: Fetching data to DataFrame
ℹ️ [13:32:01] root INFO: Fetched DataFrame with 11 rows and 3 columns in 1.81s
ℹ️ [13:32:01] root INFO: Fetching data to DataFrame
ℹ️ [13:32:02] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.47s
ℹ️ [13:32:02] root INFO: Fetching data to DataFrame
ℹ️ [13:32:03] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.00s
ℹ️ [13:32:03] root INFO: Fetching data to DataFrame
ℹ️ [13:32:03] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [13:32:03] root INFO: Fetching data to DataFrame
ℹ️ [13:32:04] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.98s
ℹ️ [13:32:04] root INFO: Fetching data to DataFrame
ℹ️ [13:32:05] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.03s
ℹ️ [13:32:05] root INFO: Fetching data to DataFrame
ℹ️ [13:32:05] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.56s
ℹ️ [13:32:05] root INFO: Fetching data to DataFrame
ℹ️ [13:32:06] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.46s
ℹ️ [13:32:06] root INFO: Fetching data to DataFrame
ℹ️ [13:32:08] root INFO: Fetched DataFrame with 17 rows and 4 columns in 2.01s
ℹ️ [13:32:08] root INFO: Fetching data to DataFrame
ℹ️ [13:32:08] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.33s
ℹ️ [13:32:08] root INFO: Fetching data to DataFrame
ℹ️ [13:32:09] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.95s
ℹ️ [13:32:09] root INFO: Fetching data to DataFrame
ℹ️ [13:32:10] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.96s
ℹ️ [13:32:10] root INFO: Consolidated waterfall report written to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_all_groups.xlsx
ℹ️ [13:32:10] root INFO: Using cached output steps.
ℹ️ [13:32:10] root INFO: Running output job for channel email
ℹ️ [13:32:10] root INFO: Fetching data to DataFrame
ℹ️ [13:32:10] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.15s
ℹ️ [13:32:10] root INFO: Fetched 17 rows for channel email
ℹ️ [13:32:10] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [13:32:10] root INFO: Running output job for channel sms
ℹ️ [13:32:10] root INFO: Fetching data to DataFrame
ℹ️ [13:32:11] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.15s
ℹ️ [13:32:11] root INFO: Fetched 8 rows for channel sms
ℹ️ [13:32:11] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [13:32:11] root INFO: Running output job for channel push
ℹ️ [13:32:11] root INFO: Fetching data to DataFrame
ℹ️ [13:32:11] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.13s
ℹ️ [13:32:11] root INFO: Fetched 17 rows for channel push
ℹ️ [13:32:11] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [13:32:11] root INFO: Cleaning up DB connection
ℹ️ [15:39:39] root INFO: ================================================================================
TLPTACO RUN START 2025-07-24 15:39:39
================================================================================
ℹ️ [15:39:39] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [15:39:39] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [15:39:39] root INFO: Calculation complete: 3 steps.
ℹ️ [15:39:39] root INFO: Calculating the number of waterfall steps.
ℹ️ [15:39:39] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [15:39:39] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [15:39:39] root INFO: Calculating the number of output steps.
ℹ️ [15:39:39] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [15:39:39] root INFO: Preparing logic for channel 'email'
ℹ️ [15:39:39] root INFO: Preparing logic for channel 'sms'
ℹ️ [15:39:39] root INFO: Preparing logic for channel 'push'
ℹ️ [15:39:39] root INFO: Calculation complete: 3 steps (files).
ℹ️ [15:39:39] root INFO: Using cached SQL statements.
ℹ️ [15:39:39] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:39:39] root INFO: Executing SQL statement
ℹ️ [15:39:41] root INFO: SQL execution finished in 1.43s
ℹ️ [15:39:41] root INFO: Executing eligibility SQL statement
ℹ️ [15:39:41] root INFO: Executing SQL statement
ℹ️ [15:39:41] root INFO: SQL execution finished in 0.65s
ℹ️ [15:39:41] root INFO: Executing eligibility SQL statement
ℹ️ [15:39:41] root INFO: Executing SQL statement
ℹ️ [15:39:42] root INFO: SQL execution finished in 0.16s
ℹ️ [15:39:42] root INFO: Using cached waterfall steps.
ℹ️ [15:39:42] root INFO: Fetching data to DataFrame
ℹ️ [15:39:42] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.57s
ℹ️ [15:39:42] root INFO: Fetching data to DataFrame
ℹ️ [15:39:42] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [15:39:42] root INFO: Fetching data to DataFrame
ℹ️ [15:39:44] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.15s
ℹ️ [15:39:44] root INFO: Fetching data to DataFrame
ℹ️ [15:39:44] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.36s
ℹ️ [15:39:44] root INFO: Fetching data to DataFrame
ℹ️ [15:39:45] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.14s
ℹ️ [15:39:45] root INFO: Fetching data to DataFrame
ℹ️ [15:39:46] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.08s
ℹ️ [15:39:46] root INFO: Fetching data to DataFrame
ℹ️ [15:39:47] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.55s
ℹ️ [15:39:47] root INFO: Fetching data to DataFrame
ℹ️ [15:39:47] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.36s
ℹ️ [15:39:47] root INFO: Fetching data to DataFrame
ℹ️ [15:39:48] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.02s
ℹ️ [15:39:48] root INFO: Fetching data to DataFrame
ℹ️ [15:39:48] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.34s
ℹ️ [15:39:48] root INFO: Fetching data to DataFrame
ℹ️ [15:39:50] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.10s
ℹ️ [15:39:50] root INFO: Fetching data to DataFrame
ℹ️ [15:39:51] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.06s
ℹ️ [15:39:51] root INFO: Fetching data to DataFrame
ℹ️ [15:39:51] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.53s
ℹ️ [15:39:51] root INFO: Fetching data to DataFrame
ℹ️ [15:39:52] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.42s
ℹ️ [15:39:52] root INFO: Fetching data to DataFrame
ℹ️ [15:39:53] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.81s
ℹ️ [15:39:53] root INFO: Fetching data to DataFrame
ℹ️ [15:39:54] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.42s
ℹ️ [15:39:54] root INFO: Fetching data to DataFrame
ℹ️ [15:39:55] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.06s
ℹ️ [15:39:55] root INFO: Fetching data to DataFrame
ℹ️ [15:39:56] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.06s
ℹ️ [15:39:56] root INFO: Consolidated waterfall report written to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_all_groups.xlsx
ℹ️ [15:39:56] root INFO: Using cached output steps.
ℹ️ [15:39:56] root INFO: Running output job for channel email
ℹ️ [15:39:56] root INFO: Fetching data to DataFrame
ℹ️ [15:39:56] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.17s
ℹ️ [15:39:56] root INFO: Fetched 17 rows for channel email
ℹ️ [15:39:56] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [15:39:56] root INFO: Running output job for channel sms
ℹ️ [15:39:56] root INFO: Fetching data to DataFrame
ℹ️ [15:39:56] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.15s
ℹ️ [15:39:56] root INFO: Fetched 8 rows for channel sms
ℹ️ [15:39:56] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [15:39:56] root INFO: Running output job for channel push
ℹ️ [15:39:56] root INFO: Fetching data to DataFrame
ℹ️ [15:39:56] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.15s
ℹ️ [15:39:56] root INFO: Fetched 17 rows for channel push
ℹ️ [15:39:56] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [15:39:57] root INFO: Cleaning up DB connection
ℹ️ [09:06:42] root INFO: ================================================================================
TLPTACO RUN START 2025-07-28 09:06:42
================================================================================
ℹ️ [09:06:42] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [09:06:42] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [09:06:42] root INFO: Calculation complete: 3 steps.
ℹ️ [09:06:42] root INFO: Calculating the number of waterfall steps.
ℹ️ [09:06:42] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [09:06:42] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [09:06:42] root INFO: Calculating the number of output steps.
ℹ️ [09:06:42] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [09:06:42] root INFO: Preparing logic for channel 'email'
ℹ️ [09:06:42] root INFO: Preparing logic for channel 'sms'
ℹ️ [09:06:42] root INFO: Preparing logic for channel 'push'
ℹ️ [09:06:42] root INFO: Calculation complete: 3 steps (files).
ℹ️ [09:06:42] root INFO: Using cached SQL statements.
ℹ️ [09:06:42] root INFO: Dropping existing table eligibility_poc
ℹ️ [09:06:42] root INFO: Executing SQL statement
ℹ️ [09:06:43] root INFO: SQL execution finished in 1.27s
ℹ️ [09:06:43] root INFO: Executing eligibility SQL statement
ℹ️ [09:06:43] root INFO: Executing SQL statement
ℹ️ [09:06:44] root INFO: SQL execution finished in 0.89s
ℹ️ [09:06:44] root INFO: Executing eligibility SQL statement
ℹ️ [09:06:44] root INFO: Executing SQL statement
ℹ️ [09:06:44] root INFO: SQL execution finished in 0.22s
ℹ️ [09:06:44] root INFO: Using cached waterfall steps.
ℹ️ [09:06:44] root INFO: Fetching data to DataFrame
ℹ️ [09:06:45] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.85s
ℹ️ [09:06:45] root INFO: Fetching data to DataFrame
ℹ️ [09:06:45] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.33s
ℹ️ [09:06:45] root INFO: Fetching data to DataFrame
ℹ️ [09:06:46] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.16s
ℹ️ [09:06:46] root INFO: Fetching data to DataFrame
ℹ️ [09:06:47] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.60s
ℹ️ [09:06:47] root INFO: Fetching data to DataFrame
ℹ️ [09:06:49] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.47s
ℹ️ [09:06:49] root INFO: Fetching data to DataFrame
ℹ️ [09:06:50] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.52s
ℹ️ [09:06:50] root INFO: Fetching data to DataFrame
ℹ️ [09:06:51] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.90s
ℹ️ [09:06:51] root INFO: Fetching data to DataFrame
ℹ️ [09:06:52] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.58s
ℹ️ [09:06:52] root INFO: Fetching data to DataFrame
ℹ️ [09:06:54] root INFO: Fetched DataFrame with 17 rows and 4 columns in 2.45s
ℹ️ [09:06:54] root INFO: Fetching data to DataFrame
ℹ️ [09:06:55] root INFO: Fetched DataFrame with 6 rows and 3 columns in 1.06s
ℹ️ [09:06:55] root INFO: Fetching data to DataFrame
ℹ️ [09:06:58] root INFO: Fetched DataFrame with 17 rows and 4 columns in 2.44s
ℹ️ [09:06:58] root INFO: Fetching data to DataFrame
ℹ️ [09:06:59] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.49s
ℹ️ [09:06:59] root INFO: Fetching data to DataFrame
ℹ️ [09:07:00] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.96s
ℹ️ [09:07:00] root INFO: Fetching data to DataFrame
ℹ️ [09:07:01] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.93s
ℹ️ [09:07:01] root INFO: Fetching data to DataFrame
ℹ️ [09:07:03] root INFO: Fetched DataFrame with 17 rows and 4 columns in 2.20s
ℹ️ [09:07:03] root INFO: Fetching data to DataFrame
ℹ️ [09:07:04] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.46s
ℹ️ [09:07:04] root INFO: Fetching data to DataFrame
ℹ️ [09:07:05] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.57s
ℹ️ [09:07:05] root INFO: Fetching data to DataFrame
ℹ️ [09:07:08] root INFO: Fetched DataFrame with 17 rows and 4 columns in 3.14s
ℹ️ [09:07:08] root INFO: Consolidated waterfall report written to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_all_groups.xlsx
ℹ️ [09:07:09] root INFO: Waterfall run history appended to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_history.sqlite
ℹ️ [09:07:09] root INFO: Using cached output steps.
ℹ️ [09:07:09] root INFO: Running output job for channel email
ℹ️ [09:07:09] root INFO: Fetching data to DataFrame
ℹ️ [09:07:09] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.19s
ℹ️ [09:07:09] root INFO: Fetched 17 rows for channel email
ℹ️ [09:07:09] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [09:07:09] root INFO: Running output job for channel sms
ℹ️ [09:07:09] root INFO: Fetching data to DataFrame
ℹ️ [09:07:09] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.17s
ℹ️ [09:07:09] root INFO: Fetched 8 rows for channel sms
ℹ️ [09:07:09] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [09:07:09] root INFO: Running output job for channel push
ℹ️ [09:07:09] root INFO: Fetching data to DataFrame
ℹ️ [09:07:09] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.19s
ℹ️ [09:07:09] root INFO: Fetched 17 rows for channel push
ℹ️ [09:07:09] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [09:07:09] root INFO: Cleaning up DB connection
ℹ️ [09:48:40] root INFO: ================================================================================
TLPTACO RUN START 2025-07-28 09:48:40
================================================================================
ℹ️ [09:48:40] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [09:48:40] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [09:48:40] root INFO: Calculation complete: 3 steps.
ℹ️ [09:48:40] root INFO: Calculating the number of waterfall steps.
ℹ️ [09:48:40] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [09:48:40] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [09:48:40] root INFO: Calculating the number of output steps.
ℹ️ [09:48:40] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [09:48:40] root INFO: Preparing logic for channel 'email'
ℹ️ [09:48:40] root INFO: Preparing logic for channel 'sms'
ℹ️ [09:48:40] root INFO: Preparing logic for channel 'push'
ℹ️ [09:48:40] root INFO: Calculation complete: 3 steps (files).
ℹ️ [09:48:40] root INFO: Using cached SQL statements.
ℹ️ [09:48:40] root INFO: Dropping existing table eligibility_poc
ℹ️ [09:48:40] root INFO: Executing SQL statement
ℹ️ [09:48:41] root INFO: SQL execution finished in 1.02s
ℹ️ [09:48:41] root INFO: Executing eligibility SQL statement
ℹ️ [09:48:41] root INFO: Executing SQL statement
ℹ️ [09:48:42] root INFO: SQL execution finished in 0.53s
ℹ️ [09:48:42] root INFO: Executing eligibility SQL statement
ℹ️ [09:48:42] root INFO: Executing SQL statement
ℹ️ [09:48:42] root INFO: SQL execution finished in 0.20s
ℹ️ [09:48:42] root INFO: Using cached waterfall steps.
ℹ️ [09:48:42] root INFO: Fetching data to DataFrame
ℹ️ [09:48:43] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.53s
ℹ️ [09:48:43] root INFO: Fetching data to DataFrame
ℹ️ [09:48:43] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [09:48:43] root INFO: Fetching data to DataFrame
ℹ️ [09:48:44] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.98s
ℹ️ [09:48:44] root INFO: Fetching data to DataFrame
ℹ️ [09:48:44] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.33s
ℹ️ [09:48:44] root INFO: Fetching data to DataFrame
ℹ️ [09:48:45] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.93s
ℹ️ [09:48:45] root INFO: Fetching data to DataFrame
ℹ️ [09:48:46] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.97s
ℹ️ [09:48:46] root INFO: Fetching data to DataFrame
ℹ️ [09:48:47] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.47s
ℹ️ [09:48:47] root INFO: Fetching data to DataFrame
ℹ️ [09:48:47] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [09:48:47] root INFO: Fetching data to DataFrame
ℹ️ [09:48:48] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.99s
ℹ️ [09:48:48] root INFO: Fetching data to DataFrame
ℹ️ [09:48:48] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [09:48:48] root INFO: Fetching data to DataFrame
ℹ️ [09:48:49] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.93s
ℹ️ [09:48:49] root INFO: Fetching data to DataFrame
ℹ️ [09:48:50] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.27s
ℹ️ [09:48:50] root INFO: Fetching data to DataFrame
ℹ️ [09:48:51] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.78s
ℹ️ [09:48:51] root INFO: Fetching data to DataFrame
ℹ️ [09:48:51] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [09:48:51] root INFO: Fetching data to DataFrame
ℹ️ [09:48:52] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.99s
ℹ️ [09:48:52] root INFO: Fetching data to DataFrame
ℹ️ [09:48:53] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [09:48:53] root INFO: Fetching data to DataFrame
ℹ️ [09:48:54] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.95s
ℹ️ [09:48:54] root INFO: Fetching data to DataFrame
ℹ️ [09:48:55] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.01s
ℹ️ [09:48:55] root INFO: Consolidated waterfall report written to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_all_groups.xlsx
ℹ️ [09:48:55] root INFO: Waterfall run history appended to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_history.sqlite
ℹ️ [09:48:55] root INFO: Using cached output steps.
ℹ️ [09:48:55] root INFO: Running output job for channel email
ℹ️ [09:48:55] root INFO: Fetching data to DataFrame
ℹ️ [09:48:55] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.15s
ℹ️ [09:48:55] root INFO: Fetched 17 rows for channel email
ℹ️ [09:48:55] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [09:48:55] root INFO: Running output job for channel sms
ℹ️ [09:48:55] root INFO: Fetching data to DataFrame
ℹ️ [09:48:55] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.13s
ℹ️ [09:48:55] root INFO: Fetched 8 rows for channel sms
ℹ️ [09:48:55] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [09:48:55] root INFO: Running output job for channel push
ℹ️ [09:48:55] root INFO: Fetching data to DataFrame
ℹ️ [09:48:55] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.15s
ℹ️ [09:48:55] root INFO: Fetched 17 rows for channel push
ℹ️ [09:48:55] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [09:48:55] root INFO: Cleaning up DB connection
ℹ️ [11:09:03] root INFO: ================================================================================
TLPTACO RUN START 2025-07-28 11:09:03
================================================================================
ℹ️ [11:09:03] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [11:09:03] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [11:09:03] root INFO: Calculation complete: 3 steps.
ℹ️ [11:09:03] root INFO: Calculating the number of waterfall steps.
ℹ️ [11:09:03] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [11:09:03] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [11:09:03] root INFO: Calculating the number of output steps.
ℹ️ [11:09:03] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [11:09:03] root INFO: Preparing logic for channel 'email'
ℹ️ [11:09:03] root INFO: Preparing logic for channel 'sms'
ℹ️ [11:09:03] root INFO: Preparing logic for channel 'push'
ℹ️ [11:09:03] root INFO: Calculation complete: 3 steps (files).
ℹ️ [11:09:03] root INFO: Using cached SQL statements.
ℹ️ [11:09:03] root INFO: Dropping existing table eligibility_poc
ℹ️ [11:09:03] root INFO: Executing SQL statement
ℹ️ [11:09:04] root INFO: SQL execution finished in 1.00s
ℹ️ [11:09:04] root INFO: Executing eligibility SQL statement
ℹ️ [11:09:04] root INFO: Executing SQL statement
ℹ️ [11:09:05] root INFO: SQL execution finished in 0.49s
ℹ️ [11:09:05] root INFO: Executing eligibility SQL statement
ℹ️ [11:09:05] root INFO: Executing SQL statement
ℹ️ [11:09:05] root INFO: SQL execution finished in 0.16s
ℹ️ [11:09:05] root INFO: Using cached waterfall steps.
ℹ️ [11:09:05] root INFO: Fetching data to DataFrame
ℹ️ [11:09:06] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.54s
ℹ️ [11:09:06] root INFO: Fetching data to DataFrame
ℹ️ [11:09:06] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [11:09:06] root INFO: Fetching data to DataFrame
ℹ️ [11:09:07] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.97s
ℹ️ [11:09:07] root INFO: Fetching data to DataFrame
ℹ️ [11:09:07] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [11:09:07] root INFO: Fetching data to DataFrame
ℹ️ [11:09:08] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.01s
ℹ️ [11:09:08] root INFO: Fetching data to DataFrame
ℹ️ [11:09:09] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.17s
❌ [11:09:09] root ERROR: Waterfall grouping 'customer_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 290, in run
    prev_result = self._fetch_previous_group_metrics(group['name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 540, in _fetch_previous_group_metrics
    (df_raw['stat_name'] == 'initial_population')
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [11:09:09] root INFO: Fetching data to DataFrame
ℹ️ [11:09:10] root INFO: Fetched DataFrame with 11 rows and 3 columns in 1.00s
ℹ️ [11:09:10] root INFO: Fetching data to DataFrame
ℹ️ [11:09:11] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.33s
ℹ️ [11:09:11] root INFO: Fetching data to DataFrame
ℹ️ [11:09:12] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.93s
ℹ️ [11:09:12] root INFO: Fetching data to DataFrame
ℹ️ [11:09:12] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.33s
ℹ️ [11:09:12] root INFO: Fetching data to DataFrame
ℹ️ [11:09:13] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.95s
ℹ️ [11:09:13] root INFO: Fetching data to DataFrame
ℹ️ [11:09:14] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.01s
❌ [11:09:14] root ERROR: Waterfall grouping 'customer_id_account_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 290, in run
    prev_result = self._fetch_previous_group_metrics(group['name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 540, in _fetch_previous_group_metrics
    (df_raw['stat_name'] == 'initial_population')
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [11:09:14] root INFO: Fetching data to DataFrame
ℹ️ [11:09:14] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.47s
ℹ️ [11:09:14] root INFO: Fetching data to DataFrame
ℹ️ [11:09:15] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.33s
ℹ️ [11:09:15] root INFO: Fetching data to DataFrame
ℹ️ [11:09:16] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.91s
ℹ️ [11:09:16] root INFO: Fetching data to DataFrame
ℹ️ [11:09:16] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [11:09:16] root INFO: Fetching data to DataFrame
ℹ️ [11:09:17] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.05s
ℹ️ [11:09:17] root INFO: Fetching data to DataFrame
ℹ️ [11:09:18] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.92s
❌ [11:09:18] root ERROR: Waterfall grouping 'region_id_segment_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 290, in run
    prev_result = self._fetch_previous_group_metrics(group['name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 540, in _fetch_previous_group_metrics
    (df_raw['stat_name'] == 'initial_population')
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [11:09:18] root INFO: Consolidated waterfall report written to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/Running_2025_07_28_11:09:18.xlsx
ℹ️ [11:09:18] root INFO: Waterfall run history appended to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_history.sqlite
ℹ️ [11:09:18] root INFO: Using cached output steps.
ℹ️ [11:09:18] root INFO: Running output job for channel email
ℹ️ [11:09:18] root INFO: Fetching data to DataFrame
ℹ️ [11:09:18] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.15s
ℹ️ [11:09:18] root INFO: Fetched 17 rows for channel email
ℹ️ [11:09:18] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [11:09:18] root INFO: Running output job for channel sms
ℹ️ [11:09:18] root INFO: Fetching data to DataFrame
ℹ️ [11:09:18] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.14s
ℹ️ [11:09:18] root INFO: Fetched 8 rows for channel sms
ℹ️ [11:09:18] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [11:09:18] root INFO: Running output job for channel push
ℹ️ [11:09:18] root INFO: Fetching data to DataFrame
ℹ️ [11:09:18] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.13s
ℹ️ [11:09:18] root INFO: Fetched 17 rows for channel push
ℹ️ [11:09:18] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [11:09:18] root INFO: Cleaning up DB connection
ℹ️ [11:13:03] root INFO: ================================================================================
TLPTACO RUN START 2025-07-28 11:13:03
================================================================================
ℹ️ [11:13:03] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [11:13:03] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [11:13:03] root INFO: Calculation complete: 3 steps.
ℹ️ [11:13:03] root INFO: Calculating the number of waterfall steps.
ℹ️ [11:13:03] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [11:13:03] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [11:13:03] root INFO: Calculating the number of output steps.
ℹ️ [11:13:03] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [11:13:03] root INFO: Preparing logic for channel 'email'
ℹ️ [11:13:03] root INFO: Preparing logic for channel 'sms'
ℹ️ [11:13:03] root INFO: Preparing logic for channel 'push'
ℹ️ [11:13:03] root INFO: Calculation complete: 3 steps (files).
ℹ️ [11:13:03] root INFO: Using cached SQL statements.
ℹ️ [11:13:03] root INFO: Dropping existing table eligibility_poc
ℹ️ [11:13:03] root INFO: Executing SQL statement
ℹ️ [11:13:04] root INFO: SQL execution finished in 0.98s
ℹ️ [11:13:04] root INFO: Executing eligibility SQL statement
ℹ️ [11:13:04] root INFO: Executing SQL statement
ℹ️ [11:13:04] root INFO: SQL execution finished in 0.47s
ℹ️ [11:13:04] root INFO: Executing eligibility SQL statement
ℹ️ [11:13:04] root INFO: Executing SQL statement
ℹ️ [11:13:05] root INFO: SQL execution finished in 0.16s
ℹ️ [11:13:05] root INFO: Using cached waterfall steps.
ℹ️ [11:13:05] root INFO: Fetching data to DataFrame
ℹ️ [11:13:05] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.48s
ℹ️ [11:13:05] root INFO: Fetching data to DataFrame
ℹ️ [11:13:05] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [11:13:05] root INFO: Fetching data to DataFrame
ℹ️ [11:13:06] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.97s
ℹ️ [11:13:06] root INFO: Fetching data to DataFrame
ℹ️ [11:13:07] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [11:13:07] root INFO: Fetching data to DataFrame
ℹ️ [11:13:08] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.95s
ℹ️ [11:13:08] root INFO: Fetching data to DataFrame
ℹ️ [11:13:09] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.95s
ℹ️ [11:13:09] root INFO: Fetching data to DataFrame
ℹ️ [11:13:09] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.48s
ℹ️ [11:13:09] root INFO: Fetching data to DataFrame
ℹ️ [11:13:09] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [11:13:09] root INFO: Fetching data to DataFrame
ℹ️ [11:13:10] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.97s
ℹ️ [11:13:10] root INFO: Fetching data to DataFrame
ℹ️ [11:13:11] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [11:13:11] root INFO: Fetching data to DataFrame
ℹ️ [11:13:12] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.93s
ℹ️ [11:13:12] root INFO: Fetching data to DataFrame
ℹ️ [11:13:13] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.13s
ℹ️ [11:13:13] root INFO: Fetching data to DataFrame
ℹ️ [11:13:14] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.86s
ℹ️ [11:13:14] root INFO: Fetching data to DataFrame
ℹ️ [11:13:14] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.39s
ℹ️ [11:13:14] root INFO: Fetching data to DataFrame
ℹ️ [11:13:15] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.97s
ℹ️ [11:13:15] root INFO: Fetching data to DataFrame
ℹ️ [11:13:15] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [11:13:15] root INFO: Fetching data to DataFrame
ℹ️ [11:13:16] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.99s
ℹ️ [11:13:16] root INFO: Fetching data to DataFrame
ℹ️ [11:13:17] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.95s
ℹ️ [11:13:17] root INFO: Consolidated waterfall report written to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/Running_2025_07_28_11:13:17.xlsx
ℹ️ [11:13:17] root INFO: Waterfall run history appended to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_history.sqlite
ℹ️ [11:13:17] root INFO: Using cached output steps.
ℹ️ [11:13:17] root INFO: Running output job for channel email
ℹ️ [11:13:17] root INFO: Fetching data to DataFrame
ℹ️ [11:13:17] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.12s
ℹ️ [11:13:17] root INFO: Fetched 17 rows for channel email
ℹ️ [11:13:17] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [11:13:17] root INFO: Running output job for channel sms
ℹ️ [11:13:17] root INFO: Fetching data to DataFrame
ℹ️ [11:13:18] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.15s
ℹ️ [11:13:18] root INFO: Fetched 8 rows for channel sms
ℹ️ [11:13:18] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [11:13:18] root INFO: Running output job for channel push
ℹ️ [11:13:18] root INFO: Fetching data to DataFrame
ℹ️ [11:13:18] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.13s
ℹ️ [11:13:18] root INFO: Fetched 17 rows for channel push
ℹ️ [11:13:18] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [11:13:18] root INFO: Cleaning up DB connection
ℹ️ [11:16:49] root INFO: ================================================================================
TLPTACO RUN START 2025-07-28 11:16:49
================================================================================
ℹ️ [11:16:49] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [11:16:49] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [11:16:49] root INFO: Calculation complete: 3 steps.
ℹ️ [11:16:49] root INFO: Calculating the number of waterfall steps.
ℹ️ [11:16:49] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [11:16:49] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [11:16:49] root INFO: Calculating the number of output steps.
ℹ️ [11:16:49] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [11:16:49] root INFO: Preparing logic for channel 'email'
ℹ️ [11:16:49] root INFO: Preparing logic for channel 'sms'
ℹ️ [11:16:49] root INFO: Preparing logic for channel 'push'
ℹ️ [11:16:49] root INFO: Calculation complete: 3 steps (files).
ℹ️ [11:16:49] root INFO: Using cached SQL statements.
ℹ️ [11:16:49] root INFO: Dropping existing table eligibility_poc
ℹ️ [11:16:49] root INFO: Executing SQL statement
ℹ️ [11:16:50] root INFO: SQL execution finished in 0.99s
ℹ️ [11:16:50] root INFO: Executing eligibility SQL statement
ℹ️ [11:16:50] root INFO: Executing SQL statement
ℹ️ [11:16:50] root INFO: SQL execution finished in 0.47s
ℹ️ [11:16:50] root INFO: Executing eligibility SQL statement
ℹ️ [11:16:50] root INFO: Executing SQL statement
ℹ️ [11:16:51] root INFO: SQL execution finished in 0.14s
ℹ️ [11:16:51] root INFO: Using cached waterfall steps.
ℹ️ [11:16:51] root INFO: Fetching data to DataFrame
ℹ️ [11:16:51] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.54s
ℹ️ [11:16:51] root INFO: Fetching data to DataFrame
ℹ️ [11:16:51] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [11:16:51] root INFO: Fetching data to DataFrame
ℹ️ [11:16:52] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.99s
ℹ️ [11:16:52] root INFO: Fetching data to DataFrame
ℹ️ [11:16:53] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [11:16:53] root INFO: Fetching data to DataFrame
ℹ️ [11:16:54] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.37s
ℹ️ [11:16:54] root INFO: Fetching data to DataFrame
ℹ️ [11:16:55] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.18s
ℹ️ [11:16:55] root INFO: Fetching data to DataFrame
ℹ️ [11:16:56] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.49s
ℹ️ [11:16:56] root INFO: Fetching data to DataFrame
ℹ️ [11:16:56] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [11:16:56] root INFO: Fetching data to DataFrame
ℹ️ [11:16:57] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.04s
ℹ️ [11:16:57] root INFO: Fetching data to DataFrame
ℹ️ [11:16:57] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [11:16:57] root INFO: Fetching data to DataFrame
ℹ️ [11:16:58] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.00s
ℹ️ [11:16:58] root INFO: Fetching data to DataFrame
ℹ️ [11:17:00] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.05s
ℹ️ [11:17:00] root INFO: Fetching data to DataFrame
ℹ️ [11:17:00] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.52s
ℹ️ [11:17:00] root INFO: Fetching data to DataFrame
ℹ️ [11:17:00] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [11:17:00] root INFO: Fetching data to DataFrame
ℹ️ [11:17:01] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.15s
ℹ️ [11:17:01] root INFO: Fetching data to DataFrame
ℹ️ [11:17:02] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [11:17:02] root INFO: Fetching data to DataFrame
ℹ️ [11:17:03] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.99s
ℹ️ [11:17:03] root INFO: Fetching data to DataFrame
ℹ️ [11:17:04] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.98s
ℹ️ [11:17:04] root INFO: Consolidated waterfall report written to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/XX001_2025_07_28_11:17:04.xlsx
ℹ️ [11:17:04] root INFO: Waterfall run history appended to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_history.sqlite
ℹ️ [11:17:04] root INFO: Using cached output steps.
ℹ️ [11:17:04] root INFO: Running output job for channel email
ℹ️ [11:17:04] root INFO: Fetching data to DataFrame
ℹ️ [11:17:04] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.12s
ℹ️ [11:17:04] root INFO: Fetched 17 rows for channel email
ℹ️ [11:17:04] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [11:17:04] root INFO: Running output job for channel sms
ℹ️ [11:17:04] root INFO: Fetching data to DataFrame
ℹ️ [11:17:04] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.13s
ℹ️ [11:17:04] root INFO: Fetched 8 rows for channel sms
ℹ️ [11:17:04] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [11:17:04] root INFO: Running output job for channel push
ℹ️ [11:17:04] root INFO: Fetching data to DataFrame
ℹ️ [11:17:04] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.13s
ℹ️ [11:17:04] root INFO: Fetched 17 rows for channel push
ℹ️ [11:17:04] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [11:17:04] root INFO: Cleaning up DB connection
ℹ️ [11:19:33] root INFO: ================================================================================
TLPTACO RUN START 2025-07-28 11:19:33
================================================================================
ℹ️ [11:19:33] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [11:19:33] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [11:19:33] root INFO: Calculation complete: 3 steps.
ℹ️ [11:19:33] root INFO: Calculating the number of waterfall steps.
ℹ️ [11:19:33] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [11:19:33] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [11:19:33] root INFO: Calculating the number of output steps.
ℹ️ [11:19:33] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [11:19:33] root INFO: Preparing logic for channel 'email'
ℹ️ [11:19:33] root INFO: Preparing logic for channel 'sms'
ℹ️ [11:19:33] root INFO: Preparing logic for channel 'push'
ℹ️ [11:19:33] root INFO: Calculation complete: 3 steps (files).
ℹ️ [11:19:33] root INFO: Using cached SQL statements.
ℹ️ [11:19:33] root INFO: Dropping existing table eligibility_poc
ℹ️ [11:19:33] root INFO: Executing SQL statement
ℹ️ [11:19:34] root INFO: SQL execution finished in 0.91s
ℹ️ [11:19:34] root INFO: Executing eligibility SQL statement
ℹ️ [11:19:34] root INFO: Executing SQL statement
ℹ️ [11:19:35] root INFO: SQL execution finished in 0.49s
ℹ️ [11:19:35] root INFO: Executing eligibility SQL statement
ℹ️ [11:19:35] root INFO: Executing SQL statement
ℹ️ [11:19:35] root INFO: SQL execution finished in 0.16s
ℹ️ [11:19:35] root INFO: Using cached waterfall steps.
ℹ️ [11:19:35] root INFO: Fetching data to DataFrame
ℹ️ [11:19:35] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.32s
ℹ️ [11:19:35] root INFO: Fetching data to DataFrame
ℹ️ [11:19:36] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [11:19:36] root INFO: Fetching data to DataFrame
ℹ️ [11:19:37] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.11s
ℹ️ [11:19:37] root INFO: Fetching data to DataFrame
ℹ️ [11:19:37] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.41s
ℹ️ [11:19:37] root INFO: Fetching data to DataFrame
ℹ️ [11:19:38] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.23s
ℹ️ [11:19:38] root INFO: Fetching data to DataFrame
ℹ️ [11:19:39] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.93s
ℹ️ [11:19:39] root INFO: Fetching data to DataFrame
ℹ️ [11:19:40] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [11:19:40] root INFO: Fetching data to DataFrame
ℹ️ [11:19:40] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [11:19:40] root INFO: Fetching data to DataFrame
ℹ️ [11:19:41] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.97s
ℹ️ [11:19:41] root INFO: Fetching data to DataFrame
ℹ️ [11:19:41] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [11:19:41] root INFO: Fetching data to DataFrame
ℹ️ [11:19:42] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.87s
ℹ️ [11:19:42] root INFO: Fetching data to DataFrame
ℹ️ [11:19:43] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.93s
ℹ️ [11:19:43] root INFO: Fetching data to DataFrame
ℹ️ [11:19:43] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [11:19:43] root INFO: Fetching data to DataFrame
ℹ️ [11:19:43] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [11:19:43] root INFO: Fetching data to DataFrame
ℹ️ [11:19:44] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.93s
ℹ️ [11:19:44] root INFO: Fetching data to DataFrame
ℹ️ [11:19:45] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [11:19:45] root INFO: Fetching data to DataFrame
ℹ️ [11:19:46] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.91s
ℹ️ [11:19:46] root INFO: Fetching data to DataFrame
ℹ️ [11:19:47] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.91s
ℹ️ [11:19:47] root INFO: Consolidated waterfall report written to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/XX001_2025_07_28_11:19:47.xlsx
ℹ️ [11:19:47] root INFO: Waterfall run history appended to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_history.sqlite
ℹ️ [11:19:47] root INFO: Using cached output steps.
ℹ️ [11:19:47] root INFO: Running output job for channel email
ℹ️ [11:19:47] root INFO: Fetching data to DataFrame
ℹ️ [11:19:47] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.12s
ℹ️ [11:19:47] root INFO: Fetched 17 rows for channel email
ℹ️ [11:19:47] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [11:19:47] root INFO: Running output job for channel sms
ℹ️ [11:19:47] root INFO: Fetching data to DataFrame
ℹ️ [11:19:47] root INFO: Fetched DataFrame with 25 rows and 5 columns in 0.13s
ℹ️ [11:19:47] root INFO: Fetched 25 rows for channel sms
ℹ️ [11:19:47] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [11:19:47] root INFO: Running output job for channel push
ℹ️ [11:19:47] root INFO: Fetching data to DataFrame
ℹ️ [11:19:47] root INFO: Fetched DataFrame with 50 rows and 5 columns in 0.13s
ℹ️ [11:19:47] root INFO: Fetched 50 rows for channel push
ℹ️ [11:19:47] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [11:19:47] root INFO: Cleaning up DB connection
ℹ️ [16:21:46] root INFO: ================================================================================
TLPTACO RUN START 2025-07-28 16:21:46
================================================================================
ℹ️ [16:21:46] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [16:21:46] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [16:21:46] root INFO: Calculation complete: 3 steps.
ℹ️ [16:21:46] root INFO: Calculating the number of waterfall steps.
ℹ️ [16:21:46] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [16:21:46] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [16:21:46] root INFO: Calculating the number of output steps.
ℹ️ [16:21:46] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [16:21:46] root INFO: Preparing logic for channel 'email'
ℹ️ [16:21:46] root INFO: Preparing logic for channel 'sms'
ℹ️ [16:21:46] root INFO: Preparing logic for channel 'push'
ℹ️ [16:21:46] root INFO: Calculation complete: 3 steps (files).
ℹ️ [16:21:46] root INFO: Using cached SQL statements.
ℹ️ [16:21:46] root INFO: Dropping existing table eligibility_poc
ℹ️ [16:21:46] root INFO: Executing SQL statement
ℹ️ [16:21:47] root INFO: SQL execution finished in 1.36s
ℹ️ [16:21:47] root INFO: Executing eligibility SQL statement
ℹ️ [16:21:47] root INFO: Executing SQL statement
ℹ️ [16:21:48] root INFO: SQL execution finished in 0.55s
ℹ️ [16:21:48] root INFO: Executing eligibility SQL statement
ℹ️ [16:21:48] root INFO: Executing SQL statement
ℹ️ [16:21:48] root INFO: SQL execution finished in 0.16s
ℹ️ [16:21:48] root INFO: Using cached waterfall steps.
ℹ️ [16:21:48] root INFO: Fetching data to DataFrame
ℹ️ [16:21:49] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.53s
ℹ️ [16:21:49] root INFO: Fetching data to DataFrame
ℹ️ [16:21:49] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [16:21:49] root INFO: Fetching data to DataFrame
ℹ️ [16:21:50] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.92s
ℹ️ [16:21:50] root INFO: Fetching data to DataFrame
ℹ️ [16:21:50] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.35s
ℹ️ [16:21:50] root INFO: Fetching data to DataFrame
ℹ️ [16:21:51] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.91s
ℹ️ [16:21:51] root INFO: Fetching data to DataFrame
ℹ️ [16:21:52] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.91s
ℹ️ [16:21:52] root INFO: Fetching data to DataFrame
ℹ️ [16:21:53] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.43s
ℹ️ [16:21:53] root INFO: Fetching data to DataFrame
ℹ️ [16:21:53] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [16:21:53] root INFO: Fetching data to DataFrame
ℹ️ [16:21:54] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.97s
ℹ️ [16:21:54] root INFO: Fetching data to DataFrame
ℹ️ [16:21:54] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [16:21:54] root INFO: Fetching data to DataFrame
ℹ️ [16:21:55] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.87s
ℹ️ [16:21:55] root INFO: Fetching data to DataFrame
ℹ️ [16:21:56] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.92s
ℹ️ [16:21:56] root INFO: Fetching data to DataFrame
ℹ️ [16:21:56] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.47s
ℹ️ [16:21:56] root INFO: Fetching data to DataFrame
ℹ️ [16:21:57] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [16:21:57] root INFO: Fetching data to DataFrame
ℹ️ [16:21:58] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.33s
ℹ️ [16:21:58] root INFO: Fetching data to DataFrame
ℹ️ [16:21:59] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.51s
ℹ️ [16:21:59] root INFO: Fetching data to DataFrame
ℹ️ [16:21:59] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.91s
ℹ️ [16:21:59] root INFO: Fetching data to DataFrame
ℹ️ [16:22:00] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.97s
ℹ️ [16:22:01] root INFO: Consolidated waterfall report written to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/XX001_2025_07_28_16:22:01.xlsx
ℹ️ [16:22:01] root INFO: Waterfall run history appended to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_history.sqlite
ℹ️ [16:22:01] root INFO: Using cached output steps.
ℹ️ [16:22:01] root INFO: Running output job for channel email
ℹ️ [16:22:01] root INFO: Fetching data to DataFrame
ℹ️ [16:22:01] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.15s
ℹ️ [16:22:01] root INFO: Fetched 17 rows for channel email
ℹ️ [16:22:01] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [16:22:01] root INFO: Running output job for channel sms
ℹ️ [16:22:01] root INFO: Fetching data to DataFrame
ℹ️ [16:22:01] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.15s
ℹ️ [16:22:01] root INFO: Fetched 8 rows for channel sms
ℹ️ [16:22:01] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [16:22:01] root INFO: Running output job for channel push
ℹ️ [16:22:01] root INFO: Fetching data to DataFrame
ℹ️ [16:22:01] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.15s
ℹ️ [16:22:01] root INFO: Fetched 17 rows for channel push
ℹ️ [16:22:01] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [16:22:01] root INFO: Cleaning up DB connection
