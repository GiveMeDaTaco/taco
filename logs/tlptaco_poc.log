ℹ️ [19:42:56] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [19:42:56] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [19:42:56] root INFO: Calculation complete: 3 steps.
ℹ️ [19:42:56] root INFO: Calculating the number of waterfall steps.
ℹ️ [19:42:56] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [19:42:56] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [19:42:56] root INFO: Calculating the number of output steps.
ℹ️ [19:42:56] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [19:42:56] root INFO: Preparing logic for channel 'email'
ℹ️ [19:42:56] root INFO: Preparing logic for channel 'sms'
ℹ️ [19:42:56] root INFO: Preparing logic for channel 'push'
ℹ️ [19:42:56] root INFO: Calculation complete: 3 steps (files).
ℹ️ [19:42:56] root INFO: Using cached SQL statements.
ℹ️ [19:42:56] root INFO: Dropping existing table eligibility_poc
ℹ️ [19:42:56] root INFO: Executing SQL statement
ℹ️ [19:42:58] root INFO: SQL execution finished in 1.23s
ℹ️ [19:42:58] root INFO: Executing eligibility SQL statement
ℹ️ [19:42:58] root INFO: Executing SQL statement
ℹ️ [19:42:58] root INFO: SQL execution finished in 0.49s
ℹ️ [19:42:58] root INFO: Executing eligibility SQL statement
ℹ️ [19:42:58] root INFO: Executing SQL statement
ℹ️ [19:42:58] root INFO: SQL execution finished in 0.20s
ℹ️ [19:42:58] root INFO: Using cached waterfall steps.
ℹ️ [19:42:58] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [19:42:58] root INFO: Fetching data to DataFrame
ℹ️ [19:42:59] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.17s
❌ [19:42:59] root ERROR: Waterfall grouping 'customer_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [19:42:59] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [19:42:59] root INFO: Fetching data to DataFrame
ℹ️ [19:42:59] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.10s
❌ [19:42:59] root ERROR: Waterfall grouping 'customer_id_account_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [19:42:59] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [19:42:59] root INFO: Fetching data to DataFrame
ℹ️ [19:42:59] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.10s
❌ [19:42:59] root ERROR: Waterfall grouping 'region_id_segment_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [19:42:59] root INFO: Using cached output steps.
ℹ️ [19:42:59] root INFO: Running output job for channel email
ℹ️ [19:42:59] root INFO: Fetching data to DataFrame
ℹ️ [19:42:59] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.17s
ℹ️ [19:42:59] root INFO: Fetched 17 rows for channel email
ℹ️ [19:42:59] root INFO: Writing output file for channel email to reports/poc/email/email_list.csv
ℹ️ [19:42:59] root INFO: Running output job for channel sms
ℹ️ [19:42:59] root INFO: Fetching data to DataFrame
ℹ️ [19:42:59] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.17s
ℹ️ [19:42:59] root INFO: Fetched 8 rows for channel sms
ℹ️ [19:42:59] root INFO: Writing output file for channel sms to reports/poc/sms/sms_list.parquet
ℹ️ [19:42:59] root INFO: Running output job for channel push
ℹ️ [19:42:59] root INFO: Fetching data to DataFrame
ℹ️ [19:42:59] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.15s
ℹ️ [19:42:59] root INFO: Fetched 17 rows for channel push
ℹ️ [19:42:59] root INFO: Writing output file for channel push to reports/poc/push/push_list.xlsx
ℹ️ [19:42:59] root INFO: Cleaning up DB connection
ℹ️ [20:00:56] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [20:00:56] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [20:00:56] root INFO: Calculation complete: 3 steps.
ℹ️ [20:00:56] root INFO: Calculating the number of waterfall steps.
ℹ️ [20:00:56] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [20:00:56] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [20:00:56] root INFO: Calculating the number of output steps.
ℹ️ [20:00:56] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [20:00:56] root INFO: Preparing logic for channel 'email'
ℹ️ [20:00:56] root INFO: Preparing logic for channel 'sms'
ℹ️ [20:00:56] root INFO: Preparing logic for channel 'push'
ℹ️ [20:00:56] root INFO: Calculation complete: 3 steps (files).
ℹ️ [20:00:56] root INFO: Using cached SQL statements.
ℹ️ [20:00:56] root INFO: Dropping existing table eligibility_poc
ℹ️ [20:00:56] root INFO: Executing SQL statement
ℹ️ [20:00:57] root INFO: SQL execution finished in 1.31s
ℹ️ [20:00:57] root INFO: Executing eligibility SQL statement
ℹ️ [20:00:57] root INFO: Executing SQL statement
ℹ️ [20:00:58] root INFO: SQL execution finished in 0.52s
ℹ️ [20:00:58] root INFO: Executing eligibility SQL statement
ℹ️ [20:00:58] root INFO: Executing SQL statement
ℹ️ [20:00:58] root INFO: SQL execution finished in 0.19s
ℹ️ [20:00:58] root INFO: Using cached waterfall steps.
ℹ️ [20:00:58] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [20:00:58] root INFO: Fetching data to DataFrame
ℹ️ [20:00:58] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.20s
❌ [20:00:58] root ERROR: Waterfall grouping 'customer_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [20:00:58] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [20:00:58] root INFO: Fetching data to DataFrame
ℹ️ [20:00:58] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.11s
❌ [20:00:58] root ERROR: Waterfall grouping 'customer_id_account_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [20:00:58] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [20:00:58] root INFO: Fetching data to DataFrame
ℹ️ [20:00:59] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.11s
❌ [20:00:59] root ERROR: Waterfall grouping 'region_id_segment_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [20:00:59] root INFO: Using cached output steps.
ℹ️ [20:00:59] root INFO: Running output job for channel email
ℹ️ [20:00:59] root INFO: Fetching data to DataFrame
ℹ️ [20:00:59] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [20:00:59] root INFO: Fetched 17 rows for channel email
ℹ️ [20:00:59] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [20:00:59] root INFO: Running output job for channel sms
ℹ️ [20:00:59] root INFO: Fetching data to DataFrame
ℹ️ [20:00:59] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.20s
ℹ️ [20:00:59] root INFO: Fetched 8 rows for channel sms
ℹ️ [20:00:59] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [20:00:59] root INFO: Running output job for channel push
ℹ️ [20:00:59] root INFO: Fetching data to DataFrame
ℹ️ [20:00:59] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [20:00:59] root INFO: Fetched 17 rows for channel push
ℹ️ [20:00:59] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [20:00:59] root INFO: Cleaning up DB connection
ℹ️ [20:04:07] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [20:04:07] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [20:04:07] root INFO: Calculation complete: 3 steps.
ℹ️ [20:04:07] root INFO: Calculating the number of waterfall steps.
ℹ️ [20:04:07] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [20:04:07] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [20:04:07] root INFO: Calculating the number of output steps.
ℹ️ [20:04:07] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [20:04:07] root INFO: Preparing logic for channel 'email'
ℹ️ [20:04:07] root INFO: Preparing logic for channel 'sms'
ℹ️ [20:04:07] root INFO: Preparing logic for channel 'push'
ℹ️ [20:04:07] root INFO: Calculation complete: 3 steps (files).
ℹ️ [20:04:07] root INFO: Using cached SQL statements.
ℹ️ [20:04:07] root INFO: Dropping existing table eligibility_poc
ℹ️ [20:04:07] root INFO: Executing SQL statement
ℹ️ [20:04:08] root INFO: SQL execution finished in 1.41s
ℹ️ [20:04:08] root INFO: Executing eligibility SQL statement
ℹ️ [20:04:08] root INFO: Executing SQL statement
ℹ️ [20:04:09] root INFO: SQL execution finished in 0.52s
ℹ️ [20:04:09] root INFO: Executing eligibility SQL statement
ℹ️ [20:04:09] root INFO: Executing SQL statement
ℹ️ [20:04:09] root INFO: SQL execution finished in 0.19s
ℹ️ [20:04:09] root INFO: Using cached waterfall steps.
ℹ️ [20:04:09] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [20:04:09] root INFO: Fetching data to DataFrame
ℹ️ [20:04:09] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.24s
❌ [20:04:09] root ERROR: Waterfall grouping 'customer_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [20:04:09] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [20:04:09] root INFO: Fetching data to DataFrame
ℹ️ [20:04:09] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.09s
❌ [20:04:09] root ERROR: Waterfall grouping 'customer_id_account_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [20:04:09] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [20:04:09] root INFO: Fetching data to DataFrame
ℹ️ [20:04:09] root INFO: Fetched DataFrame with 0 rows and 0 columns in 0.11s
❌ [20:04:09] root ERROR: Waterfall grouping 'region_id_segment_id' failed: 'stat_name'
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3812, in get_loc
    return self._engine.get_loc(casted_key)
  File "pandas/_libs/index.pyx", line 167, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/index.pyx", line 196, in pandas._libs.index.IndexEngine.get_loc
  File "pandas/_libs/hashtable_class_helper.pxi", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item
  File "pandas/_libs/hashtable_class_helper.pxi", line 7096, in pandas._libs.hashtable.PyObjectHashTable.get_item
KeyError: 'stat_name'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 149, in run
    df_pivoted = self._pivot_waterfall_df(df_raw, job['section_name'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 118, in _pivot_waterfall_df
    metric_df = df[df['stat_name'] != 'Records Claimed']
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/frame.py", line 4107, in __getitem__
    indexer = self.columns.get_loc(key)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/core/indexes/base.py", line 3819, in get_loc
    raise KeyError(key) from err
KeyError: 'stat_name'
ℹ️ [20:04:09] root INFO: Using cached output steps.
ℹ️ [20:04:09] root INFO: Running output job for channel email
ℹ️ [20:04:09] root INFO: Fetching data to DataFrame
ℹ️ [20:04:10] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [20:04:10] root INFO: Fetched 17 rows for channel email
ℹ️ [20:04:10] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [20:04:10] root INFO: Running output job for channel sms
ℹ️ [20:04:10] root INFO: Fetching data to DataFrame
ℹ️ [20:04:10] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [20:04:10] root INFO: Fetched 8 rows for channel sms
ℹ️ [20:04:10] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [20:04:10] root INFO: Running output job for channel push
ℹ️ [20:04:10] root INFO: Fetching data to DataFrame
ℹ️ [20:04:10] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [20:04:10] root INFO: Fetched 17 rows for channel push
ℹ️ [20:04:10] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [20:04:10] root INFO: Cleaning up DB connection
ℹ️ [20:25:52] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [20:25:52] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [20:25:52] root INFO: Calculation complete: 3 steps.
ℹ️ [20:25:52] root INFO: Calculating the number of waterfall steps.
ℹ️ [20:25:52] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [20:25:52] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [20:25:52] root INFO: Calculating the number of output steps.
ℹ️ [20:25:52] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [20:25:52] root INFO: Preparing logic for channel 'email'
ℹ️ [20:25:52] root INFO: Preparing logic for channel 'sms'
ℹ️ [20:25:52] root INFO: Preparing logic for channel 'push'
ℹ️ [20:25:52] root INFO: Calculation complete: 3 steps (files).
ℹ️ [20:25:52] root INFO: Using cached SQL statements.
ℹ️ [20:25:52] root INFO: Dropping existing table eligibility_poc
ℹ️ [20:25:52] root INFO: Executing SQL statement
ℹ️ [20:25:53] root INFO: SQL execution finished in 1.34s
ℹ️ [20:25:53] root INFO: Executing eligibility SQL statement
ℹ️ [20:25:53] root INFO: Executing SQL statement
ℹ️ [20:25:54] root INFO: SQL execution finished in 0.53s
ℹ️ [20:25:54] root INFO: Executing eligibility SQL statement
ℹ️ [20:25:54] root INFO: Executing SQL statement
ℹ️ [20:25:54] root INFO: SQL execution finished in 0.19s
ℹ️ [20:25:54] root INFO: Using cached waterfall steps.
ℹ️ [20:25:54] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [20:25:54] root INFO: Fetching data to DataFrame
❌ [20:25:54] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS value
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS value
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:25:55] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [20:25:55] root INFO: Fetching data to DataFrame
❌ [20:25:55] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,account_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS value
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,account_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS value
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:25:55] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [20:25:55] root INFO: Fetching data to DataFrame
❌ [20:25:55] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    region_id,segment_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS value
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    region_id,segment_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS value
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      value
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS value
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1121] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:25:55] root INFO: Using cached output steps.
ℹ️ [20:25:55] root INFO: Running output job for channel email
ℹ️ [20:25:55] root INFO: Fetching data to DataFrame
ℹ️ [20:25:56] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [20:25:56] root INFO: Fetched 17 rows for channel email
ℹ️ [20:25:56] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [20:25:56] root INFO: Running output job for channel sms
ℹ️ [20:25:56] root INFO: Fetching data to DataFrame
ℹ️ [20:25:56] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [20:25:56] root INFO: Fetched 8 rows for channel sms
ℹ️ [20:25:56] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [20:25:56] root INFO: Running output job for channel push
ℹ️ [20:25:56] root INFO: Fetching data to DataFrame
ℹ️ [20:25:56] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [20:25:56] root INFO: Fetched 17 rows for channel push
ℹ️ [20:25:56] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [20:25:56] root INFO: Cleaning up DB connection
ℹ️ [20:27:13] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [20:27:13] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [20:27:13] root INFO: Calculation complete: 3 steps.
ℹ️ [20:27:13] root INFO: Calculating the number of waterfall steps.
ℹ️ [20:27:13] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [20:27:13] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [20:27:13] root INFO: Calculating the number of output steps.
ℹ️ [20:27:13] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [20:27:13] root INFO: Preparing logic for channel 'email'
ℹ️ [20:27:13] root INFO: Preparing logic for channel 'sms'
ℹ️ [20:27:13] root INFO: Preparing logic for channel 'push'
ℹ️ [20:27:13] root INFO: Calculation complete: 3 steps (files).
ℹ️ [20:27:13] root INFO: Using cached SQL statements.
ℹ️ [20:27:13] root INFO: Dropping existing table eligibility_poc
ℹ️ [20:27:13] root INFO: Executing SQL statement
ℹ️ [20:27:14] root INFO: SQL execution finished in 1.18s
ℹ️ [20:27:14] root INFO: Executing eligibility SQL statement
ℹ️ [20:27:14] root INFO: Executing SQL statement
ℹ️ [20:27:14] root INFO: SQL execution finished in 0.50s
ℹ️ [20:27:14] root INFO: Executing eligibility SQL statement
ℹ️ [20:27:14] root INFO: Executing SQL statement
ℹ️ [20:27:15] root INFO: SQL execution finished in 0.19s
ℹ️ [20:27:15] root INFO: Using cached waterfall steps.
ℹ️ [20:27:15] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [20:27:15] root INFO: Fetching data to DataFrame
❌ [20:27:15] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:27:15] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [20:27:15] root INFO: Fetching data to DataFrame
❌ [20:27:15] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,account_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    customer_id,account_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:27:15] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [20:27:15] root INFO: Fetching data to DataFrame
❌ [20:27:16] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    region_id,segment_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_full.sql.j2
-- Purpose: Creates a standard, multi-step waterfall report for a given set of checks.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   check_columns:          A list of the individual check column names to be evaluated in order.
--   pre_filter:             An optional, pre-existing WHERE clause to apply to the base population.
--
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    
),
flags AS (
  SELECT
    region_id,segment_id,
    main_active_1,main_has_account_2
  FROM base_population
)
SELECT
  stat_name,
  check_name,
  value
FROM (
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population
    UNION ALL
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 0 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'main_active_1' as check_name, COUNT(*) - SUM(CASE WHEN main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_has_account_2' as check_name, COUNT(*) - SUM(CASE WHEN main_has_account_2 = 1 AND main_active_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1122] [Teradata Database] [Error 3706] Syntax error: expected something between ',' and the 'value' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:27:16] root INFO: Using cached output steps.
ℹ️ [20:27:16] root INFO: Running output job for channel email
ℹ️ [20:27:16] root INFO: Fetching data to DataFrame
ℹ️ [20:27:16] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [20:27:16] root INFO: Fetched 17 rows for channel email
ℹ️ [20:27:16] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [20:27:16] root INFO: Running output job for channel sms
ℹ️ [20:27:16] root INFO: Fetching data to DataFrame
ℹ️ [20:27:16] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [20:27:16] root INFO: Fetched 8 rows for channel sms
ℹ️ [20:27:16] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [20:27:16] root INFO: Running output job for channel push
ℹ️ [20:27:16] root INFO: Fetching data to DataFrame
ℹ️ [20:27:16] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [20:27:16] root INFO: Fetched 17 rows for channel push
ℹ️ [20:27:16] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [20:27:16] root INFO: Cleaning up DB connection
ℹ️ [20:28:58] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [20:28:58] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [20:28:58] root INFO: Calculation complete: 3 steps.
ℹ️ [20:28:58] root INFO: Calculating the number of waterfall steps.
ℹ️ [20:28:58] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [20:28:58] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [20:28:58] root INFO: Calculating the number of output steps.
ℹ️ [20:28:58] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [20:28:58] root INFO: Preparing logic for channel 'email'
ℹ️ [20:28:58] root INFO: Preparing logic for channel 'sms'
ℹ️ [20:28:58] root INFO: Preparing logic for channel 'push'
ℹ️ [20:28:58] root INFO: Calculation complete: 3 steps (files).
ℹ️ [20:28:58] root INFO: Using cached SQL statements.
ℹ️ [20:28:58] root INFO: Dropping existing table eligibility_poc
ℹ️ [20:28:58] root INFO: Executing SQL statement
ℹ️ [20:28:59] root INFO: SQL execution finished in 1.33s
ℹ️ [20:28:59] root INFO: Executing eligibility SQL statement
ℹ️ [20:28:59] root INFO: Executing SQL statement
ℹ️ [20:29:00] root INFO: SQL execution finished in 0.58s
ℹ️ [20:29:00] root INFO: Executing eligibility SQL statement
ℹ️ [20:29:00] root INFO: Executing SQL statement
ℹ️ [20:29:00] root INFO: SQL execution finished in 0.19s
ℹ️ [20:29:00] root INFO: Using cached waterfall steps.
ℹ️ [20:29:00] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [20:29:00] root INFO: Fetching data to DataFrame
ℹ️ [20:29:00] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.52s
ℹ️ [20:29:00] root INFO: Fetching data to DataFrame
ℹ️ [20:29:01] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.25s
ℹ️ [20:29:01] root INFO: Fetching data to DataFrame
❌ [20:29:01] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_13 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_13
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo1_6 = 1 OR c.email_promo2_7 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  
    AND NOT (c.email_loyalty_13 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
      AND 
          NOT (c.email_loyalty_13 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo1_6,email_promo2_7
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, COUNT(*) - SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, COUNT(*) - SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_13 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_13
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo1_6 = 1 OR c.email_promo2_7 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  
    AND NOT (c.email_loyalty_13 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
      AND 
          NOT (c.email_loyalty_13 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo1_6,email_promo2_7
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, COUNT(*) - SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, COUNT(*) - SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:29:01] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [20:29:01] root INFO: Fetching data to DataFrame
ℹ️ [20:29:01] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.37s
ℹ️ [20:29:01] root INFO: Fetching data to DataFrame
ℹ️ [20:29:02] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.27s
ℹ️ [20:29:02] root INFO: Fetching data to DataFrame
❌ [20:29:02] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_13 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_13
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo1_6 = 1 OR c.email_promo2_7 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  
    AND NOT (c.email_loyalty_13 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
      AND 
          NOT (c.email_loyalty_13 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo1_6,email_promo2_7
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, COUNT(*) - SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, COUNT(*) - SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_13 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_13
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo1_6 = 1 OR c.email_promo2_7 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  
    AND NOT (c.email_loyalty_13 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
      AND 
          NOT (c.email_loyalty_13 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo1_6,email_promo2_7
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, COUNT(*) - SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, COUNT(*) - SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:29:02] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [20:29:02] root INFO: Fetching data to DataFrame
ℹ️ [20:29:03] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.41s
ℹ️ [20:29:03] root INFO: Fetching data to DataFrame
ℹ️ [20:29:03] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.33s
ℹ️ [20:29:03] root INFO: Fetching data to DataFrame
❌ [20:29:03] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_13 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_13
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo1_6 = 1 OR c.email_promo2_7 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  
    AND NOT (c.email_loyalty_13 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
      AND 
          NOT (c.email_loyalty_13 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo1_6,email_promo2_7
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, COUNT(*) - SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, COUNT(*) - SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_13 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_13
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_13' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_13 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo1_6 = 1 OR c.email_promo2_7 = 1)
  AND (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
  
    AND NOT (c.email_loyalty_13 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_active_1 = 1 AND c.main_has_account_2 = 1) AND (c.email_optin_5 = 1)
    
      AND 
          NOT (c.email_loyalty_13 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo1_6,email_promo2_7
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 0 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo1_6' as check_name, COUNT(*) - SUM(CASE WHEN email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo2_7' as check_name, COUNT(*) - SUM(CASE WHEN email_promo2_7 = 1 AND email_promo1_6 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1124] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [20:29:03] root INFO: Using cached output steps.
ℹ️ [20:29:03] root INFO: Running output job for channel email
ℹ️ [20:29:03] root INFO: Fetching data to DataFrame
ℹ️ [20:29:04] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [20:29:04] root INFO: Fetched 17 rows for channel email
ℹ️ [20:29:04] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [20:29:04] root INFO: Running output job for channel sms
ℹ️ [20:29:04] root INFO: Fetching data to DataFrame
ℹ️ [20:29:04] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.22s
ℹ️ [20:29:04] root INFO: Fetched 8 rows for channel sms
ℹ️ [20:29:04] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [20:29:04] root INFO: Running output job for channel push
ℹ️ [20:29:04] root INFO: Fetching data to DataFrame
ℹ️ [20:29:04] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [20:29:04] root INFO: Fetched 17 rows for channel push
ℹ️ [20:29:04] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [20:29:04] root INFO: Cleaning up DB connection
ℹ️ [22:15:00] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [22:15:00] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [22:15:00] root INFO: Calculation complete: 3 steps.
ℹ️ [22:15:00] root INFO: Calculating the number of waterfall steps.
ℹ️ [22:15:00] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [22:15:00] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [22:15:00] root INFO: Calculating the number of output steps.
ℹ️ [22:15:00] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [22:15:00] root INFO: Preparing logic for channel 'email'
ℹ️ [22:15:00] root INFO: Preparing logic for channel 'sms'
ℹ️ [22:15:00] root INFO: Preparing logic for channel 'push'
ℹ️ [22:15:00] root INFO: Calculation complete: 3 steps (files).
ℹ️ [22:15:00] root INFO: Using cached SQL statements.
ℹ️ [22:15:00] root INFO: Dropping existing table eligibility_poc
ℹ️ [22:15:00] root INFO: Executing SQL statement
ℹ️ [22:15:01] root INFO: SQL execution finished in 1.48s
ℹ️ [22:15:01] root INFO: Executing eligibility SQL statement
ℹ️ [22:15:01] root INFO: Executing SQL statement
ℹ️ [22:15:02] root INFO: SQL execution finished in 0.56s
ℹ️ [22:15:02] root INFO: Executing eligibility SQL statement
ℹ️ [22:15:02] root INFO: Executing SQL statement
ℹ️ [22:15:02] root INFO: SQL execution finished in 0.19s
ℹ️ [22:15:02] root INFO: Using cached waterfall steps.
ℹ️ [22:15:02] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [22:15:02] root INFO: Fetching data to DataFrame
ℹ️ [22:15:03] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.47s
ℹ️ [22:15:03] root INFO: Fetching data to DataFrame
ℹ️ [22:15:03] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.27s
ℹ️ [22:15:03] root INFO: Fetching data to DataFrame
❌ [22:15:03] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:15:03] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [22:15:03] root INFO: Fetching data to DataFrame
ℹ️ [22:15:04] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [22:15:04] root INFO: Fetching data to DataFrame
ℹ️ [22:15:04] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.31s
ℹ️ [22:15:04] root INFO: Fetching data to DataFrame
❌ [22:15:04] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:15:04] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [22:15:04] root INFO: Fetching data to DataFrame
ℹ️ [22:15:05] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.37s
ℹ️ [22:15:05] root INFO: Fetching data to DataFrame
ℹ️ [22:15:05] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.25s
ℹ️ [22:15:05] root INFO: Fetching data to DataFrame
❌ [22:15:05] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1148] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:15:06] root INFO: Using cached output steps.
ℹ️ [22:15:06] root INFO: Running output job for channel email
ℹ️ [22:15:06] root INFO: Fetching data to DataFrame
ℹ️ [22:15:06] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [22:15:06] root INFO: Fetched 17 rows for channel email
ℹ️ [22:15:06] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [22:15:06] root INFO: Running output job for channel sms
ℹ️ [22:15:06] root INFO: Fetching data to DataFrame
ℹ️ [22:15:06] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [22:15:06] root INFO: Fetched 8 rows for channel sms
ℹ️ [22:15:06] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [22:15:06] root INFO: Running output job for channel push
ℹ️ [22:15:06] root INFO: Fetching data to DataFrame
ℹ️ [22:15:06] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [22:15:06] root INFO: Fetched 17 rows for channel push
ℹ️ [22:15:06] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [22:15:06] root INFO: Cleaning up DB connection
ℹ️ [22:36:17] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [22:36:17] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [22:36:18] root INFO: Calculation complete: 3 steps.
ℹ️ [22:36:18] root INFO: Calculating the number of waterfall steps.
ℹ️ [22:36:18] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [22:36:18] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [22:36:18] root INFO: Calculating the number of output steps.
ℹ️ [22:36:18] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [22:36:18] root INFO: Preparing logic for channel 'email'
ℹ️ [22:36:18] root INFO: Preparing logic for channel 'sms'
ℹ️ [22:36:18] root INFO: Preparing logic for channel 'push'
ℹ️ [22:36:18] root INFO: Calculation complete: 3 steps (files).
ℹ️ [22:36:18] root INFO: Using cached SQL statements.
ℹ️ [22:36:18] root INFO: Dropping existing table eligibility_poc
ℹ️ [22:36:18] root INFO: Executing SQL statement
ℹ️ [22:36:19] root INFO: SQL execution finished in 1.41s
ℹ️ [22:36:19] root INFO: Executing eligibility SQL statement
ℹ️ [22:36:19] root INFO: Executing SQL statement
ℹ️ [22:36:20] root INFO: SQL execution finished in 0.53s
ℹ️ [22:36:20] root INFO: Executing eligibility SQL statement
ℹ️ [22:36:20] root INFO: Executing SQL statement
ℹ️ [22:36:20] root INFO: SQL execution finished in 0.18s
ℹ️ [22:36:20] root INFO: Using cached waterfall steps.
ℹ️ [22:36:20] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [22:36:20] root INFO: Fetching data to DataFrame
ℹ️ [22:36:20] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.47s
ℹ️ [22:36:20] root INFO: Fetching data to DataFrame
ℹ️ [22:36:20] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.23s
ℹ️ [22:36:20] root INFO: Fetching data to DataFrame
❌ [22:36:21] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1153] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1153] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1153] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:36:21] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [22:36:21] root INFO: Fetching data to DataFrame
ℹ️ [22:36:21] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [22:36:21] root INFO: Fetching data to DataFrame
ℹ️ [22:36:21] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.25s
ℹ️ [22:36:21] root INFO: Fetching data to DataFrame
❌ [22:36:22] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1153] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1153] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1153] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:36:22] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [22:36:22] root INFO: Fetching data to DataFrame
ℹ️ [22:45:27] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [22:45:27] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [22:45:27] root INFO: Calculation complete: 3 steps.
ℹ️ [22:45:27] root INFO: Calculating the number of waterfall steps.
ℹ️ [22:45:27] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [22:45:27] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [22:45:27] root INFO: Calculating the number of output steps.
ℹ️ [22:45:27] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [22:45:27] root INFO: Preparing logic for channel 'email'
ℹ️ [22:45:27] root INFO: Preparing logic for channel 'sms'
ℹ️ [22:45:27] root INFO: Preparing logic for channel 'push'
ℹ️ [22:45:27] root INFO: Calculation complete: 3 steps (files).
ℹ️ [22:45:27] root INFO: Using cached SQL statements.
ℹ️ [22:45:27] root INFO: Dropping existing table eligibility_poc
ℹ️ [22:45:27] root INFO: Executing SQL statement
ℹ️ [22:45:29] root INFO: SQL execution finished in 1.51s
ℹ️ [22:45:29] root INFO: Executing eligibility SQL statement
ℹ️ [22:45:29] root INFO: Executing SQL statement
ℹ️ [22:45:31] root INFO: SQL execution finished in 1.70s
ℹ️ [22:45:31] root INFO: Executing eligibility SQL statement
ℹ️ [22:45:31] root INFO: Executing SQL statement
ℹ️ [22:45:31] root INFO: SQL execution finished in 0.20s
ℹ️ [22:45:31] root INFO: Using cached waterfall steps.
ℹ️ [22:45:31] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [22:45:31] root INFO: Fetching data to DataFrame
ℹ️ [22:45:31] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.44s
ℹ️ [22:45:31] root INFO: Fetching data to DataFrame
ℹ️ [22:45:32] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [22:45:32] root INFO: Fetching data to DataFrame
❌ [22:45:32] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:45:32] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [22:45:32] root INFO: Fetching data to DataFrame
ℹ️ [22:45:32] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [22:45:32] root INFO: Fetching data to DataFrame
ℹ️ [22:45:32] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [22:45:32] root INFO: Fetching data to DataFrame
❌ [22:45:33] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:45:33] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [22:45:33] root INFO: Fetching data to DataFrame
ℹ️ [22:45:33] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [22:45:33] root INFO: Fetching data to DataFrame
ℹ️ [22:45:33] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [22:45:33] root INFO: Fetching data to DataFrame
❌ [22:45:33] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 56, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1156] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:45:33] root INFO: Using cached output steps.
ℹ️ [22:45:33] root INFO: Running output job for channel email
ℹ️ [22:45:33] root INFO: Fetching data to DataFrame
ℹ️ [22:45:34] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [22:45:34] root INFO: Fetched 17 rows for channel email
ℹ️ [22:45:34] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [22:45:34] root INFO: Running output job for channel sms
ℹ️ [22:45:34] root INFO: Fetching data to DataFrame
ℹ️ [22:45:34] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [22:45:34] root INFO: Fetched 8 rows for channel sms
ℹ️ [22:45:34] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [22:45:34] root INFO: Running output job for channel push
ℹ️ [22:45:34] root INFO: Fetching data to DataFrame
ℹ️ [22:45:34] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [22:45:34] root INFO: Fetched 17 rows for channel push
ℹ️ [22:45:34] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [22:45:34] root INFO: Cleaning up DB connection
ℹ️ [22:57:41] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [22:57:41] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [22:57:41] root INFO: Calculation complete: 3 steps.
ℹ️ [22:57:41] root INFO: Calculating the number of waterfall steps.
ℹ️ [22:57:41] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [22:57:42] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [22:57:42] root INFO: Calculating the number of output steps.
ℹ️ [22:57:42] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [22:57:42] root INFO: Preparing logic for channel 'email'
ℹ️ [22:57:42] root INFO: Preparing logic for channel 'sms'
ℹ️ [22:57:42] root INFO: Preparing logic for channel 'push'
ℹ️ [22:57:42] root INFO: Calculation complete: 3 steps (files).
ℹ️ [22:57:42] root INFO: Using cached SQL statements.
ℹ️ [22:57:42] root INFO: Dropping existing table eligibility_poc
ℹ️ [22:57:42] root INFO: Executing SQL statement
ℹ️ [22:57:43] root INFO: SQL execution finished in 1.63s
ℹ️ [22:57:43] root INFO: Executing eligibility SQL statement
ℹ️ [22:57:43] root INFO: Executing SQL statement
ℹ️ [22:57:44] root INFO: SQL execution finished in 0.57s
ℹ️ [22:57:44] root INFO: Executing eligibility SQL statement
ℹ️ [22:57:44] root INFO: Executing SQL statement
ℹ️ [22:57:44] root INFO: SQL execution finished in 0.20s
ℹ️ [22:57:44] root INFO: Using cached waterfall steps.
ℹ️ [22:57:44] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [22:57:44] root INFO: Fetching data to DataFrame
ℹ️ [22:57:44] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.42s
ℹ️ [22:57:44] root INFO: Fetching data to DataFrame
ℹ️ [22:57:45] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.24s
ℹ️ [22:57:45] root INFO: Fetching data to DataFrame
❌ [22:57:45] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:57:45] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [22:57:45] root INFO: Fetching data to DataFrame
ℹ️ [22:57:45] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.32s
ℹ️ [22:57:45] root INFO: Fetching data to DataFrame
ℹ️ [22:57:45] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.24s
ℹ️ [22:57:45] root INFO: Fetching data to DataFrame
❌ [22:57:46] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:57:46] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [22:57:46] root INFO: Fetching data to DataFrame
ℹ️ [22:57:46] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.35s
ℹ️ [22:57:46] root INFO: Fetching data to DataFrame
ℹ️ [22:57:46] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [22:57:46] root INFO: Fetching data to DataFrame
❌ [22:57:47] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1159] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [22:57:47] root INFO: Using cached output steps.
ℹ️ [22:57:47] root INFO: Running output job for channel email
ℹ️ [22:57:47] root INFO: Fetching data to DataFrame
ℹ️ [22:57:47] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [22:57:47] root INFO: Fetched 17 rows for channel email
ℹ️ [22:57:47] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [22:57:47] root INFO: Running output job for channel sms
ℹ️ [22:57:47] root INFO: Fetching data to DataFrame
ℹ️ [22:57:47] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [22:57:47] root INFO: Fetched 8 rows for channel sms
ℹ️ [22:57:47] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [22:57:47] root INFO: Running output job for channel push
ℹ️ [22:57:47] root INFO: Fetching data to DataFrame
ℹ️ [22:57:47] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [22:57:47] root INFO: Fetched 17 rows for channel push
ℹ️ [22:57:47] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [22:57:47] root INFO: Cleaning up DB connection
ℹ️ [23:15:44] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:15:44] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:15:44] root INFO: Calculation complete: 3 steps.
ℹ️ [23:15:44] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:15:44] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:15:44] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:15:44] root INFO: Calculating the number of output steps.
ℹ️ [23:15:44] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:15:44] root INFO: Preparing logic for channel 'email'
ℹ️ [23:15:44] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:15:44] root INFO: Preparing logic for channel 'push'
ℹ️ [23:15:44] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:15:44] root INFO: Using cached SQL statements.
ℹ️ [23:15:44] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:15:44] root INFO: Executing SQL statement
ℹ️ [23:15:46] root INFO: SQL execution finished in 1.52s
ℹ️ [23:15:46] root INFO: Executing eligibility SQL statement
ℹ️ [23:15:46] root INFO: Executing SQL statement
ℹ️ [23:15:46] root INFO: SQL execution finished in 0.69s
ℹ️ [23:15:46] root INFO: Executing eligibility SQL statement
ℹ️ [23:15:46] root INFO: Executing SQL statement
ℹ️ [23:15:47] root INFO: SQL execution finished in 0.18s
ℹ️ [23:15:47] root INFO: Using cached waterfall steps.
ℹ️ [23:15:47] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:15:47] root INFO: Fetching data to DataFrame
ℹ️ [23:15:47] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.42s
ℹ️ [23:15:47] root INFO: Fetching data to DataFrame
ℹ️ [23:15:47] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:15:47] root INFO: Fetching data to DataFrame
❌ [23:15:47] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:15:47] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:15:47] root INFO: Fetching data to DataFrame
ℹ️ [23:15:48] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [23:15:48] root INFO: Fetching data to DataFrame
ℹ️ [23:15:48] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:15:48] root INFO: Fetching data to DataFrame
❌ [23:15:48] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:15:48] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:15:48] root INFO: Fetching data to DataFrame
ℹ️ [23:15:48] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [23:15:48] root INFO: Fetching data to DataFrame
ℹ️ [23:15:49] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.24s
ℹ️ [23:15:49] root INFO: Fetching data to DataFrame
❌ [23:15:49] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1164] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:15:49] root INFO: Using cached output steps.
ℹ️ [23:15:49] root INFO: Running output job for channel email
ℹ️ [23:15:49] root INFO: Fetching data to DataFrame
ℹ️ [23:15:49] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [23:15:49] root INFO: Fetched 17 rows for channel email
ℹ️ [23:15:49] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:15:49] root INFO: Running output job for channel sms
ℹ️ [23:15:49] root INFO: Fetching data to DataFrame
ℹ️ [23:15:49] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [23:15:49] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:15:49] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:15:49] root INFO: Running output job for channel push
ℹ️ [23:15:49] root INFO: Fetching data to DataFrame
ℹ️ [23:15:49] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [23:15:49] root INFO: Fetched 17 rows for channel push
ℹ️ [23:15:49] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:15:50] root INFO: Cleaning up DB connection
ℹ️ [23:16:00] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:16:00] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:16:00] root INFO: Calculation complete: 3 steps.
ℹ️ [23:16:00] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:16:00] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:16:00] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:16:00] root INFO: Calculating the number of output steps.
ℹ️ [23:16:00] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:16:00] root INFO: Preparing logic for channel 'email'
ℹ️ [23:16:00] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:16:00] root INFO: Preparing logic for channel 'push'
ℹ️ [23:16:00] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:16:00] root INFO: Using cached SQL statements.
ℹ️ [23:16:00] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:16:00] root INFO: Executing SQL statement
ℹ️ [23:16:02] root INFO: SQL execution finished in 2.29s
ℹ️ [23:16:02] root INFO: Executing eligibility SQL statement
ℹ️ [23:16:02] root INFO: Executing SQL statement
ℹ️ [23:16:02] root INFO: SQL execution finished in 0.52s
ℹ️ [23:16:02] root INFO: Executing eligibility SQL statement
ℹ️ [23:16:02] root INFO: Executing SQL statement
ℹ️ [23:16:03] root INFO: SQL execution finished in 0.18s
ℹ️ [23:16:03] root INFO: Using cached waterfall steps.
ℹ️ [23:16:03] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:16:03] root INFO: Fetching data to DataFrame
ℹ️ [23:16:03] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.37s
ℹ️ [23:16:03] root INFO: Fetching data to DataFrame
ℹ️ [23:16:03] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:16:03] root INFO: Fetching data to DataFrame
❌ [23:16:03] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:16:03] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:16:03] root INFO: Fetching data to DataFrame
ℹ️ [23:16:04] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.34s
ℹ️ [23:16:04] root INFO: Fetching data to DataFrame
ℹ️ [23:16:04] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:16:04] root INFO: Fetching data to DataFrame
❌ [23:16:04] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:16:04] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:16:04] root INFO: Fetching data to DataFrame
ℹ️ [23:16:05] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [23:16:05] root INFO: Fetching data to DataFrame
ℹ️ [23:16:05] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.30s
ℹ️ [23:16:05] root INFO: Fetching data to DataFrame
❌ [23:16:05] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1165] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:16:05] root INFO: Using cached output steps.
ℹ️ [23:16:05] root INFO: Running output job for channel email
ℹ️ [23:16:05] root INFO: Fetching data to DataFrame
ℹ️ [23:16:05] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [23:16:05] root INFO: Fetched 17 rows for channel email
ℹ️ [23:16:05] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:16:05] root INFO: Running output job for channel sms
ℹ️ [23:16:05] root INFO: Fetching data to DataFrame
ℹ️ [23:16:05] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [23:16:05] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:16:05] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:16:05] root INFO: Running output job for channel push
ℹ️ [23:16:05] root INFO: Fetching data to DataFrame
ℹ️ [23:16:06] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [23:16:06] root INFO: Fetched 17 rows for channel push
ℹ️ [23:16:06] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:16:06] root INFO: Cleaning up DB connection
ℹ️ [23:16:28] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:16:28] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:16:28] root INFO: Calculation complete: 3 steps.
ℹ️ [23:16:28] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:16:28] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:16:28] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:16:28] root INFO: Calculating the number of output steps.
ℹ️ [23:16:28] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:16:28] root INFO: Preparing logic for channel 'email'
ℹ️ [23:16:28] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:16:28] root INFO: Preparing logic for channel 'push'
ℹ️ [23:16:28] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:16:28] root INFO: Using cached SQL statements.
ℹ️ [23:16:28] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:16:28] root INFO: Executing SQL statement
ℹ️ [23:16:29] root INFO: SQL execution finished in 1.21s
ℹ️ [23:16:29] root INFO: Executing eligibility SQL statement
ℹ️ [23:16:29] root INFO: Executing SQL statement
ℹ️ [23:16:30] root INFO: SQL execution finished in 0.44s
ℹ️ [23:16:30] root INFO: Executing eligibility SQL statement
ℹ️ [23:16:30] root INFO: Executing SQL statement
ℹ️ [23:16:30] root INFO: SQL execution finished in 0.18s
ℹ️ [23:16:30] root INFO: Using cached waterfall steps.
ℹ️ [23:16:30] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:16:30] root INFO: Fetching data to DataFrame
ℹ️ [23:16:30] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.39s
ℹ️ [23:16:30] root INFO: Fetching data to DataFrame
ℹ️ [23:16:30] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.20s
ℹ️ [23:16:30] root INFO: Fetching data to DataFrame
❌ [23:16:31] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:16:31] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:16:31] root INFO: Fetching data to DataFrame
ℹ️ [23:16:31] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.40s
ℹ️ [23:16:31] root INFO: Fetching data to DataFrame
ℹ️ [23:16:31] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.30s
ℹ️ [23:16:31] root INFO: Fetching data to DataFrame
❌ [23:16:32] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:16:32] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:16:32] root INFO: Fetching data to DataFrame
ℹ️ [23:16:32] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.50s
ℹ️ [23:16:32] root INFO: Fetching data to DataFrame
ℹ️ [23:16:32] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.32s
ℹ️ [23:16:32] root INFO: Fetching data to DataFrame
❌ [23:16:33] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1166] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:16:33] root INFO: Using cached output steps.
ℹ️ [23:16:33] root INFO: Running output job for channel email
ℹ️ [23:16:33] root INFO: Fetching data to DataFrame
ℹ️ [23:16:33] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [23:16:33] root INFO: Fetched 17 rows for channel email
ℹ️ [23:16:33] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:16:33] root INFO: Running output job for channel sms
ℹ️ [23:16:33] root INFO: Fetching data to DataFrame
ℹ️ [23:16:33] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [23:16:33] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:16:33] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:16:33] root INFO: Running output job for channel push
ℹ️ [23:16:33] root INFO: Fetching data to DataFrame
ℹ️ [23:16:34] root INFO: Fetched DataFrame with 17 rows and 5 columns in 1.21s
ℹ️ [23:16:34] root INFO: Fetched 17 rows for channel push
ℹ️ [23:16:34] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:16:34] root INFO: Cleaning up DB connection
ℹ️ [23:17:08] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:17:08] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:17:08] root INFO: Calculation complete: 3 steps.
ℹ️ [23:17:08] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:17:08] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:17:08] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:17:08] root INFO: Calculating the number of output steps.
ℹ️ [23:17:08] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:17:08] root INFO: Preparing logic for channel 'email'
ℹ️ [23:17:08] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:17:08] root INFO: Preparing logic for channel 'push'
ℹ️ [23:17:08] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:17:08] root INFO: Using cached SQL statements.
ℹ️ [23:17:08] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:17:08] root INFO: Executing SQL statement
ℹ️ [23:17:09] root INFO: SQL execution finished in 1.17s
ℹ️ [23:17:09] root INFO: Executing eligibility SQL statement
ℹ️ [23:17:09] root INFO: Executing SQL statement
ℹ️ [23:17:10] root INFO: SQL execution finished in 0.44s
ℹ️ [23:17:10] root INFO: Executing eligibility SQL statement
ℹ️ [23:17:10] root INFO: Executing SQL statement
ℹ️ [23:17:10] root INFO: SQL execution finished in 0.18s
ℹ️ [23:17:10] root INFO: Using cached waterfall steps.
ℹ️ [23:17:10] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:17:10] root INFO: Fetching data to DataFrame
ℹ️ [23:17:10] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.37s
ℹ️ [23:17:10] root INFO: Fetching data to DataFrame
ℹ️ [23:17:10] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:17:10] root INFO: Fetching data to DataFrame
❌ [23:17:11] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:17:11] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:17:11] root INFO: Fetching data to DataFrame
ℹ️ [23:17:11] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.32s
ℹ️ [23:17:11] root INFO: Fetching data to DataFrame
ℹ️ [23:17:11] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:17:11] root INFO: Fetching data to DataFrame
❌ [23:17:11] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:17:11] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:17:11] root INFO: Fetching data to DataFrame
ℹ️ [23:17:12] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.34s
ℹ️ [23:17:12] root INFO: Fetching data to DataFrame
ℹ️ [23:17:12] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:17:12] root INFO: Fetching data to DataFrame
❌ [23:17:12] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1167] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:17:12] root INFO: Using cached output steps.
ℹ️ [23:17:12] root INFO: Running output job for channel email
ℹ️ [23:17:12] root INFO: Fetching data to DataFrame
ℹ️ [23:17:12] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [23:17:12] root INFO: Fetched 17 rows for channel email
ℹ️ [23:17:12] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:17:12] root INFO: Running output job for channel sms
ℹ️ [23:17:12] root INFO: Fetching data to DataFrame
ℹ️ [23:17:12] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [23:17:12] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:17:12] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:17:12] root INFO: Running output job for channel push
ℹ️ [23:17:12] root INFO: Fetching data to DataFrame
ℹ️ [23:17:13] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [23:17:13] root INFO: Fetched 17 rows for channel push
ℹ️ [23:17:13] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:17:13] root INFO: Cleaning up DB connection
ℹ️ [23:17:15] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:17:15] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:17:15] root INFO: Calculation complete: 3 steps.
ℹ️ [23:17:15] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:17:15] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:17:15] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:17:15] root INFO: Calculating the number of output steps.
ℹ️ [23:17:15] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:17:15] root INFO: Preparing logic for channel 'email'
ℹ️ [23:17:15] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:17:15] root INFO: Preparing logic for channel 'push'
ℹ️ [23:17:15] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:17:15] root INFO: Using cached SQL statements.
ℹ️ [23:17:15] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:17:15] root INFO: Executing SQL statement
ℹ️ [23:17:16] root INFO: SQL execution finished in 1.19s
ℹ️ [23:17:16] root INFO: Executing eligibility SQL statement
ℹ️ [23:17:16] root INFO: Executing SQL statement
ℹ️ [23:17:16] root INFO: SQL execution finished in 0.48s
ℹ️ [23:17:16] root INFO: Executing eligibility SQL statement
ℹ️ [23:17:16] root INFO: Executing SQL statement
ℹ️ [23:17:16] root INFO: SQL execution finished in 0.18s
ℹ️ [23:17:16] root INFO: Using cached waterfall steps.
ℹ️ [23:17:16] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:17:16] root INFO: Fetching data to DataFrame
ℹ️ [23:17:17] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.37s
ℹ️ [23:17:17] root INFO: Fetching data to DataFrame
ℹ️ [23:17:17] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:17:17] root INFO: Fetching data to DataFrame
❌ [23:17:17] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:17:17] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:17:17] root INFO: Fetching data to DataFrame
ℹ️ [23:17:18] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.36s
ℹ️ [23:17:18] root INFO: Fetching data to DataFrame
ℹ️ [23:17:18] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.26s
ℹ️ [23:17:18] root INFO: Fetching data to DataFrame
❌ [23:17:18] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:17:18] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:17:18] root INFO: Fetching data to DataFrame
ℹ️ [23:17:19] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.58s
ℹ️ [23:17:19] root INFO: Fetching data to DataFrame
ℹ️ [23:17:19] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.32s
ℹ️ [23:17:19] root INFO: Fetching data to DataFrame
❌ [23:17:19] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1168] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:17:19] root INFO: Using cached output steps.
ℹ️ [23:17:19] root INFO: Running output job for channel email
ℹ️ [23:17:19] root INFO: Fetching data to DataFrame
ℹ️ [23:17:19] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [23:17:19] root INFO: Fetched 17 rows for channel email
ℹ️ [23:17:19] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:17:19] root INFO: Running output job for channel sms
ℹ️ [23:17:19] root INFO: Fetching data to DataFrame
ℹ️ [23:17:20] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [23:17:20] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:17:20] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:17:20] root INFO: Running output job for channel push
ℹ️ [23:17:20] root INFO: Fetching data to DataFrame
ℹ️ [23:17:20] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [23:17:20] root INFO: Fetched 17 rows for channel push
ℹ️ [23:17:20] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:17:20] root INFO: Cleaning up DB connection
ℹ️ [23:19:46] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:19:46] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:19:46] root INFO: Calculation complete: 3 steps.
ℹ️ [23:19:46] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:19:46] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:19:46] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:19:46] root INFO: Calculating the number of output steps.
ℹ️ [23:19:46] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:19:46] root INFO: Preparing logic for channel 'email'
ℹ️ [23:19:46] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:19:46] root INFO: Preparing logic for channel 'push'
ℹ️ [23:19:46] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:19:46] root INFO: Using cached SQL statements.
ℹ️ [23:19:46] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:19:46] root INFO: Executing SQL statement
ℹ️ [23:19:47] root INFO: SQL execution finished in 1.31s
ℹ️ [23:19:47] root INFO: Executing eligibility SQL statement
ℹ️ [23:19:47] root INFO: Executing SQL statement
ℹ️ [23:19:48] root INFO: SQL execution finished in 0.87s
ℹ️ [23:19:48] root INFO: Executing eligibility SQL statement
ℹ️ [23:19:48] root INFO: Executing SQL statement
ℹ️ [23:19:48] root INFO: SQL execution finished in 0.24s
ℹ️ [23:19:48] root INFO: Using cached waterfall steps.
ℹ️ [23:19:48] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:19:48] root INFO: Fetching data to DataFrame
ℹ️ [23:19:48] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.43s
ℹ️ [23:19:48] root INFO: Fetching data to DataFrame
ℹ️ [23:19:49] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:19:49] root INFO: Fetching data to DataFrame
❌ [23:19:49] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:19:49] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:19:49] root INFO: Fetching data to DataFrame
ℹ️ [23:19:49] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.31s
ℹ️ [23:19:49] root INFO: Fetching data to DataFrame
ℹ️ [23:19:49] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.27s
ℹ️ [23:19:49] root INFO: Fetching data to DataFrame
❌ [23:19:50] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:19:50] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:19:50] root INFO: Fetching data to DataFrame
ℹ️ [23:19:50] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.33s
ℹ️ [23:19:50] root INFO: Fetching data to DataFrame
ℹ️ [23:19:50] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.20s
ℹ️ [23:19:50] root INFO: Fetching data to DataFrame
❌ [23:19:50] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1170] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:19:50] root INFO: Using cached output steps.
ℹ️ [23:19:50] root INFO: Running output job for channel email
ℹ️ [23:19:50] root INFO: Fetching data to DataFrame
ℹ️ [23:19:51] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [23:19:51] root INFO: Fetched 17 rows for channel email
ℹ️ [23:19:51] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:19:51] root INFO: Running output job for channel sms
ℹ️ [23:19:51] root INFO: Fetching data to DataFrame
ℹ️ [23:19:51] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [23:19:51] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:19:51] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:19:51] root INFO: Running output job for channel push
ℹ️ [23:19:51] root INFO: Fetching data to DataFrame
ℹ️ [23:19:51] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [23:19:51] root INFO: Fetched 17 rows for channel push
ℹ️ [23:19:51] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:19:51] root INFO: Cleaning up DB connection
ℹ️ [23:19:55] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:19:55] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:19:55] root INFO: Calculation complete: 3 steps.
ℹ️ [23:19:55] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:19:55] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:19:55] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:19:55] root INFO: Calculating the number of output steps.
ℹ️ [23:19:55] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:19:55] root INFO: Preparing logic for channel 'email'
ℹ️ [23:19:55] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:19:55] root INFO: Preparing logic for channel 'push'
ℹ️ [23:19:55] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:19:55] root INFO: Using cached SQL statements.
ℹ️ [23:19:55] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:19:55] root INFO: Executing SQL statement
ℹ️ [23:19:57] root INFO: SQL execution finished in 1.12s
ℹ️ [23:19:57] root INFO: Executing eligibility SQL statement
ℹ️ [23:19:57] root INFO: Executing SQL statement
ℹ️ [23:19:57] root INFO: SQL execution finished in 0.47s
ℹ️ [23:19:57] root INFO: Executing eligibility SQL statement
ℹ️ [23:19:57] root INFO: Executing SQL statement
ℹ️ [23:19:57] root INFO: SQL execution finished in 0.18s
ℹ️ [23:19:57] root INFO: Using cached waterfall steps.
ℹ️ [23:19:57] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:19:57] root INFO: Fetching data to DataFrame
ℹ️ [23:19:58] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.39s
ℹ️ [23:19:58] root INFO: Fetching data to DataFrame
ℹ️ [23:19:58] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.24s
ℹ️ [23:19:58] root INFO: Fetching data to DataFrame
❌ [23:19:58] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:19:58] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:19:58] root INFO: Fetching data to DataFrame
ℹ️ [23:19:58] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.30s
ℹ️ [23:19:58] root INFO: Fetching data to DataFrame
ℹ️ [23:19:59] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:19:59] root INFO: Fetching data to DataFrame
❌ [23:19:59] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:19:59] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:19:59] root INFO: Fetching data to DataFrame
ℹ️ [23:19:59] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.37s
ℹ️ [23:19:59] root INFO: Fetching data to DataFrame
ℹ️ [23:19:59] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.30s
ℹ️ [23:19:59] root INFO: Fetching data to DataFrame
❌ [23:20:00] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1171] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:20:00] root INFO: Using cached output steps.
ℹ️ [23:20:00] root INFO: Running output job for channel email
ℹ️ [23:20:00] root INFO: Fetching data to DataFrame
ℹ️ [23:20:00] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.22s
ℹ️ [23:20:00] root INFO: Fetched 17 rows for channel email
ℹ️ [23:20:00] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:20:00] root INFO: Running output job for channel sms
ℹ️ [23:20:00] root INFO: Fetching data to DataFrame
ℹ️ [23:20:00] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.22s
ℹ️ [23:20:00] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:20:00] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:20:00] root INFO: Running output job for channel push
ℹ️ [23:20:00] root INFO: Fetching data to DataFrame
ℹ️ [23:20:00] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [23:20:00] root INFO: Fetched 17 rows for channel push
ℹ️ [23:20:00] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:20:00] root INFO: Cleaning up DB connection
ℹ️ [23:20:10] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:20:10] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:20:10] root INFO: Calculation complete: 3 steps.
ℹ️ [23:20:10] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:20:10] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:20:10] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:20:10] root INFO: Calculating the number of output steps.
ℹ️ [23:20:10] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:20:10] root INFO: Preparing logic for channel 'email'
ℹ️ [23:20:10] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:20:10] root INFO: Preparing logic for channel 'push'
ℹ️ [23:20:10] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:20:10] root INFO: Using cached SQL statements.
ℹ️ [23:20:10] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:20:10] root INFO: Executing SQL statement
ℹ️ [23:20:11] root INFO: SQL execution finished in 1.42s
ℹ️ [23:20:11] root INFO: Executing eligibility SQL statement
ℹ️ [23:20:11] root INFO: Executing SQL statement
ℹ️ [23:20:12] root INFO: SQL execution finished in 0.77s
ℹ️ [23:20:12] root INFO: Executing eligibility SQL statement
ℹ️ [23:20:12] root INFO: Executing SQL statement
ℹ️ [23:20:12] root INFO: SQL execution finished in 0.22s
ℹ️ [23:20:12] root INFO: Using cached waterfall steps.
ℹ️ [23:20:12] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [23:20:12] root INFO: Fetching data to DataFrame
ℹ️ [23:20:13] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.37s
ℹ️ [23:20:13] root INFO: Fetching data to DataFrame
ℹ️ [23:20:13] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.20s
ℹ️ [23:20:13] root INFO: Fetching data to DataFrame
❌ [23:20:13] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:20:13] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [23:20:13] root INFO: Fetching data to DataFrame
ℹ️ [23:20:13] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.31s
ℹ️ [23:20:13] root INFO: Fetching data to DataFrame
ℹ️ [23:20:14] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:20:14] root INFO: Fetching data to DataFrame
❌ [23:20:14] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    customer_id,account_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:20:14] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [23:20:14] root INFO: Fetching data to DataFrame
ℹ️ [23:20:14] root INFO: Fetched DataFrame with 9 rows and 3 columns in 0.30s
ℹ️ [23:20:14] root INFO: Fetching data to DataFrame
ℹ️ [23:20:14] root INFO: Fetched DataFrame with 5 rows and 3 columns in 0.22s
ℹ️ [23:20:14] root INFO: Fetching data to DataFrame
❌ [23:20:15] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 142, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall_segments.sql.j2
-- Purpose: Handles the "Claim and Exclude" logic for a series of non-BA segments.
--
-- Context:
--   eligibility_table:      Name of the smart eligibility table.
--   unique_identifiers:     List of unique ID columns.
--   pre_filter:             The base WHERE clause (e.g., passed all main and channel BA).
--   segments:               A list of segment objects. Each object must contain:
--                             - name: The name of the segment (e.g., 'SegmentA')
--                             - checks: A list of the individual check column names.
--                             - summary_column: The full SQL condition string for this segment.
--


-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - loyalty' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_loyalty_1 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_loyalty_1
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_loyalty_1' as check_name, COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics
UNION ALL

-- For each segment, we run two distinct calculations and UNION them together.

-- Calculation 1: Count records "Claimed" by this segment.
-- The population for this is anyone who has NOT been claimed by a previous segment.
SELECT
    'email - promo' AS section,
    'Records Claimed' AS stat_name,
    NULL AS check_name, -- Placeholder for consistent column structure
    COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.email_promo_1 = 1 OR c.email_promo_2 = 1)
  AND (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  
    AND NOT (c.email_loyalty_1 = 1)

UNION ALL

-- Calculation 2: Perform a detailed failure analysis for this segment.
-- The CTE below defines the correct sub-population for this segment's waterfall.
WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
    
      AND 
          NOT (c.email_loyalty_1 = 1)
          
    
),
-- The flags CTE is standard, but operates on our filtered population
flags AS (
  SELECT
    region_id,segment_id,
    email_promo_1,email_promo_2
  FROM current_segment_population
)
-- This is the standard waterfall calculation block, reused here.
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        
        SELECT
          'email_promo_1' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'email_promo_2' as check_name, COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
) metrics;': [Version 20.0.0.32] [Session 1172] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [23:20:15] root INFO: Using cached output steps.
ℹ️ [23:20:15] root INFO: Running output job for channel email
ℹ️ [23:20:15] root INFO: Fetching data to DataFrame
ℹ️ [23:20:15] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [23:20:15] root INFO: Fetched 17 rows for channel email
ℹ️ [23:20:15] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [23:20:15] root INFO: Running output job for channel sms
ℹ️ [23:20:15] root INFO: Fetching data to DataFrame
ℹ️ [23:20:15] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [23:20:15] root INFO: Fetched 8 rows for channel sms
ℹ️ [23:20:15] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [23:20:15] root INFO: Running output job for channel push
ℹ️ [23:20:15] root INFO: Fetching data to DataFrame
ℹ️ [23:20:15] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [23:20:15] root INFO: Fetched 17 rows for channel push
ℹ️ [23:20:15] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [23:20:15] root INFO: Cleaning up DB connection
ℹ️ [23:26:58] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:26:58] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:26:58] root INFO: Calculation complete: 3 steps.
ℹ️ [23:26:58] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:26:58] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:26:58] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:26:58] root INFO: Calculating the number of output steps.
ℹ️ [23:26:58] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:26:58] root INFO: Preparing logic for channel 'email'
ℹ️ [23:26:58] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:26:58] root INFO: Preparing logic for channel 'push'
ℹ️ [23:26:58] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:26:58] root INFO: Using cached SQL statements.
ℹ️ [23:26:58] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:26:58] root INFO: Executing SQL statement
ℹ️ [23:27:10] root INFO: No existing eligibility table to drop
ℹ️ [23:27:10] root INFO: Executing eligibility SQL statement
ℹ️ [23:27:10] root INFO: Executing SQL statement
ℹ️ [23:31:21] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:31:21] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:31:21] root INFO: Calculation complete: 3 steps.
ℹ️ [23:31:21] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:31:21] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:31:21] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:31:21] root INFO: Calculating the number of output steps.
ℹ️ [23:31:21] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:31:21] root INFO: Preparing logic for channel 'email'
ℹ️ [23:31:21] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:31:21] root INFO: Preparing logic for channel 'push'
ℹ️ [23:31:21] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:31:21] root INFO: Using cached SQL statements.
ℹ️ [23:31:21] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:31:21] root INFO: Executing SQL statement
ℹ️ [23:31:33] root INFO: No existing eligibility table to drop
ℹ️ [23:31:33] root INFO: Executing eligibility SQL statement
ℹ️ [23:31:33] root INFO: Executing SQL statement
ℹ️ [23:37:26] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:37:26] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:37:26] root INFO: Calculation complete: 3 steps.
ℹ️ [23:37:26] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:37:26] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:37:26] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:37:26] root INFO: Calculating the number of output steps.
ℹ️ [23:37:26] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:37:26] root INFO: Preparing logic for channel 'email'
ℹ️ [23:37:26] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:37:26] root INFO: Preparing logic for channel 'push'
ℹ️ [23:37:26] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:37:26] root INFO: Using cached SQL statements.
ℹ️ [23:37:26] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:37:26] root INFO: Executing SQL statement
ℹ️ [23:39:15] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:39:15] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:39:15] root INFO: Calculation complete: 3 steps.
ℹ️ [23:39:15] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:39:15] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:39:15] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:39:15] root INFO: Calculating the number of output steps.
ℹ️ [23:39:15] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:39:15] root INFO: Preparing logic for channel 'email'
ℹ️ [23:39:15] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:39:15] root INFO: Preparing logic for channel 'push'
ℹ️ [23:39:15] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:39:15] root INFO: Using cached SQL statements.
ℹ️ [23:39:15] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:39:15] root INFO: Executing SQL statement
ℹ️ [23:41:09] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:41:09] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:41:09] root INFO: Calculation complete: 3 steps.
ℹ️ [23:41:09] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:41:09] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:41:09] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:41:09] root INFO: Calculating the number of output steps.
ℹ️ [23:41:09] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:41:09] root INFO: Preparing logic for channel 'email'
ℹ️ [23:41:09] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:41:09] root INFO: Preparing logic for channel 'push'
ℹ️ [23:41:09] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:41:09] root INFO: Using cached SQL statements.
ℹ️ [23:41:09] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:41:09] root INFO: Executing SQL statement
ℹ️ [23:43:38] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:43:38] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:43:38] root INFO: Calculation complete: 3 steps.
ℹ️ [23:43:38] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:43:38] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:43:38] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:43:38] root INFO: Calculating the number of output steps.
ℹ️ [23:43:38] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:43:38] root INFO: Preparing logic for channel 'email'
ℹ️ [23:43:38] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:43:38] root INFO: Preparing logic for channel 'push'
ℹ️ [23:43:38] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:43:38] root INFO: Using cached SQL statements.
ℹ️ [23:43:38] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:43:38] root INFO: Executing SQL statement
ℹ️ [23:45:15] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:45:15] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:45:15] root INFO: Calculation complete: 3 steps.
ℹ️ [23:45:15] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:45:15] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:45:15] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:45:15] root INFO: Calculating the number of output steps.
ℹ️ [23:45:15] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:45:15] root INFO: Preparing logic for channel 'email'
ℹ️ [23:45:15] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:45:15] root INFO: Preparing logic for channel 'push'
ℹ️ [23:45:15] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:45:15] root INFO: Using cached SQL statements.
ℹ️ [23:45:15] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:45:15] root INFO: Executing SQL statement
ℹ️ [23:53:35] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [23:53:35] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [23:53:35] root INFO: Calculation complete: 3 steps.
ℹ️ [23:53:35] root INFO: Calculating the number of waterfall steps.
ℹ️ [23:53:35] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [23:53:35] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [23:53:35] root INFO: Calculating the number of output steps.
ℹ️ [23:53:35] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [23:53:35] root INFO: Preparing logic for channel 'email'
ℹ️ [23:53:35] root INFO: Preparing logic for channel 'sms'
ℹ️ [23:53:35] root INFO: Preparing logic for channel 'push'
ℹ️ [23:53:35] root INFO: Calculation complete: 3 steps (files).
ℹ️ [23:53:35] root INFO: Using cached SQL statements.
ℹ️ [23:53:35] root INFO: Dropping existing table eligibility_poc
ℹ️ [23:53:35] root INFO: Executing SQL statement
ℹ️ [23:53:47] root INFO: No existing eligibility table to drop
ℹ️ [23:53:47] root INFO: Executing eligibility SQL statement
ℹ️ [23:53:47] root INFO: Executing SQL statement
ℹ️ [07:19:49] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [07:19:49] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [07:19:49] root INFO: Calculation complete: 3 steps.
ℹ️ [07:19:49] root INFO: Calculating the number of waterfall steps.
ℹ️ [07:19:49] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [07:19:49] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [07:19:49] root INFO: Calculating the number of output steps.
ℹ️ [07:19:49] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [07:19:49] root INFO: Preparing logic for channel 'email'
ℹ️ [07:19:49] root INFO: Preparing logic for channel 'sms'
ℹ️ [07:19:49] root INFO: Preparing logic for channel 'push'
ℹ️ [07:19:49] root INFO: Calculation complete: 3 steps (files).
ℹ️ [07:19:49] root INFO: Using cached SQL statements.
ℹ️ [07:19:49] root INFO: Dropping existing table eligibility_poc
ℹ️ [07:19:49] root INFO: Executing SQL statement
ℹ️ [15:28:50] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [15:28:50] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [15:28:50] root INFO: Calculation complete: 3 steps.
ℹ️ [15:28:50] root INFO: Calculating the number of waterfall steps.
ℹ️ [15:28:50] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [15:28:50] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [15:28:50] root INFO: Calculating the number of output steps.
ℹ️ [15:28:50] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [15:28:50] root INFO: Preparing logic for channel 'email'
ℹ️ [15:28:50] root INFO: Preparing logic for channel 'sms'
ℹ️ [15:28:50] root INFO: Preparing logic for channel 'push'
ℹ️ [15:28:50] root INFO: Calculation complete: 3 steps (files).
ℹ️ [15:28:50] root INFO: Using cached SQL statements.
ℹ️ [15:28:50] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:28:50] root INFO: Executing SQL statement
ℹ️ [15:29:04] root INFO: No existing eligibility table to drop
ℹ️ [15:29:04] root INFO: Executing eligibility SQL statement
ℹ️ [15:29:04] root INFO: Executing SQL statement
ℹ️ [15:30:14] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [15:30:14] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [15:30:14] root INFO: Calculation complete: 3 steps.
ℹ️ [15:30:14] root INFO: Calculating the number of waterfall steps.
ℹ️ [15:30:14] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [15:30:14] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [15:30:14] root INFO: Calculating the number of output steps.
ℹ️ [15:30:14] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [15:30:14] root INFO: Preparing logic for channel 'email'
ℹ️ [15:30:14] root INFO: Preparing logic for channel 'sms'
ℹ️ [15:30:14] root INFO: Preparing logic for channel 'push'
ℹ️ [15:30:14] root INFO: Calculation complete: 3 steps (files).
ℹ️ [15:30:14] root INFO: Using cached SQL statements.
ℹ️ [15:30:14] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:30:14] root INFO: Executing SQL statement
ℹ️ [15:30:16] root INFO: SQL execution finished in 1.98s
ℹ️ [15:30:16] root INFO: Executing eligibility SQL statement
ℹ️ [15:30:16] root INFO: Executing SQL statement
ℹ️ [15:30:18] root INFO: SQL execution finished in 1.35s
ℹ️ [15:30:18] root INFO: Executing eligibility SQL statement
ℹ️ [15:30:18] root INFO: Executing SQL statement
ℹ️ [15:30:18] root INFO: SQL execution finished in 0.51s
ℹ️ [15:30:18] root INFO: Using cached waterfall steps.
ℹ️ [15:30:18] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [15:30:18] root INFO: Fetching data to DataFrame
ℹ️ [15:30:19] root INFO: Fetched DataFrame with 11 rows and 3 columns in 1.01s
ℹ️ [15:30:19] root INFO: Fetching data to DataFrame
❌ [15:30:19] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        email_BA_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_BA_1' AS check_name,
        SUM(CASE WHEN email_BA_1 = 0
            AND (
                (email_loyalty_1 = 1) OR 
                (email_promo_1 = 1 OR email_promo_2 = 1)
            )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
) metrics;': [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        email_BA_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_BA_1' AS check_name,
        SUM(CASE WHEN email_BA_1 = 0
            AND (
                (email_loyalty_1 = 1) OR 
                (email_promo_1 = 1 OR email_promo_2 = 1)
            )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
) metrics;': [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [15:30:20] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [15:30:20] root INFO: Fetching data to DataFrame
ℹ️ [15:30:20] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.90s
ℹ️ [15:30:20] root INFO: Fetching data to DataFrame
❌ [15:30:21] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        account_id, 
        email_BA_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_BA_1' AS check_name,
        SUM(CASE WHEN email_BA_1 = 0
            AND (
                (email_loyalty_1 = 1) OR 
                (email_promo_1 = 1 OR email_promo_2 = 1)
            )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
) metrics;': [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        account_id, 
        email_BA_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_BA_1' AS check_name,
        SUM(CASE WHEN email_BA_1 = 0
            AND (
                (email_loyalty_1 = 1) OR 
                (email_promo_1 = 1 OR email_promo_2 = 1)
            )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
) metrics;': [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [15:30:21] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [15:30:21] root INFO: Fetching data to DataFrame
ℹ️ [15:30:21] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.54s
ℹ️ [15:30:21] root INFO: Fetching data to DataFrame
❌ [15:30:22] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        region_id, 
        segment_id, 
        email_BA_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_BA_1' AS check_name,
        SUM(CASE WHEN email_BA_1 = 0
            AND (
                (email_loyalty_1 = 1) OR 
                (email_promo_1 = 1 OR email_promo_2 = 1)
            )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
) metrics;': [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        region_id, 
        segment_id, 
        email_BA_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'email_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_BA_1' AS check_name,
        SUM(CASE WHEN email_BA_1 = 0
            AND (
                (email_loyalty_1 = 1) OR 
                (email_promo_1 = 1 OR email_promo_2 = 1)
            )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
) metrics;': [Version 20.0.0.32] [Session 1174] [Teradata Database] [Error 5628] Column email_loyalty_1 not found in flags.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [15:30:22] root INFO: Using cached output steps.
ℹ️ [15:30:22] root INFO: Running output job for channel email
ℹ️ [15:30:22] root INFO: Fetching data to DataFrame
ℹ️ [15:30:22] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [15:30:22] root INFO: Fetched 17 rows for channel email
ℹ️ [15:30:22] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [15:30:22] root INFO: Running output job for channel sms
ℹ️ [15:30:22] root INFO: Fetching data to DataFrame
ℹ️ [15:30:22] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [15:30:22] root INFO: Fetched 8 rows for channel sms
ℹ️ [15:30:22] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [15:30:22] root INFO: Running output job for channel push
ℹ️ [15:30:22] root INFO: Fetching data to DataFrame
ℹ️ [15:30:22] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [15:30:22] root INFO: Fetched 17 rows for channel push
ℹ️ [15:30:22] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [15:30:22] root INFO: Cleaning up DB connection
ℹ️ [15:59:11] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [15:59:11] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [15:59:11] root INFO: Calculation complete: 3 steps.
ℹ️ [15:59:11] root INFO: Calculating the number of waterfall steps.
ℹ️ [15:59:11] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [15:59:11] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [15:59:11] root INFO: Calculating the number of output steps.
ℹ️ [15:59:11] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [15:59:11] root INFO: Preparing logic for channel 'email'
ℹ️ [15:59:11] root INFO: Preparing logic for channel 'sms'
ℹ️ [15:59:11] root INFO: Preparing logic for channel 'push'
ℹ️ [15:59:11] root INFO: Calculation complete: 3 steps (files).
ℹ️ [15:59:11] root INFO: Using cached SQL statements.
ℹ️ [15:59:11] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:59:11] root INFO: Executing SQL statement
ℹ️ [15:59:12] root INFO: SQL execution finished in 1.09s
ℹ️ [15:59:12] root INFO: Executing eligibility SQL statement
ℹ️ [15:59:12] root INFO: Executing SQL statement
ℹ️ [15:59:12] root INFO: SQL execution finished in 0.50s
ℹ️ [15:59:12] root INFO: Executing eligibility SQL statement
ℹ️ [15:59:12] root INFO: Executing SQL statement
ℹ️ [15:59:13] root INFO: SQL execution finished in 0.17s
ℹ️ [15:59:13] root INFO: Using cached waterfall steps.
ℹ️ [15:59:13] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [15:59:13] root INFO: Fetching data to DataFrame
ℹ️ [15:59:13] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.47s
ℹ️ [15:59:13] root INFO: Fetching data to DataFrame
ℹ️ [15:59:13] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [15:59:13] root INFO: Fetching data to DataFrame
❌ [15:59:14] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed breakdown for email - loyalty

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),
flags AS (
    SELECT
      customer_id, 
      email_loyalty_1, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,
        SUM(CASE WHEN email_loyalty_1 = 0
            AND NOT ( email_promo_1 = 1 OR email_promo_2 = 1 )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  UNION ALL
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed breakdown for email - promo

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      AND NOT ( c.email_loyalty_1 = 1 )
),
flags AS (
    SELECT
      customer_id, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,
        SUM(CASE WHEN email_promo_1 = 0 AND email_promo_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,
        SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  ;': [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed breakdown for email - loyalty

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),
flags AS (
    SELECT
      customer_id, 
      email_loyalty_1, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,
        SUM(CASE WHEN email_loyalty_1 = 0
            AND NOT ( email_promo_1 = 1 OR email_promo_2 = 1 )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  UNION ALL
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed breakdown for email - promo

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      AND NOT ( c.email_loyalty_1 = 1 )
),
flags AS (
    SELECT
      customer_id, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,
        SUM(CASE WHEN email_promo_1 = 0 AND email_promo_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,
        SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  ;': [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [15:59:14] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [15:59:14] root INFO: Fetching data to DataFrame
ℹ️ [15:59:14] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.40s
ℹ️ [15:59:14] root INFO: Fetching data to DataFrame
ℹ️ [15:59:14] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [15:59:14] root INFO: Fetching data to DataFrame
❌ [15:59:15] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed breakdown for email - loyalty

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),
flags AS (
    SELECT
      customer_id, 
      account_id, 
      email_loyalty_1, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,
        SUM(CASE WHEN email_loyalty_1 = 0
            AND NOT ( email_promo_1 = 1 OR email_promo_2 = 1 )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  UNION ALL
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed breakdown for email - promo

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      AND NOT ( c.email_loyalty_1 = 1 )
),
flags AS (
    SELECT
      customer_id, 
      account_id, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,
        SUM(CASE WHEN email_promo_1 = 0 AND email_promo_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,
        SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  ;': [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed breakdown for email - loyalty

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),
flags AS (
    SELECT
      customer_id, 
      account_id, 
      email_loyalty_1, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,
        SUM(CASE WHEN email_loyalty_1 = 0
            AND NOT ( email_promo_1 = 1 OR email_promo_2 = 1 )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  UNION ALL
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed breakdown for email - promo

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      AND NOT ( c.email_loyalty_1 = 1 )
),
flags AS (
    SELECT
      customer_id, 
      account_id, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,
        SUM(CASE WHEN email_promo_1 = 0 AND email_promo_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,
        SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  ;': [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [15:59:15] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [15:59:15] root INFO: Fetching data to DataFrame
ℹ️ [15:59:15] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.48s
ℹ️ [15:59:15] root INFO: Fetching data to DataFrame
ℹ️ [15:59:15] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [15:59:16] root INFO: Fetching data to DataFrame
❌ [15:59:16] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed breakdown for email - loyalty

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),
flags AS (
    SELECT
      region_id, 
      segment_id, 
      email_loyalty_1, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,
        SUM(CASE WHEN email_loyalty_1 = 0
            AND NOT ( email_promo_1 = 1 OR email_promo_2 = 1 )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  UNION ALL
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed breakdown for email - promo

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      AND NOT ( c.email_loyalty_1 = 1 )
),
flags AS (
    SELECT
      region_id, 
      segment_id, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,
        SUM(CASE WHEN email_promo_1 = 0 AND email_promo_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,
        SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  ;': [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed breakdown for email - loyalty

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),
flags AS (
    SELECT
      region_id, 
      segment_id, 
      email_loyalty_1, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_loyalty_1' AS check_name,
        SUM(CASE WHEN email_loyalty_1 = 0
            AND NOT ( email_promo_1 = 1 OR email_promo_2 = 1 )
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  UNION ALL
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed breakdown for email - promo

WITH current_segment_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      AND NOT ( c.email_loyalty_1 = 1 )
),
flags AS (
    SELECT
      region_id, 
      segment_id, 
      email_promo_1, 
      email_promo_2
    FROM current_segment_population
)
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN email_promo_2 = 1 AND email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) q
    

    UNION ALL

    -- Regain metric for the segment
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'email_promo_1' AS check_name,
        SUM(CASE WHEN email_promo_1 = 0 AND email_promo_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'email_promo_2' AS check_name,
        SUM(CASE WHEN email_promo_2 = 0 AND email_promo_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r
  ) metrics
  ;': [Version 20.0.0.32] [Session 1182] [Teradata Database] [Error 3707] Syntax error, expected something like a 'SELECT' keyword or '(' or a 'TRANSACTIONTIME' keyword or a 'NONTEMPORAL' keyword between the 'ALL' keyword and the 'WITH' keyword.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [15:59:16] root INFO: Using cached output steps.
ℹ️ [15:59:16] root INFO: Running output job for channel email
ℹ️ [15:59:16] root INFO: Fetching data to DataFrame
ℹ️ [15:59:16] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [15:59:16] root INFO: Fetched 17 rows for channel email
ℹ️ [15:59:16] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [15:59:16] root INFO: Running output job for channel sms
ℹ️ [15:59:16] root INFO: Fetching data to DataFrame
ℹ️ [15:59:16] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [15:59:16] root INFO: Fetched 8 rows for channel sms
ℹ️ [15:59:16] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [15:59:16] root INFO: Running output job for channel push
ℹ️ [15:59:16] root INFO: Fetching data to DataFrame
ℹ️ [15:59:16] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [15:59:16] root INFO: Fetched 17 rows for channel push
ℹ️ [15:59:16] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [15:59:17] root INFO: Cleaning up DB connection
ℹ️ [16:13:42] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [16:13:42] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [16:13:42] root INFO: Calculation complete: 3 steps.
ℹ️ [16:13:42] root INFO: Calculating the number of waterfall steps.
ℹ️ [16:13:42] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [16:13:42] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [16:13:42] root INFO: Calculating the number of output steps.
ℹ️ [16:13:42] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [16:13:42] root INFO: Preparing logic for channel 'email'
ℹ️ [16:13:42] root INFO: Preparing logic for channel 'sms'
ℹ️ [16:13:42] root INFO: Preparing logic for channel 'push'
ℹ️ [16:13:42] root INFO: Calculation complete: 3 steps (files).
ℹ️ [16:13:42] root INFO: Using cached SQL statements.
ℹ️ [16:13:42] root INFO: Dropping existing table eligibility_poc
ℹ️ [16:13:42] root INFO: Executing SQL statement
ℹ️ [16:13:44] root INFO: SQL execution finished in 1.27s
ℹ️ [16:13:44] root INFO: Executing eligibility SQL statement
ℹ️ [16:13:44] root INFO: Executing SQL statement
ℹ️ [16:13:44] root INFO: SQL execution finished in 0.48s
ℹ️ [16:13:44] root INFO: Executing eligibility SQL statement
ℹ️ [16:13:44] root INFO: Executing SQL statement
ℹ️ [16:13:44] root INFO: SQL execution finished in 0.15s
ℹ️ [16:13:44] root INFO: Using cached waterfall steps.
ℹ️ [16:13:44] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [16:13:44] root INFO: Fetching data to DataFrame
❌ [16:13:45] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),
flags AS (
    SELECT
        customer_id, 
        main_BA_1, 
        main_BA_2
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'main_BA_1' AS check_name,
        SUM(CASE WHEN main_BA_1 = 0 AND main_BA_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'main_BA_2' AS check_name,
        SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r': [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),
flags AS (
    SELECT
        customer_id, 
        main_BA_1, 
        main_BA_2
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'main_BA_1' AS check_name,
        SUM(CASE WHEN main_BA_1 = 0 AND main_BA_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'main_BA_2' AS check_name,
        SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r': [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:13:45] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [16:13:45] root INFO: Fetching data to DataFrame
❌ [16:13:45] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),
flags AS (
    SELECT
        customer_id, 
        account_id, 
        main_BA_1, 
        main_BA_2
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'main_BA_1' AS check_name,
        SUM(CASE WHEN main_BA_1 = 0 AND main_BA_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'main_BA_2' AS check_name,
        SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r': [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),
flags AS (
    SELECT
        customer_id, 
        account_id, 
        main_BA_1, 
        main_BA_2
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'main_BA_1' AS check_name,
        SUM(CASE WHEN main_BA_1 = 0 AND main_BA_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'main_BA_2' AS check_name,
        SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r': [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:13:45] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [16:13:45] root INFO: Fetching data to DataFrame
❌ [16:13:45] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),
flags AS (
    SELECT
        region_id, 
        segment_id, 
        main_BA_1, 
        main_BA_2
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'main_BA_1' AS check_name,
        SUM(CASE WHEN main_BA_1 = 0 AND main_BA_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'main_BA_2' AS check_name,
        SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r': [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),
flags AS (
    SELECT
        region_id, 
        segment_id, 
        main_BA_1, 
        main_BA_2
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 0 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
        SELECT
          'main_BA_1' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        UNION ALL
        
        SELECT
          'main_BA_2' AS check_name,COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1 THEN 1 ELSE 0 END) AS cntr
        FROM flags
        
        
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
      SELECT
        'main_BA_1' AS check_name,
        SUM(CASE WHEN main_BA_1 = 0 AND main_BA_2 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      UNION ALL
      
      SELECT
        'main_BA_2' AS check_name,
        SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
        THEN 1 ELSE 0 END) AS cntr
      FROM flags
      
      
    ) r': [Version 20.0.0.32] [Session 1186] [Teradata Database] [Error 3707] Syntax error, expected something like an 'EXCEPT' keyword or an 'UNION' keyword or a 'MINUS' keyword between the word 'r' and ';'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:13:46] root INFO: Using cached output steps.
ℹ️ [16:13:46] root INFO: Running output job for channel email
ℹ️ [16:13:46] root INFO: Fetching data to DataFrame
ℹ️ [16:13:46] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.65s
ℹ️ [16:13:46] root INFO: Fetched 17 rows for channel email
ℹ️ [16:13:46] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [16:13:46] root INFO: Running output job for channel sms
ℹ️ [16:13:46] root INFO: Fetching data to DataFrame
ℹ️ [16:13:46] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [16:13:46] root INFO: Fetched 8 rows for channel sms
ℹ️ [16:13:46] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [16:13:46] root INFO: Running output job for channel push
ℹ️ [16:13:46] root INFO: Fetching data to DataFrame
ℹ️ [16:13:47] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [16:13:47] root INFO: Fetched 17 rows for channel push
ℹ️ [16:13:47] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [16:13:47] root INFO: Cleaning up DB connection
ℹ️ [16:17:23] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [16:17:23] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [16:17:23] root INFO: Calculation complete: 3 steps.
ℹ️ [16:17:23] root INFO: Calculating the number of waterfall steps.
ℹ️ [16:17:23] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [16:17:23] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [16:17:23] root INFO: Calculating the number of output steps.
ℹ️ [16:17:23] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [16:17:23] root INFO: Preparing logic for channel 'email'
ℹ️ [16:17:23] root INFO: Preparing logic for channel 'sms'
ℹ️ [16:17:23] root INFO: Preparing logic for channel 'push'
ℹ️ [16:17:23] root INFO: Calculation complete: 3 steps (files).
ℹ️ [16:17:23] root INFO: Using cached SQL statements.
ℹ️ [16:17:23] root INFO: Dropping existing table eligibility_poc
ℹ️ [16:17:23] root INFO: Executing SQL statement
ℹ️ [16:17:25] root INFO: SQL execution finished in 1.43s
ℹ️ [16:17:25] root INFO: Executing eligibility SQL statement
ℹ️ [16:17:25] root INFO: Executing SQL statement
ℹ️ [16:17:25] root INFO: SQL execution finished in 0.63s
ℹ️ [16:17:25] root INFO: Executing eligibility SQL statement
ℹ️ [16:17:25] root INFO: Executing SQL statement
ℹ️ [16:17:25] root INFO: SQL execution finished in 0.17s
ℹ️ [16:17:25] root INFO: Using cached waterfall steps.
ℹ️ [16:17:25] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [16:17:25] root INFO: Fetching data to DataFrame
ℹ️ [16:17:26] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.48s
ℹ️ [16:17:26] root INFO: Fetching data to DataFrame
ℹ️ [16:17:26] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [16:17:26] root INFO: Fetching data to DataFrame
❌ [16:17:26] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed waterfall breakdown and regain for email - loyalty
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
) q
;
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed waterfall breakdown and regain for email - promo
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 AND c.email_promo_2 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
) q
;': [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed waterfall breakdown and regain for email - loyalty
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
) q
;
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed waterfall breakdown and regain for email - promo
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 AND c.email_promo_2 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
) q
;': [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:17:27] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [16:17:27] root INFO: Fetching data to DataFrame
ℹ️ [16:17:27] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.36s
ℹ️ [16:17:27] root INFO: Fetching data to DataFrame
ℹ️ [16:17:27] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.39s
ℹ️ [16:17:27] root INFO: Fetching data to DataFrame
❌ [16:17:28] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed waterfall breakdown and regain for email - loyalty
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
) q
;
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed waterfall breakdown and regain for email - promo
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 AND c.email_promo_2 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
) q
;': [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed waterfall breakdown and regain for email - loyalty
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
) q
;
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed waterfall breakdown and regain for email - promo
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 AND c.email_promo_2 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
) q
;': [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:17:28] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [16:17:28] root INFO: Fetching data to DataFrame
ℹ️ [16:17:28] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.38s
ℹ️ [16:17:28] root INFO: Fetching data to DataFrame
ℹ️ [16:17:29] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [16:17:29] root INFO: Fetching data to DataFrame
❌ [16:17:29] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed waterfall breakdown and regain for email - loyalty
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
) q
;
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed waterfall breakdown and regain for email - promo
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 AND c.email_promo_2 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
) q
;': [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
-- Records claimed for email - loyalty
SELECT
  'email - loyalty' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)

UNION ALL

-- Detailed waterfall breakdown and regain for email - loyalty
SELECT
  'email - loyalty' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_loyalty_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_loyalty_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_loyalty_1' AS check_name,SUM(CASE WHEN c.email_loyalty_1 = 0
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
) q
;
-- Records claimed for email - promo
SELECT
  'email - promo' AS section,
  'Records Claimed' AS stat_name,
  NULL AS check_name,
  COUNT(*) AS cntr
FROM eligibility_poc c
WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
  AND NOT ( c.email_loyalty_1 = 1 )

UNION ALL

-- Detailed waterfall breakdown and regain for email - promo
SELECT
  'email - promo' AS section,
  stat_name,
  check_name,
  cntr
FROM (
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'unique_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'incremental_drops' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'remaining' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_1' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'cumulative_drops' AS stat_name,
        'email_promo_2' AS check_name,COUNT(*) - SUM(CASE WHEN c.email_promo_2 = 1 AND c.email_promo_1 = 1 THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_1' AS check_name,SUM(CASE WHEN c.email_promo_1 = 0 AND c.email_promo_2 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
      GROUP BY 1,2
      UNION ALL
      SELECT
        'regain' AS stat_name,
        'email_promo_2' AS check_name,SUM(CASE WHEN c.email_promo_2 = 0 AND c.email_promo_1 = 1
          THEN 1 ELSE 0 END) AS cntr
      FROM eligibility_poc c
      WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
          AND NOT ( c.email_loyalty_1 = 1 )
      GROUP BY 1,2
) q
;': [Version 20.0.0.32] [Session 1188] [Teradata Database] [Error 3654] Corresponding select-list expressions are incompatible.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:17:29] root INFO: Using cached output steps.
ℹ️ [16:17:29] root INFO: Running output job for channel email
ℹ️ [16:17:29] root INFO: Fetching data to DataFrame
ℹ️ [16:17:29] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [16:17:29] root INFO: Fetched 17 rows for channel email
ℹ️ [16:17:29] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [16:17:29] root INFO: Running output job for channel sms
ℹ️ [16:17:29] root INFO: Fetching data to DataFrame
ℹ️ [16:17:29] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [16:17:29] root INFO: Fetched 8 rows for channel sms
ℹ️ [16:17:29] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [16:17:29] root INFO: Running output job for channel push
ℹ️ [16:17:30] root INFO: Fetching data to DataFrame
ℹ️ [16:17:30] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.32s
ℹ️ [16:17:30] root INFO: Fetched 17 rows for channel push
ℹ️ [16:17:30] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [16:17:30] root INFO: Cleaning up DB connection
ℹ️ [16:25:04] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [16:25:04] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [16:25:04] root INFO: Calculation complete: 3 steps.
ℹ️ [16:25:04] root INFO: Calculating the number of waterfall steps.
ℹ️ [16:25:04] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [16:25:04] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [16:25:04] root INFO: Calculating the number of output steps.
ℹ️ [16:25:04] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [16:25:04] root INFO: Preparing logic for channel 'email'
ℹ️ [16:25:04] root INFO: Preparing logic for channel 'sms'
ℹ️ [16:25:04] root INFO: Preparing logic for channel 'push'
ℹ️ [16:25:04] root INFO: Calculation complete: 3 steps (files).
ℹ️ [16:25:04] root INFO: Using cached SQL statements.
ℹ️ [16:25:04] root INFO: Dropping existing table eligibility_poc
ℹ️ [16:25:04] root INFO: Executing SQL statement
ℹ️ [16:25:06] root INFO: SQL execution finished in 1.26s
ℹ️ [16:25:06] root INFO: Executing eligibility SQL statement
ℹ️ [16:25:06] root INFO: Executing SQL statement
ℹ️ [16:25:06] root INFO: SQL execution finished in 0.46s
ℹ️ [16:25:06] root INFO: Executing eligibility SQL statement
ℹ️ [16:25:06] root INFO: Executing SQL statement
ℹ️ [16:25:06] root INFO: SQL execution finished in 0.17s
ℹ️ [16:25:06] root INFO: Using cached waterfall steps.
ℹ️ [16:25:06] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [16:25:06] root INFO: Fetching data to DataFrame
ℹ️ [16:25:07] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.67s
ℹ️ [16:25:07] root INFO: Fetching data to DataFrame
ℹ️ [16:25:07] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.43s
ℹ️ [16:25:07] root INFO: Fetching data to DataFrame
ℹ️ [16:25:08] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.88s
ℹ️ [16:25:08] root INFO: Fetching data to DataFrame
ℹ️ [16:25:09] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [16:25:09] root INFO: Fetching data to DataFrame
ℹ️ [16:25:09] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.59s
ℹ️ [16:25:09] root INFO: Fetching data to DataFrame
❌ [16:25:10] root ERROR: Waterfall grouping 'customer_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        push_promotions_1, 
        push_promotions_2, 
        push_surveys_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
    ) r
) metrics;': [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        push_promotions_1, 
        push_promotions_2, 
        push_surveys_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
    ) r
) metrics;': [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:25:10] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [16:25:10] root INFO: Fetching data to DataFrame
ℹ️ [16:25:10] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.38s
ℹ️ [16:25:10] root INFO: Fetching data to DataFrame
ℹ️ [16:25:10] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [16:25:10] root INFO: Fetching data to DataFrame
ℹ️ [16:25:11] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.59s
ℹ️ [16:25:11] root INFO: Fetching data to DataFrame
ℹ️ [16:25:11] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [16:25:11] root INFO: Fetching data to DataFrame
ℹ️ [16:25:12] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.56s
ℹ️ [16:25:12] root INFO: Fetching data to DataFrame
❌ [16:25:12] root ERROR: Waterfall grouping 'customer_id_account_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        account_id, 
        push_promotions_1, 
        push_promotions_2, 
        push_surveys_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
    ) r
) metrics;': [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        customer_id, 
        account_id, 
        push_promotions_1, 
        push_promotions_2, 
        push_surveys_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
    ) r
) metrics;': [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:25:12] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [16:25:12] root INFO: Fetching data to DataFrame
ℹ️ [16:25:13] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.56s
ℹ️ [16:25:13] root INFO: Fetching data to DataFrame
ℹ️ [16:25:13] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [16:25:13] root INFO: Fetching data to DataFrame
ℹ️ [16:25:13] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.33s
ℹ️ [16:25:13] root INFO: Fetching data to DataFrame
ℹ️ [16:25:13] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [16:25:13] root INFO: Fetching data to DataFrame
ℹ️ [16:25:14] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.34s
ℹ️ [16:25:14] root INFO: Fetching data to DataFrame
❌ [16:25:14] root ERROR: Waterfall grouping 'region_id_segment_id' failed: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        region_id, 
        segment_id, 
        push_promotions_1, 
        push_promotions_2, 
        push_surveys_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
    ) r
) metrics;': [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 169, in run
    df_raw = self.runner.to_df(job['sql'])
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 64, in to_df
    df = pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Jinja2 Template: waterfall.sql.j2
-- Purpose: Unified waterfall report with base/channel BA segments and non-BA bucket segments, including regain metric.
  
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),
flags AS (
    SELECT
        region_id, 
        segment_id, 
        push_promotions_1, 
        push_promotions_2, 
        push_surveys_1
    FROM base_population
)
SELECT
  stat_name,
  check_name,
  cntr
FROM (
    -- initial population count
    SELECT
      'initial_population' AS stat_name,
      'Total' AS check_name,
      COUNT(*) AS cntr
    FROM base_population

    UNION ALL

    -- standard waterfall parts (unique, incremental, remaining, cumulative)
    SELECT
      'unique_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'incremental_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'remaining' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    
    UNION ALL
    
    SELECT
      'cumulative_drops' AS stat_name,
      check_name,
      cntr
    FROM (
    ) q
    

    UNION ALL

    -- regain metric: rows regained if only this check failed (others passed) and segments condition holds
    SELECT
      'regain' AS stat_name,
      check_name,
      cntr
    FROM (
    ) r
) metrics;': [Version 20.0.0.32] [Session 1190] [Teradata Database] [Error 3707] Syntax error, expected something like a name or a Unicode delimited identifier or an 'UDFCALLNAME' keyword or a 'SELECT' keyword or '(' between '(' and ')'.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:25:14] root INFO: Using cached output steps.
ℹ️ [16:25:14] root INFO: Running output job for channel email
ℹ️ [16:25:14] root INFO: Fetching data to DataFrame
ℹ️ [16:25:14] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [16:25:14] root INFO: Fetched 17 rows for channel email
ℹ️ [16:25:14] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [16:25:14] root INFO: Running output job for channel sms
ℹ️ [16:25:14] root INFO: Fetching data to DataFrame
ℹ️ [16:25:15] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.16s
ℹ️ [16:25:15] root INFO: Fetched 8 rows for channel sms
ℹ️ [16:25:15] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [16:25:15] root INFO: Running output job for channel push
ℹ️ [16:25:15] root INFO: Fetching data to DataFrame
ℹ️ [16:25:15] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [16:25:15] root INFO: Fetched 17 rows for channel push
ℹ️ [16:25:15] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [16:25:15] root INFO: Cleaning up DB connection
ℹ️ [17:40:45] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [17:40:45] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [17:40:45] root INFO: Calculation complete: 3 steps.
ℹ️ [17:40:45] root INFO: Calculating the number of waterfall steps.
ℹ️ [17:40:45] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [17:40:45] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [17:40:45] root INFO: Calculating the number of output steps.
ℹ️ [17:40:45] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [17:40:45] root INFO: Preparing logic for channel 'email'
ℹ️ [17:40:45] root INFO: Preparing logic for channel 'sms'
ℹ️ [17:40:45] root INFO: Preparing logic for channel 'push'
ℹ️ [17:40:45] root INFO: Calculation complete: 3 steps (files).
ℹ️ [17:40:45] root INFO: Using cached SQL statements.
ℹ️ [17:40:45] root INFO: Dropping existing table eligibility_poc
ℹ️ [17:40:45] root INFO: Executing SQL statement
ℹ️ [17:40:46] root INFO: SQL execution finished in 1.42s
ℹ️ [17:40:46] root INFO: Executing eligibility SQL statement
ℹ️ [17:40:46] root INFO: Executing SQL statement
ℹ️ [17:40:47] root INFO: SQL execution finished in 0.48s
ℹ️ [17:40:47] root INFO: Executing eligibility SQL statement
ℹ️ [17:40:47] root INFO: Executing SQL statement
ℹ️ [17:40:47] root INFO: SQL execution finished in 0.19s
ℹ️ [17:40:47] root INFO: Using cached waterfall steps.
ℹ️ [17:40:47] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [17:40:47] root INFO: Fetching data to DataFrame
ℹ️ [17:40:48] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.62s
ℹ️ [17:40:48] root INFO: Fetching data to DataFrame
ℹ️ [17:40:48] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [17:40:48] root INFO: Fetching data to DataFrame
ℹ️ [17:40:49] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.66s
ℹ️ [17:40:49] root INFO: Fetching data to DataFrame
ℹ️ [17:40:49] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [17:40:49] root INFO: Fetching data to DataFrame
ℹ️ [17:40:50] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.70s
ℹ️ [17:40:50] root INFO: Fetching data to DataFrame
ℹ️ [17:40:50] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.56s
ℹ️ [17:40:50] root INFO: Waterfall report for 'customer_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id.xlsx
ℹ️ [17:40:50] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [17:40:50] root INFO: Fetching data to DataFrame
ℹ️ [17:40:51] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.56s
ℹ️ [17:40:51] root INFO: Fetching data to DataFrame
ℹ️ [17:40:51] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.44s
ℹ️ [17:40:51] root INFO: Fetching data to DataFrame
ℹ️ [17:40:52] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.78s
ℹ️ [17:40:52] root INFO: Fetching data to DataFrame
ℹ️ [17:40:53] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [17:40:53] root INFO: Fetching data to DataFrame
ℹ️ [17:40:53] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.64s
ℹ️ [17:40:53] root INFO: Fetching data to DataFrame
ℹ️ [17:40:54] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.73s
ℹ️ [17:40:54] root INFO: Waterfall report for 'customer_id_account_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id_account_id.xlsx
ℹ️ [17:40:54] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [17:40:54] root INFO: Fetching data to DataFrame
ℹ️ [17:40:54] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.46s
ℹ️ [17:40:54] root INFO: Fetching data to DataFrame
ℹ️ [17:40:55] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [17:40:55] root INFO: Fetching data to DataFrame
ℹ️ [17:40:55] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.37s
ℹ️ [17:40:55] root INFO: Fetching data to DataFrame
ℹ️ [17:40:55] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [17:40:55] root INFO: Fetching data to DataFrame
ℹ️ [17:40:56] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.35s
ℹ️ [17:40:56] root INFO: Fetching data to DataFrame
ℹ️ [17:40:56] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.34s
ℹ️ [17:40:56] root INFO: Waterfall report for 'region_id_segment_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_region_id_segment_id.xlsx
ℹ️ [17:40:56] root INFO: Using cached output steps.
ℹ️ [17:40:56] root INFO: Running output job for channel email
ℹ️ [17:40:56] root INFO: Fetching data to DataFrame
ℹ️ [17:40:56] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.20s
ℹ️ [17:40:56] root INFO: Fetched 17 rows for channel email
ℹ️ [17:40:56] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [17:40:56] root INFO: Running output job for channel sms
ℹ️ [17:40:56] root INFO: Fetching data to DataFrame
ℹ️ [17:40:57] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.18s
ℹ️ [17:40:57] root INFO: Fetched 8 rows for channel sms
ℹ️ [17:40:57] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [17:40:57] root INFO: Running output job for channel push
ℹ️ [17:40:57] root INFO: Fetching data to DataFrame
ℹ️ [17:40:57] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [17:40:57] root INFO: Fetched 17 rows for channel push
ℹ️ [17:40:57] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [17:40:57] root INFO: Cleaning up DB connection
ℹ️ [19:06:07] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [19:06:07] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [19:06:07] root INFO: Calculation complete: 3 steps.
ℹ️ [19:06:07] root INFO: Calculating the number of waterfall steps.
ℹ️ [19:06:07] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [19:06:07] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [19:06:07] root INFO: Calculating the number of output steps.
ℹ️ [19:06:07] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [19:06:07] root INFO: Preparing logic for channel 'email'
ℹ️ [19:06:07] root INFO: Preparing logic for channel 'sms'
ℹ️ [19:06:07] root INFO: Preparing logic for channel 'push'
ℹ️ [19:06:07] root INFO: Calculation complete: 3 steps (files).
ℹ️ [19:06:07] root INFO: Using cached SQL statements.
ℹ️ [19:06:07] root INFO: Dropping existing table eligibility_poc
ℹ️ [19:06:07] root INFO: Executing SQL statement
ℹ️ [19:06:08] root INFO: SQL execution finished in 0.98s
ℹ️ [19:06:08] root INFO: Executing eligibility SQL statement
ℹ️ [19:06:08] root INFO: Executing SQL statement
ℹ️ [19:06:09] root INFO: SQL execution finished in 0.69s
ℹ️ [19:06:09] root INFO: Executing eligibility SQL statement
ℹ️ [19:06:09] root INFO: Executing SQL statement
ℹ️ [19:06:09] root INFO: SQL execution finished in 0.15s
ℹ️ [19:06:09] root INFO: Using cached waterfall steps.
ℹ️ [19:06:09] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [19:06:09] root INFO: Fetching data to DataFrame
ℹ️ [19:06:09] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.48s
ℹ️ [19:06:09] root INFO: Fetching data to DataFrame
ℹ️ [19:06:10] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [19:06:10] root INFO: Fetching data to DataFrame
ℹ️ [19:06:10] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.51s
ℹ️ [19:06:10] root INFO: Fetching data to DataFrame
ℹ️ [19:06:10] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [19:06:10] root INFO: Fetching data to DataFrame
ℹ️ [19:06:11] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.53s
ℹ️ [19:06:11] root INFO: Fetching data to DataFrame
ℹ️ [19:06:11] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.57s
ℹ️ [19:06:12] root INFO: Waterfall report for 'customer_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id.xlsx
ℹ️ [19:06:12] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [19:06:12] root INFO: Fetching data to DataFrame
ℹ️ [19:06:12] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.56s
ℹ️ [19:06:12] root INFO: Fetching data to DataFrame
ℹ️ [19:06:13] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.36s
ℹ️ [19:06:13] root INFO: Fetching data to DataFrame
ℹ️ [19:06:13] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.53s
ℹ️ [19:06:13] root INFO: Fetching data to DataFrame
ℹ️ [19:06:13] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [19:06:13] root INFO: Fetching data to DataFrame
ℹ️ [19:06:14] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.89s
ℹ️ [19:06:14] root INFO: Fetching data to DataFrame
ℹ️ [19:06:15] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.49s
ℹ️ [19:06:15] root INFO: Waterfall report for 'customer_id_account_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id_account_id.xlsx
ℹ️ [19:06:15] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [19:06:15] root INFO: Fetching data to DataFrame
ℹ️ [19:06:15] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.34s
ℹ️ [19:06:15] root INFO: Fetching data to DataFrame
ℹ️ [19:06:15] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [19:06:15] root INFO: Fetching data to DataFrame
ℹ️ [19:06:16] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.31s
ℹ️ [19:06:16] root INFO: Fetching data to DataFrame
ℹ️ [19:06:16] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.26s
ℹ️ [19:06:16] root INFO: Fetching data to DataFrame
ℹ️ [19:06:16] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.31s
ℹ️ [19:06:16] root INFO: Fetching data to DataFrame
ℹ️ [19:06:17] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.31s
ℹ️ [19:06:17] root INFO: Waterfall report for 'region_id_segment_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_region_id_segment_id.xlsx
ℹ️ [19:06:17] root INFO: Using cached output steps.
ℹ️ [19:06:17] root INFO: Running output job for channel email
ℹ️ [19:06:17] root INFO: Fetching data to DataFrame
ℹ️ [19:06:17] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [19:06:17] root INFO: Fetched 17 rows for channel email
ℹ️ [19:06:17] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [19:06:17] root INFO: Running output job for channel sms
ℹ️ [19:06:17] root INFO: Fetching data to DataFrame
ℹ️ [19:06:17] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.14s
ℹ️ [19:06:17] root INFO: Fetched 8 rows for channel sms
ℹ️ [19:06:17] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [19:06:17] root INFO: Running output job for channel push
ℹ️ [19:06:17] root INFO: Fetching data to DataFrame
ℹ️ [19:06:17] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [19:06:17] root INFO: Fetched 17 rows for channel push
ℹ️ [19:06:17] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [19:06:17] root INFO: Cleaning up DB connection
ℹ️ [19:36:26] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [19:36:26] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [19:36:26] root INFO: Calculation complete: 3 steps.
ℹ️ [19:36:26] root INFO: Calculating the number of waterfall steps.
ℹ️ [19:36:26] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [19:36:27] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [19:36:27] root INFO: Calculating the number of output steps.
ℹ️ [19:36:27] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [19:36:27] root INFO: Preparing logic for channel 'email'
ℹ️ [19:36:27] root INFO: Preparing logic for channel 'sms'
ℹ️ [19:36:27] root INFO: Preparing logic for channel 'push'
ℹ️ [19:36:27] root INFO: Calculation complete: 3 steps (files).
ℹ️ [19:36:27] root INFO: Using cached SQL statements.
ℹ️ [19:36:27] root INFO: Dropping existing table eligibility_poc
ℹ️ [19:36:27] root INFO: Executing SQL statement
ℹ️ [19:36:28] root INFO: SQL execution finished in 0.99s
ℹ️ [19:36:28] root INFO: Executing eligibility SQL statement
ℹ️ [19:36:28] root INFO: Executing SQL statement
ℹ️ [19:36:28] root INFO: SQL execution finished in 0.45s
ℹ️ [19:36:28] root INFO: Executing eligibility SQL statement
ℹ️ [19:36:28] root INFO: Executing SQL statement
ℹ️ [19:36:28] root INFO: SQL execution finished in 0.17s
ℹ️ [19:36:28] root INFO: Using cached waterfall steps.
ℹ️ [19:36:28] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [19:36:28] root INFO: Fetching data to DataFrame
ℹ️ [19:36:29] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.52s
ℹ️ [19:36:29] root INFO: Fetching data to DataFrame
ℹ️ [19:36:29] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.32s
ℹ️ [19:36:29] root INFO: Fetching data to DataFrame
ℹ️ [19:36:30] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.76s
ℹ️ [19:36:30] root INFO: Fetching data to DataFrame
ℹ️ [19:36:30] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.33s
ℹ️ [19:36:30] root INFO: Fetching data to DataFrame
ℹ️ [19:36:31] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.60s
ℹ️ [19:36:31] root INFO: Fetching data to DataFrame
ℹ️ [19:36:31] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.53s
ℹ️ [19:36:31] root INFO: Waterfall report for 'customer_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id.xlsx
ℹ️ [19:36:32] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [19:36:32] root INFO: Fetching data to DataFrame
ℹ️ [19:36:32] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.40s
ℹ️ [19:36:32] root INFO: Fetching data to DataFrame
ℹ️ [19:36:32] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
ℹ️ [19:36:32] root INFO: Fetching data to DataFrame
ℹ️ [19:36:33] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.53s
ℹ️ [19:36:33] root INFO: Fetching data to DataFrame
ℹ️ [19:36:33] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [19:36:33] root INFO: Fetching data to DataFrame
ℹ️ [19:36:34] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.55s
ℹ️ [19:36:34] root INFO: Fetching data to DataFrame
ℹ️ [19:36:34] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.57s
ℹ️ [19:36:34] root INFO: Waterfall report for 'customer_id_account_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id_account_id.xlsx
ℹ️ [19:36:34] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [19:36:34] root INFO: Fetching data to DataFrame
ℹ️ [19:36:35] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.36s
ℹ️ [19:36:35] root INFO: Fetching data to DataFrame
ℹ️ [19:36:35] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.23s
ℹ️ [19:36:35] root INFO: Fetching data to DataFrame
ℹ️ [19:36:35] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.29s
ℹ️ [19:36:35] root INFO: Fetching data to DataFrame
ℹ️ [19:36:35] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [19:36:35] root INFO: Fetching data to DataFrame
ℹ️ [19:36:36] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.30s
ℹ️ [19:36:36] root INFO: Fetching data to DataFrame
ℹ️ [19:36:36] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.31s
ℹ️ [19:36:36] root INFO: Waterfall report for 'region_id_segment_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_region_id_segment_id.xlsx
ℹ️ [19:36:36] root INFO: Using cached output steps.
ℹ️ [19:36:36] root INFO: Running output job for channel email
ℹ️ [19:36:36] root INFO: Fetching data to DataFrame
ℹ️ [19:36:36] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [19:36:36] root INFO: Fetched 17 rows for channel email
ℹ️ [19:36:36] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [19:36:36] root INFO: Running output job for channel sms
ℹ️ [19:36:36] root INFO: Fetching data to DataFrame
ℹ️ [19:36:36] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.14s
ℹ️ [19:36:36] root INFO: Fetched 8 rows for channel sms
ℹ️ [19:36:36] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [19:36:36] root INFO: Running output job for channel push
ℹ️ [19:36:36] root INFO: Fetching data to DataFrame
ℹ️ [19:36:37] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [19:36:37] root INFO: Fetched 17 rows for channel push
ℹ️ [19:36:37] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [19:36:37] root INFO: Cleaning up DB connection
ℹ️ [19:55:45] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [19:55:45] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [19:55:45] root INFO: Calculation complete: 3 steps.
ℹ️ [19:55:45] root INFO: Calculating the number of waterfall steps.
ℹ️ [19:55:45] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [19:55:45] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [19:55:45] root INFO: Calculating the number of output steps.
ℹ️ [19:55:45] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [19:55:45] root INFO: Preparing logic for channel 'email'
ℹ️ [19:55:45] root INFO: Preparing logic for channel 'sms'
ℹ️ [19:55:45] root INFO: Preparing logic for channel 'push'
ℹ️ [19:55:45] root INFO: Calculation complete: 3 steps (files).
ℹ️ [19:55:45] root INFO: Using cached SQL statements.
ℹ️ [19:55:45] root INFO: Dropping existing table eligibility_poc
ℹ️ [19:55:45] root INFO: Executing SQL statement
ℹ️ [19:55:46] root INFO: SQL execution finished in 0.90s
ℹ️ [19:55:46] root INFO: Executing eligibility SQL statement
ℹ️ [19:55:46] root INFO: Executing SQL statement
ℹ️ [19:55:47] root INFO: SQL execution finished in 0.46s
ℹ️ [19:55:47] root INFO: Executing eligibility SQL statement
ℹ️ [19:55:47] root INFO: Executing SQL statement
ℹ️ [19:55:47] root INFO: SQL execution finished in 0.17s
ℹ️ [19:55:47] root INFO: Using cached waterfall steps.
ℹ️ [19:55:47] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [19:55:47] root INFO: Fetching data to DataFrame
ℹ️ [19:55:47] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.47s
ℹ️ [19:55:47] root INFO: Fetching data to DataFrame
ℹ️ [19:55:48] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.28s
ℹ️ [19:55:48] root INFO: Fetching data to DataFrame
ℹ️ [19:55:48] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.54s
ℹ️ [19:55:48] root INFO: Fetching data to DataFrame
ℹ️ [19:55:49] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.26s
ℹ️ [19:55:49] root INFO: Fetching data to DataFrame
ℹ️ [19:55:49] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.56s
ℹ️ [19:55:49] root INFO: Fetching data to DataFrame
ℹ️ [19:55:50] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.69s
ℹ️ [19:55:50] root INFO: Waterfall report for 'customer_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id.xlsx
ℹ️ [19:55:50] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [19:55:50] root INFO: Fetching data to DataFrame
ℹ️ [19:55:50] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.53s
ℹ️ [19:55:50] root INFO: Fetching data to DataFrame
ℹ️ [19:55:51] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.32s
ℹ️ [19:55:51] root INFO: Fetching data to DataFrame
ℹ️ [19:55:51] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.53s
ℹ️ [19:55:51] root INFO: Fetching data to DataFrame
ℹ️ [19:55:52] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.24s
ℹ️ [19:55:52] root INFO: Fetching data to DataFrame
ℹ️ [19:55:52] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.53s
ℹ️ [19:55:52] root INFO: Fetching data to DataFrame
ℹ️ [19:55:53] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.54s
ℹ️ [19:55:53] root INFO: Waterfall report for 'customer_id_account_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id_account_id.xlsx
ℹ️ [19:55:53] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [19:55:53] root INFO: Fetching data to DataFrame
ℹ️ [19:55:53] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.36s
ℹ️ [19:55:53] root INFO: Fetching data to DataFrame
ℹ️ [19:55:53] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [19:55:53] root INFO: Fetching data to DataFrame
ℹ️ [19:55:54] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.33s
ℹ️ [19:55:54] root INFO: Fetching data to DataFrame
ℹ️ [19:55:54] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [19:55:54] root INFO: Fetching data to DataFrame
ℹ️ [19:55:54] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.31s
ℹ️ [19:55:54] root INFO: Fetching data to DataFrame
ℹ️ [19:55:55] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.31s
ℹ️ [19:55:55] root INFO: Waterfall report for 'region_id_segment_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_region_id_segment_id.xlsx
ℹ️ [19:55:55] root INFO: Using cached output steps.
ℹ️ [19:55:55] root INFO: Running output job for channel email
ℹ️ [19:55:55] root INFO: Fetching data to DataFrame
ℹ️ [19:55:55] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [19:55:55] root INFO: Fetched 17 rows for channel email
ℹ️ [19:55:55] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [19:55:55] root INFO: Running output job for channel sms
ℹ️ [19:55:55] root INFO: Fetching data to DataFrame
ℹ️ [19:55:55] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.14s
ℹ️ [19:55:55] root INFO: Fetched 8 rows for channel sms
ℹ️ [19:55:55] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [19:55:55] root INFO: Running output job for channel push
ℹ️ [19:55:55] root INFO: Fetching data to DataFrame
ℹ️ [19:55:55] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [19:55:55] root INFO: Fetched 17 rows for channel push
ℹ️ [19:55:55] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [19:55:55] root INFO: Cleaning up DB connection
ℹ️ [22:23:46] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [22:23:46] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [22:23:47] root INFO: Calculation complete: 3 steps.
ℹ️ [22:23:47] root INFO: Calculating the number of waterfall steps.
ℹ️ [22:23:47] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [22:23:47] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [22:23:47] root INFO: Calculating the number of output steps.
ℹ️ [22:23:47] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [22:23:47] root INFO: Preparing logic for channel 'email'
ℹ️ [22:23:47] root INFO: Preparing logic for channel 'sms'
ℹ️ [22:23:47] root INFO: Preparing logic for channel 'push'
ℹ️ [22:23:47] root INFO: Calculation complete: 3 steps (files).
ℹ️ [22:23:47] root INFO: Using cached SQL statements.
ℹ️ [22:23:47] root INFO: Dropping existing table eligibility_poc
ℹ️ [22:23:47] root INFO: Executing SQL statement
ℹ️ [22:23:59] root INFO: No existing eligibility table to drop
ℹ️ [22:23:59] root INFO: Executing eligibility SQL statement
ℹ️ [22:23:59] root INFO: Executing SQL statement
ℹ️ [22:25:15] root INFO: Calculating the number of steps for the eligibility run.
ℹ️ [22:25:15] root INFO: No cached SQL found. Generating new SQL statements.
ℹ️ [22:25:15] root INFO: Calculation complete: 3 steps.
ℹ️ [22:25:15] root INFO: Calculating the number of waterfall steps.
ℹ️ [22:25:15] root INFO: No cached steps found. Preparing waterfall groups and SQL.
ℹ️ [22:25:15] root INFO: Calculation complete: 3 steps (reports).
ℹ️ [22:25:15] root INFO: Calculating the number of output steps.
ℹ️ [22:25:15] root INFO: No cached steps found. Preparing output jobs and SQL.
ℹ️ [22:25:15] root INFO: Preparing logic for channel 'email'
ℹ️ [22:25:15] root INFO: Preparing logic for channel 'sms'
ℹ️ [22:25:15] root INFO: Preparing logic for channel 'push'
ℹ️ [22:25:15] root INFO: Calculation complete: 3 steps (files).
ℹ️ [22:25:15] root INFO: Using cached SQL statements.
ℹ️ [22:25:15] root INFO: Dropping existing table eligibility_poc
ℹ️ [22:25:15] root INFO: Executing SQL statement
ℹ️ [22:25:16] root INFO: SQL execution finished in 1.30s
ℹ️ [22:25:16] root INFO: Executing eligibility SQL statement
ℹ️ [22:25:16] root INFO: Executing SQL statement
ℹ️ [22:25:17] root INFO: SQL execution finished in 1.13s
ℹ️ [22:25:18] root INFO: Executing eligibility SQL statement
ℹ️ [22:25:18] root INFO: Executing SQL statement
ℹ️ [22:25:18] root INFO: SQL execution finished in 0.17s
ℹ️ [22:25:18] root INFO: Using cached waterfall steps.
ℹ️ [22:25:18] root INFO: Processing waterfall grouping 'customer_id'
ℹ️ [22:25:18] root INFO: Fetching data to DataFrame
ℹ️ [22:25:18] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.55s
ℹ️ [22:25:18] root INFO: Fetching data to DataFrame
ℹ️ [22:25:19] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.25s
ℹ️ [22:25:19] root INFO: Fetching data to DataFrame
ℹ️ [22:25:19] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.57s
ℹ️ [22:25:19] root INFO: Fetching data to DataFrame
ℹ️ [22:25:19] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
ℹ️ [22:25:19] root INFO: Fetching data to DataFrame
ℹ️ [22:25:20] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.72s
ℹ️ [22:25:20] root INFO: Fetching data to DataFrame
ℹ️ [22:25:21] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.75s
ℹ️ [22:25:21] root INFO: Waterfall report for 'customer_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id.xlsx
ℹ️ [22:25:21] root INFO: Processing waterfall grouping 'customer_id_account_id'
ℹ️ [22:25:21] root INFO: Fetching data to DataFrame
ℹ️ [22:25:22] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.44s
ℹ️ [22:25:22] root INFO: Fetching data to DataFrame
ℹ️ [22:25:22] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [22:25:22] root INFO: Fetching data to DataFrame
ℹ️ [22:25:22] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.58s
ℹ️ [22:25:22] root INFO: Fetching data to DataFrame
ℹ️ [22:25:23] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
ℹ️ [22:25:23] root INFO: Fetching data to DataFrame
ℹ️ [22:25:23] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.64s
ℹ️ [22:25:23] root INFO: Fetching data to DataFrame
ℹ️ [22:25:24] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.71s
ℹ️ [22:25:24] root INFO: Waterfall report for 'customer_id_account_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_customer_id_account_id.xlsx
ℹ️ [22:25:24] root INFO: Processing waterfall grouping 'region_id_segment_id'
ℹ️ [22:25:24] root INFO: Fetching data to DataFrame
ℹ️ [22:25:25] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.60s
ℹ️ [22:25:25] root INFO: Fetching data to DataFrame
ℹ️ [22:25:25] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.37s
ℹ️ [22:25:25] root INFO: Fetching data to DataFrame
ℹ️ [22:25:26] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.45s
ℹ️ [22:25:26] root INFO: Fetching data to DataFrame
ℹ️ [22:25:26] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.41s
ℹ️ [22:25:26] root INFO: Fetching data to DataFrame
ℹ️ [22:25:26] root INFO: Fetched DataFrame with 6 rows and 4 columns in 0.42s
ℹ️ [22:25:26] root INFO: Fetching data to DataFrame
ℹ️ [22:25:27] root INFO: Fetched DataFrame with 11 rows and 4 columns in 0.52s
ℹ️ [22:25:27] root INFO: Waterfall report for 'region_id_segment_id' saved to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_report_eligibility_poc_region_id_segment_id.xlsx
ℹ️ [22:25:27] root INFO: Using cached output steps.
ℹ️ [22:25:27] root INFO: Running output job for channel email
ℹ️ [22:25:27] root INFO: Fetching data to DataFrame
ℹ️ [22:25:27] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.18s
ℹ️ [22:25:27] root INFO: Fetched 17 rows for channel email
ℹ️ [22:25:27] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
ℹ️ [22:25:27] root INFO: Running output job for channel sms
ℹ️ [22:25:27] root INFO: Fetching data to DataFrame
ℹ️ [22:25:28] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.26s
ℹ️ [22:25:28] root INFO: Fetched 8 rows for channel sms
ℹ️ [22:25:28] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
ℹ️ [22:25:28] root INFO: Running output job for channel push
ℹ️ [22:25:28] root INFO: Fetching data to DataFrame
ℹ️ [22:25:28] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.34s
ℹ️ [22:25:28] root INFO: Fetched 17 rows for channel push
ℹ️ [22:25:28] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
ℹ️ [22:25:28] root INFO: Cleaning up DB connection
