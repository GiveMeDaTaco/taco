ℹ️ [13:58:28] root INFO: Dropping existing table eligibility_poc
ℹ️ [13:58:28] root INFO: Executing SQL:
ℹ️ [13:58:28] root INFO: DROP TABLE eligibility_poc;
ℹ️ [13:58:28] root INFO: SQL execution finished in 0.60s
ℹ️ [13:58:28] root INFO: Executing eligibility SQL statement
ℹ️ [13:58:28] root INFO: Executing SQL:
ℹ️ [13:58:28] root INFO: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [13:58:29] root INFO: SQL execution finished in 0.49s
ℹ️ [13:58:29] root INFO: Executing eligibility SQL statement
ℹ️ [13:58:29] root INFO: Executing SQL:
ℹ️ [13:58:29] root INFO: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [13:58:29] root INFO: SQL execution finished in 0.04s
ℹ️ [13:58:29] root INFO: Executing eligibility SQL statement
ℹ️ [13:58:29] root INFO: Executing SQL:
ℹ️ [13:58:29] root INFO: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [13:58:29] root INFO: SQL execution finished in 0.04s
ℹ️ [13:58:29] root INFO: Executing base waterfall SQL for grouping customer_id
ℹ️ [13:58:29] root INFO: Fetching data to DataFrame:
ℹ️ [13:58:29] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [13:58:29] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.22s
ℹ️ [13:58:29] root INFO: Executing waterfall SQL for channel email, grouping customer_id
ℹ️ [13:58:29] root INFO: Fetching data to DataFrame:
ℹ️ [13:58:29] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [13:58:29] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.17s
ℹ️ [13:58:29] root INFO: Executing waterfall SQL for channel sms, grouping customer_id
ℹ️ [13:58:29] root INFO: Fetching data to DataFrame:
ℹ️ [13:58:29] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [13:58:29] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.17s
ℹ️ [13:58:29] root INFO: Executing waterfall SQL for channel push, grouping customer_id
ℹ️ [13:58:29] root INFO: Fetching data to DataFrame:
ℹ️ [13:58:29] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [13:58:29] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.17s
ℹ️ [13:58:30] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [13:58:30] root INFO: Executing base waterfall SQL for grouping customer_id_account_id
ℹ️ [13:58:30] root INFO: Fetching data to DataFrame:
ℹ️ [13:58:30] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,a.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, a.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:20:26] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:20:26] root INFO: Executing SQL:
ℹ️ [15:20:26] root INFO: DROP TABLE eligibility_poc;
ℹ️ [15:20:27] root INFO: SQL execution finished in 0.69s
ℹ️ [15:20:27] root INFO: Executing eligibility SQL statement
ℹ️ [15:20:27] root INFO: Executing SQL:
ℹ️ [15:20:27] root INFO: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [15:20:28] root INFO: SQL execution finished in 0.51s
ℹ️ [15:20:28] root INFO: Executing eligibility SQL statement
ℹ️ [15:20:28] root INFO: Executing SQL:
ℹ️ [15:20:28] root INFO: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [15:20:28] root INFO: SQL execution finished in 0.04s
ℹ️ [15:20:28] root INFO: Executing eligibility SQL statement
ℹ️ [15:20:28] root INFO: Executing SQL:
ℹ️ [15:20:28] root INFO: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [15:20:28] root INFO: SQL execution finished in 0.04s
ℹ️ [15:20:28] root INFO: Executing base waterfall SQL for grouping customer_id
ℹ️ [15:20:28] root INFO: Fetching data to DataFrame:
ℹ️ [15:20:28] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:20:28] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.39s
ℹ️ [15:20:28] root INFO: Executing waterfall SQL for channel email, grouping customer_id
ℹ️ [15:20:28] root INFO: Fetching data to DataFrame:
ℹ️ [15:20:28] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [15:20:28] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.23s
ℹ️ [15:20:28] root INFO: Executing waterfall SQL for channel sms, grouping customer_id
ℹ️ [15:20:28] root INFO: Fetching data to DataFrame:
ℹ️ [15:20:28] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [15:20:29] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.23s
ℹ️ [15:20:29] root INFO: Executing waterfall SQL for channel push, grouping customer_id
ℹ️ [15:20:29] root INFO: Fetching data to DataFrame:
ℹ️ [15:20:29] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [15:20:29] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.13s
ℹ️ [15:20:29] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [15:20:29] root INFO: Executing base waterfall SQL for grouping customer_id_account_id
ℹ️ [15:20:29] root INFO: Fetching data to DataFrame:
ℹ️ [15:20:29] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,a.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, a.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:21:40] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:21:40] root INFO: Executing SQL:
ℹ️ [15:21:40] root INFO: DROP TABLE eligibility_poc;
ℹ️ [15:21:41] root INFO: SQL execution finished in 0.57s
ℹ️ [15:21:41] root INFO: Executing eligibility SQL statement
ℹ️ [15:21:41] root INFO: Executing SQL:
ℹ️ [15:21:41] root INFO: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [15:21:41] root INFO: SQL execution finished in 0.39s
ℹ️ [15:21:41] root INFO: Executing eligibility SQL statement
ℹ️ [15:21:41] root INFO: Executing SQL:
ℹ️ [15:21:41] root INFO: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [15:21:41] root INFO: SQL execution finished in 0.02s
ℹ️ [15:21:41] root INFO: Executing eligibility SQL statement
ℹ️ [15:21:41] root INFO: Executing SQL:
ℹ️ [15:21:41] root INFO: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [15:21:41] root INFO: SQL execution finished in 0.04s
ℹ️ [15:21:41] root INFO: Executing base waterfall SQL for grouping customer_id
ℹ️ [15:21:41] root INFO: Fetching data to DataFrame:
ℹ️ [15:21:41] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:21:41] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.20s
ℹ️ [15:21:41] root INFO: Executing waterfall SQL for channel email, grouping customer_id
ℹ️ [15:21:41] root INFO: Fetching data to DataFrame:
ℹ️ [15:21:41] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [15:21:41] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.13s
ℹ️ [15:21:42] root INFO: Executing waterfall SQL for channel sms, grouping customer_id
ℹ️ [15:21:42] root INFO: Fetching data to DataFrame:
ℹ️ [15:21:42] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [15:21:42] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.15s
ℹ️ [15:21:42] root INFO: Executing waterfall SQL for channel push, grouping customer_id
ℹ️ [15:21:42] root INFO: Fetching data to DataFrame:
ℹ️ [15:21:42] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [15:21:42] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.13s
ℹ️ [15:21:42] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [15:21:42] root INFO: Executing base waterfall SQL for grouping customer_id_account_id
ℹ️ [15:21:42] root INFO: Fetching data to DataFrame:
ℹ️ [15:21:42] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,a.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, a.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:21:56] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:21:56] root INFO: Executing SQL:
ℹ️ [15:21:56] root INFO: DROP TABLE eligibility_poc;
ℹ️ [15:21:57] root INFO: SQL execution finished in 0.89s
ℹ️ [15:21:57] root INFO: Executing eligibility SQL statement
ℹ️ [15:21:57] root INFO: Executing SQL:
ℹ️ [15:21:57] root INFO: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [15:21:58] root INFO: SQL execution finished in 0.47s
ℹ️ [15:21:58] root INFO: Executing eligibility SQL statement
ℹ️ [15:21:58] root INFO: Executing SQL:
ℹ️ [15:21:58] root INFO: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [15:21:58] root INFO: SQL execution finished in 0.04s
ℹ️ [15:21:58] root INFO: Executing eligibility SQL statement
ℹ️ [15:21:58] root INFO: Executing SQL:
ℹ️ [15:21:58] root INFO: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [15:21:58] root INFO: SQL execution finished in 0.04s
ℹ️ [15:21:58] root INFO: Executing base waterfall SQL for grouping customer_id
ℹ️ [15:21:58] root INFO: Fetching data to DataFrame:
ℹ️ [15:21:58] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:21:58] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.21s
ℹ️ [15:21:58] root INFO: Executing waterfall SQL for channel email, grouping customer_id
ℹ️ [15:21:58] root INFO: Fetching data to DataFrame:
ℹ️ [15:21:58] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [15:21:58] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.13s
ℹ️ [15:21:58] root INFO: Executing waterfall SQL for channel sms, grouping customer_id
ℹ️ [15:21:58] root INFO: Fetching data to DataFrame:
ℹ️ [15:21:58] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [15:21:58] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.15s
ℹ️ [15:21:58] root INFO: Executing waterfall SQL for channel push, grouping customer_id
ℹ️ [15:21:58] root INFO: Fetching data to DataFrame:
ℹ️ [15:21:58] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [15:21:58] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.12s
ℹ️ [15:21:58] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [15:21:58] root INFO: Executing base waterfall SQL for grouping customer_id_account_id
ℹ️ [15:21:58] root INFO: Fetching data to DataFrame:
ℹ️ [15:21:58] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,a.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, a.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:22:40] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:22:40] root INFO: Executing SQL:
ℹ️ [15:22:40] root INFO: DROP TABLE eligibility_poc;
ℹ️ [15:22:41] root INFO: SQL execution finished in 0.55s
ℹ️ [15:22:41] root INFO: Executing eligibility SQL statement
ℹ️ [15:22:41] root INFO: Executing SQL:
ℹ️ [15:22:41] root INFO: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [15:22:41] root INFO: SQL execution finished in 0.43s
ℹ️ [15:22:41] root INFO: Executing eligibility SQL statement
ℹ️ [15:22:41] root INFO: Executing SQL:
ℹ️ [15:22:41] root INFO: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [15:22:41] root INFO: SQL execution finished in 0.04s
ℹ️ [15:22:41] root INFO: Executing eligibility SQL statement
ℹ️ [15:22:41] root INFO: Executing SQL:
ℹ️ [15:22:41] root INFO: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [15:22:41] root INFO: SQL execution finished in 0.04s
ℹ️ [15:22:41] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [15:22:41] root INFO: Executing base waterfall SQL for grouping customer_id
ℹ️ [15:22:41] root INFO: Fetching data to DataFrame:
ℹ️ [15:22:41] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:22:41] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.20s
ℹ️ [15:22:41] root INFO: Executing waterfall SQL for channel email, grouping customer_id
ℹ️ [15:22:41] root INFO: Fetching data to DataFrame:
ℹ️ [15:22:41] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [15:22:42] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.15s
ℹ️ [15:22:42] root INFO: Executing waterfall SQL for channel sms, grouping customer_id
ℹ️ [15:22:42] root INFO: Fetching data to DataFrame:
ℹ️ [15:22:42] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [15:22:42] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.15s
ℹ️ [15:22:42] root INFO: Executing waterfall SQL for channel push, grouping customer_id
ℹ️ [15:22:42] root INFO: Fetching data to DataFrame:
ℹ️ [15:22:42] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [15:22:42] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.12s
ℹ️ [15:22:42] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [15:22:42] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [15:22:42] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [15:22:42] root INFO: Executing base waterfall SQL for grouping customer_id_account_id
ℹ️ [15:22:42] root INFO: Fetching data to DataFrame:
ℹ️ [15:22:42] root INFO: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,a.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, a.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:24:55] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:24:55] root INFO: Executing SQL statement
🐛 [15:24:55] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [15:24:55] root INFO: SQL execution finished in 0.57s
ℹ️ [15:24:55] root INFO: Executing eligibility SQL statement
ℹ️ [15:24:55] root INFO: Executing SQL statement
🐛 [15:24:55] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [15:24:56] root INFO: SQL execution finished in 0.40s
ℹ️ [15:24:56] root INFO: Executing eligibility SQL statement
ℹ️ [15:24:56] root INFO: Executing SQL statement
🐛 [15:24:56] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [15:24:56] root INFO: SQL execution finished in 0.04s
ℹ️ [15:24:56] root INFO: Executing eligibility SQL statement
ℹ️ [15:24:56] root INFO: Executing SQL statement
🐛 [15:24:56] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [15:24:56] root INFO: SQL execution finished in 0.04s
ℹ️ [15:24:56] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [15:24:56] root INFO: Executing base waterfall SQL for grouping customer_id
ℹ️ [15:24:56] root INFO: Fetching data to DataFrame
🐛 [15:24:56] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:24:56] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.20s
ℹ️ [15:24:56] root INFO: Executing waterfall SQL for channel email, grouping customer_id
ℹ️ [15:24:56] root INFO: Fetching data to DataFrame
🐛 [15:24:56] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [15:24:56] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.12s
ℹ️ [15:24:56] root INFO: Executing waterfall SQL for channel sms, grouping customer_id
ℹ️ [15:24:56] root INFO: Fetching data to DataFrame
🐛 [15:24:56] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [15:24:56] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [15:24:56] root INFO: Executing waterfall SQL for channel push, grouping customer_id
ℹ️ [15:24:56] root INFO: Fetching data to DataFrame
🐛 [15:24:56] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [15:24:56] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.12s
ℹ️ [15:24:56] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [15:24:56] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [15:24:56] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [15:24:56] root INFO: Executing base waterfall SQL for grouping customer_id_account_id
ℹ️ [15:24:56] root INFO: Fetching data to DataFrame
🐛 [15:24:56] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,a.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, a.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:25:52] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:25:52] root INFO: Executing SQL statement
🐛 [15:25:52] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [15:25:52] root INFO: SQL execution finished in 0.67s
ℹ️ [15:25:52] root INFO: Executing eligibility SQL statement
ℹ️ [15:25:52] root INFO: Executing SQL statement
🐛 [15:25:52] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [15:25:53] root INFO: SQL execution finished in 0.43s
ℹ️ [15:25:53] root INFO: Executing eligibility SQL statement
ℹ️ [15:25:53] root INFO: Executing SQL statement
🐛 [15:25:53] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [15:25:53] root INFO: SQL execution finished in 0.04s
ℹ️ [15:25:53] root INFO: Executing eligibility SQL statement
ℹ️ [15:25:53] root INFO: Executing SQL statement
🐛 [15:25:53] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [15:25:53] root INFO: SQL execution finished in 0.04s
ℹ️ [15:25:53] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [15:25:53] root INFO: Executing base waterfall SQL for grouping customer_id
ℹ️ [15:25:53] root INFO: Fetching data to DataFrame
🐛 [15:25:53] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:25:53] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.25s
ℹ️ [15:25:53] root INFO: Executing waterfall SQL for channel email, grouping customer_id
ℹ️ [15:25:53] root INFO: Fetching data to DataFrame
🐛 [15:25:53] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [15:25:53] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.19s
ℹ️ [15:25:53] root INFO: Executing waterfall SQL for channel sms, grouping customer_id
ℹ️ [15:25:53] root INFO: Fetching data to DataFrame
🐛 [15:25:53] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [15:25:53] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.33s
ℹ️ [15:25:53] root INFO: Executing waterfall SQL for channel push, grouping customer_id
ℹ️ [15:25:53] root INFO: Fetching data to DataFrame
🐛 [15:25:53] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [15:25:54] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.23s
ℹ️ [15:25:54] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [15:25:54] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [15:25:54] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [15:25:54] root INFO: Executing base waterfall SQL for grouping customer_id_account_id
ℹ️ [15:25:54] root INFO: Fetching data to DataFrame
🐛 [15:25:54] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,a.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, a.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:27:54] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:27:54] root INFO: Executing SQL statement
🐛 [15:27:54] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [15:27:54] root INFO: SQL execution finished in 0.61s
ℹ️ [15:27:54] root INFO: Executing eligibility SQL statement
ℹ️ [15:27:54] root INFO: Executing SQL statement
🐛 [15:27:54] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [15:27:55] root INFO: SQL execution finished in 0.44s
ℹ️ [15:27:55] root INFO: Executing eligibility SQL statement
ℹ️ [15:27:55] root INFO: Executing SQL statement
🐛 [15:27:55] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [15:27:55] root INFO: SQL execution finished in 0.04s
ℹ️ [15:27:55] root INFO: Executing eligibility SQL statement
ℹ️ [15:27:55] root INFO: Executing SQL statement
🐛 [15:27:55] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [15:27:55] root INFO: SQL execution finished in 0.04s
ℹ️ [15:27:55] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [15:27:55] root INFO: Executing base waterfall SQL for grouping customer_id
ℹ️ [15:27:55] root INFO: Fetching data to DataFrame
🐛 [15:27:55] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:27:55] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.22s
ℹ️ [15:27:55] root INFO: Executing waterfall SQL for channel email, grouping customer_id
ℹ️ [15:27:55] root INFO: Fetching data to DataFrame
🐛 [15:27:55] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [15:27:55] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [15:27:55] root INFO: Executing waterfall SQL for channel sms, grouping customer_id
ℹ️ [15:27:55] root INFO: Fetching data to DataFrame
🐛 [15:27:55] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [15:27:55] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [15:27:55] root INFO: Executing waterfall SQL for channel push, grouping customer_id
ℹ️ [15:27:55] root INFO: Fetching data to DataFrame
🐛 [15:27:55] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [15:27:55] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.12s
ℹ️ [15:27:55] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [15:27:55] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [15:27:55] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [15:27:55] root INFO: Executing base waterfall SQL for grouping customer_id_account_id
ℹ️ [15:27:55] root INFO: Fetching data to DataFrame
🐛 [15:27:55] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,a.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, a.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:28:06] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:28:06] root INFO: Executing SQL statement
🐛 [15:28:06] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [15:28:06] root INFO: SQL execution finished in 0.53s
ℹ️ [15:28:06] root INFO: Executing eligibility SQL statement
ℹ️ [15:28:06] root INFO: Executing SQL statement
🐛 [15:28:06] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [15:28:07] root INFO: SQL execution finished in 0.51s
ℹ️ [15:28:07] root INFO: Executing eligibility SQL statement
ℹ️ [15:28:07] root INFO: Executing SQL statement
🐛 [15:28:07] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [15:28:07] root INFO: SQL execution finished in 0.04s
ℹ️ [15:28:07] root INFO: Executing eligibility SQL statement
ℹ️ [15:28:07] root INFO: Executing SQL statement
🐛 [15:28:07] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [15:28:07] root INFO: SQL execution finished in 0.04s
ℹ️ [15:28:07] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [15:28:07] root INFO: Executing base waterfall SQL for grouping customer_id
ℹ️ [15:28:07] root INFO: Fetching data to DataFrame
🐛 [15:28:07] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:28:07] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.35s
ℹ️ [15:28:07] root INFO: Executing waterfall SQL for channel email, grouping customer_id
ℹ️ [15:28:07] root INFO: Fetching data to DataFrame
🐛 [15:28:07] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [15:28:08] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.29s
ℹ️ [15:28:08] root INFO: Executing waterfall SQL for channel sms, grouping customer_id
ℹ️ [15:28:08] root INFO: Fetching data to DataFrame
🐛 [15:28:08] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [15:28:08] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.15s
ℹ️ [15:28:08] root INFO: Executing waterfall SQL for channel push, grouping customer_id
ℹ️ [15:28:08] root INFO: Fetching data to DataFrame
🐛 [15:28:08] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [15:28:08] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.13s
ℹ️ [15:28:08] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [15:28:08] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [15:28:08] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [15:28:08] root INFO: Executing base waterfall SQL for grouping customer_id_account_id
ℹ️ [15:28:08] root INFO: Fetching data to DataFrame
🐛 [15:28:08] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,a.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, a.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:28:49] root INFO: Dropping existing table eligibility_poc
ℹ️ [15:28:49] root INFO: Executing SQL statement
🐛 [15:28:49] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [15:28:50] root INFO: SQL execution finished in 0.60s
ℹ️ [15:28:50] root INFO: Executing eligibility SQL statement
ℹ️ [15:28:50] root INFO: Executing SQL statement
🐛 [15:28:50] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [15:28:50] root INFO: SQL execution finished in 0.40s
ℹ️ [15:28:50] root INFO: Executing eligibility SQL statement
ℹ️ [15:28:50] root INFO: Executing SQL statement
🐛 [15:28:50] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [15:28:50] root INFO: SQL execution finished in 0.04s
ℹ️ [15:28:50] root INFO: Executing eligibility SQL statement
ℹ️ [15:28:50] root INFO: Executing SQL statement
🐛 [15:28:50] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [15:28:50] root INFO: SQL execution finished in 0.04s
ℹ️ [15:28:50] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [15:28:50] root INFO: Executing base waterfall SQL for grouping customer_id
ℹ️ [15:28:50] root INFO: Fetching data to DataFrame
🐛 [15:28:50] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [15:28:51] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.25s
ℹ️ [15:28:51] root INFO: Executing waterfall SQL for channel email, grouping customer_id
ℹ️ [15:28:51] root INFO: Fetching data to DataFrame
🐛 [15:28:51] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [15:28:51] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.22s
ℹ️ [15:28:51] root INFO: Executing waterfall SQL for channel sms, grouping customer_id
ℹ️ [15:28:51] root INFO: Fetching data to DataFrame
🐛 [15:28:51] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [15:28:51] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.28s
ℹ️ [15:28:51] root INFO: Executing waterfall SQL for channel push, grouping customer_id
ℹ️ [15:28:51] root INFO: Fetching data to DataFrame
🐛 [15:28:51] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [15:28:51] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.26s
ℹ️ [15:28:52] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [15:28:52] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [15:28:52] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [15:28:52] root INFO: Executing base waterfall SQL for grouping customer_id_account_id
ℹ️ [15:28:52] root INFO: Fetching data to DataFrame
🐛 [15:28:52] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,a.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, a.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [16:25:49] root INFO: Dropping existing table eligibility_poc
ℹ️ [16:25:49] root INFO: Executing SQL statement
🐛 [16:25:49] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [16:25:50] root INFO: SQL execution finished in 0.73s
ℹ️ [16:25:50] root INFO: Executing eligibility SQL statement
ℹ️ [16:25:50] root INFO: Executing SQL statement
🐛 [16:25:50] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [16:25:50] root INFO: SQL execution finished in 0.47s
ℹ️ [16:25:50] root INFO: Executing eligibility SQL statement
ℹ️ [16:25:50] root INFO: Executing SQL statement
🐛 [16:25:50] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [16:25:50] root INFO: SQL execution finished in 0.04s
ℹ️ [16:25:50] root INFO: Executing eligibility SQL statement
ℹ️ [16:25:50] root INFO: Executing SQL statement
🐛 [16:25:50] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [16:25:50] root INFO: SQL execution finished in 0.04s
ℹ️ [16:25:50] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [16:25:50] root INFO: Fetching data to DataFrame
🐛 [16:25:50] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [16:25:50] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.23s
ℹ️ [16:25:50] root INFO: Fetching data to DataFrame
🐛 [16:25:50] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [16:25:50] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [16:25:50] root INFO: Fetching data to DataFrame
🐛 [16:25:50] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [16:25:51] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [16:25:51] root INFO: Fetching data to DataFrame
🐛 [16:25:51] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [16:25:51] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [16:25:51] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [16:25:51] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [16:25:51] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [16:25:51] root INFO: Fetching data to DataFrame
🐛 [16:25:51] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,a.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, a.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
❌ [16:25:51] root ERROR: Waterfall grouping 'customer_id_account_id' failed
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1161] [Teradata Database] [Error 3807] Object 'a' does not exist.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 110, in run
    df_base = self.runner.to_df(gen.render('waterfall_full.sql.j2', ctx_base))
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 53, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,a.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, a.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;': [Version 20.0.0.32] [Session 1161] [Teradata Database] [Error 3807] Object 'a' does not exist.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:25:51] root INFO: Finished waterfall grouping 'customer_id_account_id'
ℹ️ [16:25:51] root INFO: Starting waterfall grouping 'region_id_segment_id'
ℹ️ [16:25:51] root INFO: Fetching data to DataFrame
🐛 [16:25:51] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    r.region_id,s.segment_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY r.region_id, s.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
❌ [16:25:51] root ERROR: Waterfall grouping 'region_id_segment_id' failed
Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2664, in execute
    cur.execute(sql, *args)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 755, in execute
    self.executemany (sOperation, None, ignoreErrors)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/teradatasql/__init__.py", line 1010, in executemany
    raise OperationalError (sErr)
teradatasql.OperationalError: [Version 20.0.0.32] [Session 1161] [Teradata Database] [Error 3807] Object 'r' does not exist.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/taco/projects/recodeWaterfall/tlptaco/engines/waterfall.py", line 110, in run
    df_base = self.runner.to_df(gen.render('waterfall_full.sql.j2', ctx_base))
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/runner.py", line 40, in to_df
    df = self.conn.to_df(sql)
  File "/home/taco/projects/recodeWaterfall/tlptaco/db/connection.py", line 53, in to_df
    return pd.read_sql(sql, self.conn)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 708, in read_sql
    return pandas_sql.read_query(
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2728, in read_query
    cursor = self.execute(sql, params)
  File "/home/taco/projects/recodeWaterfall/venv/lib/python3.10/site-packages/pandas/io/sql.py", line 2676, in execute
    raise ex from exc
pandas.errors.DatabaseError: Execution failed on sql '-- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    r.region_id,s.segment_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY r.region_id, s.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;': [Version 20.0.0.32] [Session 1161] [Teradata Database] [Error 3807] Object 'r' does not exist.
 at gosqldriver/teradatasql.formatError ErrorUtil.go:85
 at gosqldriver/teradatasql.(*teradataConnection).formatDatabaseError ErrorUtil.go:223
 at gosqldriver/teradatasql.(*teradataConnection).makeChainedDatabaseError ErrorUtil.go:239
 at gosqldriver/teradatasql.(*teradataConnection).processErrorParcel TeradataConnection.go:816
 at gosqldriver/teradatasql.(*TeradataRows).processResponseBundle TeradataRows.go:2494
 at gosqldriver/teradatasql.(*TeradataRows).executeSQLRequest TeradataRows.go:970
 at gosqldriver/teradatasql.newTeradataRows TeradataRows.go:791
 at gosqldriver/teradatasql.(*teradataStatement).QueryContext TeradataStatement.go:122
 at gosqldriver/teradatasql.(*teradataConnection).QueryContext TeradataConnection.go:1335
 at database/sql.ctxDriverQuery ctxutil.go:48
 at database/sql.(*DB).queryDC.func1 sql.go:1786
 at database/sql.withLock sql.go:3574
 at database/sql.(*DB).queryDC sql.go:1781
 at database/sql.(*Conn).QueryContext sql.go:2037
 at main.createRows goside.go:1080
 at main.goCreateRows goside.go:959
 at _cgoexp_ff5e33a08e40_goCreateRows _cgo_gotypes.go:417
 at runtime.cgocallbackg1 cgocall.go:446
 at runtime.cgocallbackg cgocall.go:350
 at runtime.cgocallback asm_amd64.s:1084
 at runtime.goexit asm_amd64.s:1700
ℹ️ [16:25:51] root INFO: Finished waterfall grouping 'region_id_segment_id'
ℹ️ [16:25:51] root INFO: Running output SQL for channel email
🐛 [16:25:51] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [16:25:51] root INFO: Fetching data to DataFrame
🐛 [16:25:51] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [16:25:51] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.08s
ℹ️ [16:25:51] root INFO: Fetched 2 rows for channel email
ℹ️ [16:25:51] root INFO: Writing output file for channel email to reports/poc/email/email_list.csv
ℹ️ [16:25:51] root INFO: Output file saved to reports/poc/email/email_list.csv (2 rows, 5 columns)
ℹ️ [16:25:51] root INFO: Running output SQL for channel sms
🐛 [16:25:51] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [16:25:51] root INFO: Fetching data to DataFrame
🐛 [16:25:51] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [16:25:51] root INFO: Fetched DataFrame with 12 rows and 5 columns in 0.08s
ℹ️ [16:25:51] root INFO: Fetched 2 rows for channel sms
ℹ️ [16:25:51] root INFO: Writing output file for channel sms to reports/poc/sms/sms_list.parquet
ℹ️ [16:25:51] root INFO: Output file saved to reports/poc/sms/sms_list.parquet (2 rows, 5 columns)
ℹ️ [16:25:51] root INFO: Running output SQL for channel push
🐛 [16:25:51] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [16:25:51] root INFO: Fetching data to DataFrame
🐛 [16:25:51] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [16:25:51] root INFO: Fetched DataFrame with 2 rows and 5 columns in 0.08s
ℹ️ [16:25:51] root INFO: Fetched 1 rows for channel push
ℹ️ [16:25:51] root INFO: Writing output file for channel push to reports/poc/push/push_list.excel
ℹ️ [16:26:35] root INFO: Dropping existing table eligibility_poc
ℹ️ [16:26:35] root INFO: Executing SQL statement
🐛 [16:26:35] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [16:26:36] root INFO: SQL execution finished in 0.64s
ℹ️ [16:26:36] root INFO: Executing eligibility SQL statement
ℹ️ [16:26:36] root INFO: Executing SQL statement
🐛 [16:26:36] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [16:26:37] root INFO: SQL execution finished in 0.43s
ℹ️ [16:26:37] root INFO: Executing eligibility SQL statement
ℹ️ [16:26:37] root INFO: Executing SQL statement
🐛 [16:26:37] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [16:26:37] root INFO: SQL execution finished in 0.04s
ℹ️ [16:26:37] root INFO: Executing eligibility SQL statement
ℹ️ [16:26:37] root INFO: Executing SQL statement
🐛 [16:26:37] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [16:26:37] root INFO: SQL execution finished in 0.04s
ℹ️ [16:26:37] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [16:26:37] root INFO: Fetching data to DataFrame
🐛 [16:26:37] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [16:26:37] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.24s
ℹ️ [16:26:37] root INFO: Fetching data to DataFrame
🐛 [16:26:37] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [16:26:37] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [16:26:37] root INFO: Fetching data to DataFrame
🐛 [16:26:37] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [16:26:37] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [16:26:37] root INFO: Fetching data to DataFrame
🐛 [16:26:37] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [16:26:37] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [16:26:37] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [16:26:37] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [16:26:37] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [16:26:37] root INFO: Fetching data to DataFrame
🐛 [16:26:37] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [16:26:38] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.16s
ℹ️ [16:26:38] root INFO: Fetching data to DataFrame
🐛 [16:26:38] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [16:26:38] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [16:26:38] root INFO: Fetching data to DataFrame
🐛 [16:26:38] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [16:26:38] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [16:26:38] root INFO: Fetching data to DataFrame
🐛 [16:26:38] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [16:26:38] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [16:26:38] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id_account_id.xlsx (12 rows, 6 columns)
ℹ️ [16:26:38] root INFO: Finished waterfall grouping 'customer_id_account_id'
ℹ️ [16:26:38] root INFO: Starting waterfall grouping 'region_id_segment_id'
ℹ️ [16:26:38] root INFO: Fetching data to DataFrame
🐛 [16:26:38] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [16:26:38] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.16s
ℹ️ [16:26:38] root INFO: Fetching data to DataFrame
🐛 [16:26:38] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [16:26:38] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [16:26:38] root INFO: Fetching data to DataFrame
🐛 [16:26:38] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [16:26:38] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [16:26:38] root INFO: Fetching data to DataFrame
🐛 [16:26:39] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [16:26:39] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [16:26:39] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_region_id_segment_id.xlsx (12 rows, 6 columns)
ℹ️ [16:26:39] root INFO: Finished waterfall grouping 'region_id_segment_id'
ℹ️ [16:26:39] root INFO: Running output SQL for channel email
🐛 [16:26:39] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [16:26:39] root INFO: Fetching data to DataFrame
🐛 [16:26:39] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [16:26:39] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.08s
ℹ️ [16:26:39] root INFO: Fetched 2 rows for channel email
ℹ️ [16:26:39] root INFO: Writing output file for channel email to reports/poc/email/email_list.csv
ℹ️ [16:26:39] root INFO: Output file saved to reports/poc/email/email_list.csv (2 rows, 5 columns)
ℹ️ [16:26:39] root INFO: Running output SQL for channel sms
🐛 [16:26:39] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [16:26:39] root INFO: Fetching data to DataFrame
🐛 [16:26:39] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [16:26:39] root INFO: Fetched DataFrame with 12 rows and 5 columns in 0.08s
ℹ️ [16:26:39] root INFO: Fetched 2 rows for channel sms
ℹ️ [16:26:39] root INFO: Writing output file for channel sms to reports/poc/sms/sms_list.parquet
ℹ️ [16:26:39] root INFO: Output file saved to reports/poc/sms/sms_list.parquet (2 rows, 5 columns)
ℹ️ [16:26:39] root INFO: Running output SQL for channel push
🐛 [16:26:39] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [16:26:39] root INFO: Fetching data to DataFrame
🐛 [16:26:39] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [16:26:39] root INFO: Fetched DataFrame with 2 rows and 5 columns in 0.08s
ℹ️ [16:26:39] root INFO: Fetched 1 rows for channel push
ℹ️ [16:26:39] root INFO: Writing output file for channel push to reports/poc/push/push_list.excel
ℹ️ [17:50:07] root INFO: Dropping existing table eligibility_poc
ℹ️ [17:50:07] root INFO: Executing SQL statement
🐛 [17:50:07] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [17:50:08] root INFO: SQL execution finished in 0.72s
ℹ️ [17:50:08] root INFO: Executing eligibility SQL statement
ℹ️ [17:50:08] root INFO: Executing SQL statement
🐛 [17:50:08] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [17:50:08] root INFO: SQL execution finished in 0.43s
ℹ️ [17:50:08] root INFO: Executing eligibility SQL statement
ℹ️ [17:50:08] root INFO: Executing SQL statement
🐛 [17:50:08] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [17:50:09] root INFO: SQL execution finished in 0.04s
ℹ️ [17:50:09] root INFO: Executing eligibility SQL statement
ℹ️ [17:50:09] root INFO: Executing SQL statement
🐛 [17:50:09] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [17:50:09] root INFO: SQL execution finished in 0.04s
ℹ️ [17:50:09] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [17:50:09] root INFO: Fetching data to DataFrame
🐛 [17:50:09] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [17:50:09] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.23s
ℹ️ [17:50:09] root INFO: Fetching data to DataFrame
🐛 [17:50:09] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [17:50:09] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [17:50:09] root INFO: Fetching data to DataFrame
🐛 [17:50:09] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [17:50:09] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [17:50:09] root INFO: Fetching data to DataFrame
🐛 [17:50:09] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [17:50:09] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [17:50:09] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [17:50:09] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [17:50:09] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [17:50:09] root INFO: Fetching data to DataFrame
🐛 [17:50:09] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [17:50:09] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.16s
ℹ️ [17:50:09] root INFO: Fetching data to DataFrame
🐛 [17:50:09] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [17:50:10] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [17:50:10] root INFO: Fetching data to DataFrame
🐛 [17:50:10] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [17:50:10] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [17:50:10] root INFO: Fetching data to DataFrame
🐛 [17:50:10] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [17:50:10] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [17:50:10] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id_account_id.xlsx (12 rows, 6 columns)
ℹ️ [17:50:10] root INFO: Finished waterfall grouping 'customer_id_account_id'
ℹ️ [17:50:10] root INFO: Starting waterfall grouping 'region_id_segment_id'
ℹ️ [17:50:10] root INFO: Fetching data to DataFrame
🐛 [17:50:10] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [17:50:10] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.14s
ℹ️ [17:50:10] root INFO: Fetching data to DataFrame
🐛 [17:50:10] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [17:50:10] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [17:50:10] root INFO: Fetching data to DataFrame
🐛 [17:50:10] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [17:50:10] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [17:50:10] root INFO: Fetching data to DataFrame
🐛 [17:50:10] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [17:50:11] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [17:50:11] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_region_id_segment_id.xlsx (12 rows, 6 columns)
ℹ️ [17:50:11] root INFO: Finished waterfall grouping 'region_id_segment_id'
ℹ️ [17:50:11] root INFO: Running output SQL for channel email
🐛 [17:50:11] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [17:50:11] root INFO: Fetching data to DataFrame
🐛 [17:50:11] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [17:50:11] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.08s
ℹ️ [17:50:11] root INFO: Fetched 2 rows for channel email
ℹ️ [17:50:11] root INFO: Writing output file for channel email to reports/poc/email/email_list.csv
ℹ️ [17:50:11] root INFO: Output file saved to reports/poc/email/email_list.csv (2 rows, 5 columns)
ℹ️ [17:50:11] root INFO: Running output SQL for channel sms
🐛 [17:50:11] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [17:50:11] root INFO: Fetching data to DataFrame
🐛 [17:50:11] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [17:50:11] root INFO: Fetched DataFrame with 12 rows and 5 columns in 0.12s
ℹ️ [17:50:11] root INFO: Fetched 2 rows for channel sms
ℹ️ [17:50:11] root INFO: Writing output file for channel sms to reports/poc/sms/sms_list.parquet
ℹ️ [17:50:11] root INFO: Output file saved to reports/poc/sms/sms_list.parquet (2 rows, 5 columns)
ℹ️ [17:50:11] root INFO: Running output SQL for channel push
🐛 [17:50:11] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [17:50:11] root INFO: Fetching data to DataFrame
🐛 [17:50:11] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [17:50:11] root INFO: Fetched DataFrame with 2 rows and 5 columns in 0.10s
ℹ️ [17:50:11] root INFO: Fetched 1 rows for channel push
ℹ️ [17:50:11] root INFO: Writing output file for channel push to reports/poc/push/push_list.excel
ℹ️ [18:08:15] root INFO: Dropping existing table eligibility_poc
ℹ️ [18:08:15] root INFO: Executing SQL statement
🐛 [18:08:15] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [18:08:15] root INFO: SQL execution finished in 0.70s
ℹ️ [18:08:15] root INFO: Executing eligibility SQL statement
ℹ️ [18:08:15] root INFO: Executing SQL statement
🐛 [18:08:15] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [18:08:16] root INFO: SQL execution finished in 0.43s
ℹ️ [18:08:16] root INFO: Executing eligibility SQL statement
ℹ️ [18:08:16] root INFO: Executing SQL statement
🐛 [18:08:16] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [18:08:16] root INFO: SQL execution finished in 0.04s
ℹ️ [18:08:16] root INFO: Executing eligibility SQL statement
ℹ️ [18:08:16] root INFO: Executing SQL statement
🐛 [18:08:16] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [18:08:16] root INFO: SQL execution finished in 0.04s
ℹ️ [18:18:14] root INFO: Dropping existing table eligibility_poc
ℹ️ [18:18:14] root INFO: Executing SQL statement
🐛 [18:18:14] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [18:18:15] root INFO: SQL execution finished in 0.72s
ℹ️ [18:18:15] root INFO: Executing eligibility SQL statement
ℹ️ [18:18:15] root INFO: Executing SQL statement
🐛 [18:18:15] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [18:18:16] root INFO: SQL execution finished in 0.83s
ℹ️ [18:18:16] root INFO: Executing eligibility SQL statement
ℹ️ [18:18:16] root INFO: Executing SQL statement
🐛 [18:18:16] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [18:18:16] root INFO: SQL execution finished in 0.04s
ℹ️ [18:18:16] root INFO: Executing eligibility SQL statement
ℹ️ [18:18:16] root INFO: Executing SQL statement
🐛 [18:18:16] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [18:18:16] root INFO: SQL execution finished in 0.04s
ℹ️ [18:18:16] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [18:18:16] root INFO: Fetching data to DataFrame
🐛 [18:18:16] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [18:18:16] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.22s
ℹ️ [18:18:16] root INFO: Fetching data to DataFrame
🐛 [18:18:16] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [18:18:16] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [18:18:16] root INFO: Fetching data to DataFrame
🐛 [18:18:16] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [18:18:16] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [18:18:16] root INFO: Fetching data to DataFrame
🐛 [18:18:16] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [18:18:16] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [18:18:16] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [18:18:16] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [18:18:16] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [18:18:16] root INFO: Fetching data to DataFrame
🐛 [18:18:16] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [18:18:17] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.14s
ℹ️ [18:18:17] root INFO: Fetching data to DataFrame
🐛 [18:18:17] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [18:18:17] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [18:18:17] root INFO: Fetching data to DataFrame
🐛 [18:18:17] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [18:18:17] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [18:18:17] root INFO: Fetching data to DataFrame
🐛 [18:18:17] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [18:18:17] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [18:18:17] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id_account_id.xlsx (12 rows, 6 columns)
ℹ️ [18:18:17] root INFO: Finished waterfall grouping 'customer_id_account_id'
ℹ️ [18:18:17] root INFO: Starting waterfall grouping 'region_id_segment_id'
ℹ️ [18:18:17] root INFO: Fetching data to DataFrame
🐛 [18:18:17] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [18:18:17] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.16s
ℹ️ [18:18:17] root INFO: Fetching data to DataFrame
🐛 [18:18:17] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [18:18:17] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [18:18:17] root INFO: Fetching data to DataFrame
🐛 [18:18:17] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [18:18:18] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [18:18:18] root INFO: Fetching data to DataFrame
🐛 [18:18:18] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [18:18:18] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.16s
ℹ️ [18:18:18] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_region_id_segment_id.xlsx (12 rows, 6 columns)
ℹ️ [18:18:18] root INFO: Finished waterfall grouping 'region_id_segment_id'
ℹ️ [18:18:18] root INFO: Running output SQL for channel email
🐛 [18:18:18] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [18:18:18] root INFO: Fetching data to DataFrame
🐛 [18:18:18] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [18:18:18] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.10s
ℹ️ [18:18:18] root INFO: Fetched 2 rows for channel email
ℹ️ [18:18:18] root INFO: Writing output file for channel email to reports/poc/email/email_list.csv
ℹ️ [18:18:18] root INFO: Output file saved to reports/poc/email/email_list.csv (2 rows, 5 columns)
ℹ️ [18:18:18] root INFO: Running output SQL for channel sms
🐛 [18:18:18] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [18:18:18] root INFO: Fetching data to DataFrame
🐛 [18:18:18] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [18:18:18] root INFO: Fetched DataFrame with 12 rows and 5 columns in 0.10s
ℹ️ [18:18:18] root INFO: Fetched 2 rows for channel sms
ℹ️ [18:18:18] root INFO: Writing output file for channel sms to reports/poc/sms/sms_list.parquet
ℹ️ [18:18:18] root INFO: Output file saved to reports/poc/sms/sms_list.parquet (2 rows, 5 columns)
ℹ️ [18:18:18] root INFO: Running output SQL for channel push
🐛 [18:18:18] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [18:18:18] root INFO: Fetching data to DataFrame
🐛 [18:18:18] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [18:18:18] root INFO: Fetched DataFrame with 2 rows and 5 columns in 0.08s
ℹ️ [18:18:18] root INFO: Fetched 1 rows for channel push
ℹ️ [18:18:18] root INFO: Writing output file for channel push to reports/poc/push/push_list.excel
ℹ️ [19:13:25] root INFO: Dropping existing table eligibility_poc
ℹ️ [19:13:25] root INFO: Executing SQL statement
🐛 [19:13:25] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [19:13:26] root INFO: SQL execution finished in 0.73s
ℹ️ [19:13:26] root INFO: Executing eligibility SQL statement
ℹ️ [19:13:26] root INFO: Executing SQL statement
🐛 [19:13:26] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [19:13:26] root INFO: SQL execution finished in 0.44s
ℹ️ [19:13:26] root INFO: Executing eligibility SQL statement
ℹ️ [19:13:26] root INFO: Executing SQL statement
🐛 [19:13:26] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [19:13:26] root INFO: SQL execution finished in 0.04s
ℹ️ [19:13:26] root INFO: Executing eligibility SQL statement
ℹ️ [19:13:26] root INFO: Executing SQL statement
🐛 [19:13:26] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [19:13:26] root INFO: SQL execution finished in 0.04s
ℹ️ [19:13:26] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [19:13:26] root INFO: Fetching data to DataFrame
🐛 [19:13:26] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [19:13:26] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.22s
ℹ️ [19:13:26] root INFO: Fetching data to DataFrame
🐛 [19:13:26] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [19:13:27] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [19:13:27] root INFO: Fetching data to DataFrame
🐛 [19:13:27] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [19:13:27] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [19:13:27] root INFO: Fetching data to DataFrame
🐛 [19:13:27] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [19:13:27] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [19:13:27] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [19:13:27] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [19:13:27] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [19:13:27] root INFO: Fetching data to DataFrame
🐛 [19:13:27] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [19:13:27] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.16s
ℹ️ [19:13:27] root INFO: Fetching data to DataFrame
🐛 [19:13:27] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [19:13:27] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [19:13:27] root INFO: Fetching data to DataFrame
🐛 [19:13:27] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [19:13:27] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [19:13:27] root INFO: Fetching data to DataFrame
🐛 [19:13:27] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [19:13:27] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [19:13:27] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id_account_id.xlsx (12 rows, 6 columns)
ℹ️ [19:13:27] root INFO: Finished waterfall grouping 'customer_id_account_id'
ℹ️ [19:13:27] root INFO: Starting waterfall grouping 'region_id_segment_id'
ℹ️ [19:13:27] root INFO: Fetching data to DataFrame
🐛 [19:13:27] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [19:13:28] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.17s
ℹ️ [19:13:28] root INFO: Fetching data to DataFrame
🐛 [19:13:28] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [19:13:28] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.15s
ℹ️ [19:13:28] root INFO: Fetching data to DataFrame
🐛 [19:13:28] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [19:13:28] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.17s
ℹ️ [19:13:28] root INFO: Fetching data to DataFrame
🐛 [19:13:28] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [19:13:28] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.15s
ℹ️ [19:13:28] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_region_id_segment_id.xlsx (12 rows, 6 columns)
ℹ️ [19:13:28] root INFO: Finished waterfall grouping 'region_id_segment_id'
ℹ️ [19:13:28] root INFO: Running output SQL for channel email
🐛 [19:13:28] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [19:13:28] root INFO: Fetching data to DataFrame
🐛 [19:13:28] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [19:13:28] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.11s
ℹ️ [19:13:28] root INFO: Fetched 2 rows for channel email
ℹ️ [19:13:28] root INFO: Writing output file for channel email to reports/poc/email/email_list.csv
ℹ️ [19:13:28] root INFO: Output file saved to reports/poc/email/email_list.csv (2 rows, 5 columns)
ℹ️ [19:13:28] root INFO: Running output SQL for channel sms
🐛 [19:13:28] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [19:13:28] root INFO: Fetching data to DataFrame
🐛 [19:13:28] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [19:13:28] root INFO: Fetched DataFrame with 12 rows and 5 columns in 0.10s
ℹ️ [19:13:28] root INFO: Fetched 2 rows for channel sms
ℹ️ [19:13:28] root INFO: Writing output file for channel sms to reports/poc/sms/sms_list.parquet
ℹ️ [19:13:28] root INFO: Output file saved to reports/poc/sms/sms_list.parquet (2 rows, 5 columns)
ℹ️ [19:13:28] root INFO: Running output SQL for channel push
🐛 [19:13:28] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [19:13:28] root INFO: Fetching data to DataFrame
🐛 [19:13:28] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [19:13:28] root INFO: Fetched DataFrame with 2 rows and 5 columns in 0.08s
ℹ️ [19:13:28] root INFO: Fetched 1 rows for channel push
ℹ️ [19:13:28] root INFO: Writing output file for channel push to reports/poc/push/push_list.excel
ℹ️ [19:39:48] root INFO: Dropping existing table eligibility_poc
ℹ️ [19:39:48] root INFO: Executing SQL statement
🐛 [19:39:48] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [19:39:49] root INFO: SQL execution finished in 0.75s
ℹ️ [19:39:49] root INFO: Executing eligibility SQL statement
ℹ️ [19:39:49] root INFO: Executing SQL statement
🐛 [19:39:49] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [19:39:49] root INFO: SQL execution finished in 0.45s
ℹ️ [19:39:49] root INFO: Executing eligibility SQL statement
ℹ️ [19:39:49] root INFO: Executing SQL statement
🐛 [19:39:49] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [19:39:49] root INFO: SQL execution finished in 0.04s
ℹ️ [19:39:49] root INFO: Executing eligibility SQL statement
ℹ️ [19:39:49] root INFO: Executing SQL statement
🐛 [19:39:49] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [19:39:49] root INFO: SQL execution finished in 0.04s
ℹ️ [19:39:49] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [19:39:49] root INFO: Fetching data to DataFrame
🐛 [19:39:49] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [19:39:49] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.23s
ℹ️ [19:39:49] root INFO: Fetching data to DataFrame
🐛 [19:39:49] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [19:39:50] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [19:39:50] root INFO: Fetching data to DataFrame
🐛 [19:39:50] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [19:39:50] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [19:39:50] root INFO: Fetching data to DataFrame
🐛 [19:39:50] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [19:39:50] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.12s
ℹ️ [19:39:50] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [19:39:50] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [19:39:50] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [19:39:50] root INFO: Fetching data to DataFrame
🐛 [19:39:50] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [19:39:50] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.16s
ℹ️ [19:39:50] root INFO: Fetching data to DataFrame
🐛 [19:39:50] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [19:39:50] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [19:39:50] root INFO: Fetching data to DataFrame
🐛 [19:39:50] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [19:39:50] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [19:39:50] root INFO: Fetching data to DataFrame
🐛 [19:39:50] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [19:39:51] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [19:39:51] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id_account_id.xlsx (12 rows, 6 columns)
ℹ️ [19:39:51] root INFO: Finished waterfall grouping 'customer_id_account_id'
ℹ️ [19:39:51] root INFO: Starting waterfall grouping 'region_id_segment_id'
ℹ️ [19:39:51] root INFO: Fetching data to DataFrame
🐛 [19:39:51] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [19:39:51] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.14s
ℹ️ [19:39:51] root INFO: Fetching data to DataFrame
🐛 [19:39:51] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [19:39:51] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [19:39:51] root INFO: Fetching data to DataFrame
🐛 [19:39:51] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [19:39:51] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [19:39:51] root INFO: Fetching data to DataFrame
🐛 [19:39:51] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [19:39:51] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [19:39:51] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_region_id_segment_id.xlsx (12 rows, 6 columns)
ℹ️ [19:39:51] root INFO: Finished waterfall grouping 'region_id_segment_id'
ℹ️ [19:39:51] root INFO: Running output SQL for channel email
🐛 [19:39:51] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [19:39:51] root INFO: Fetching data to DataFrame
🐛 [19:39:51] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [19:39:51] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.08s
ℹ️ [19:39:51] root INFO: Fetched 2 rows for channel email
ℹ️ [19:39:51] root INFO: Writing output file for channel email to reports/poc/email/email_list.csv
ℹ️ [19:39:51] root INFO: Output file saved to reports/poc/email/email_list.csv (2 rows, 5 columns)
ℹ️ [19:39:51] root INFO: Running output SQL for channel sms
🐛 [19:39:51] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [19:39:51] root INFO: Fetching data to DataFrame
🐛 [19:39:51] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [19:39:51] root INFO: Fetched DataFrame with 12 rows and 5 columns in 0.10s
ℹ️ [19:39:51] root INFO: Fetched 2 rows for channel sms
ℹ️ [19:39:51] root INFO: Writing output file for channel sms to reports/poc/sms/sms_list.parquet
ℹ️ [19:39:51] root INFO: Output file saved to reports/poc/sms/sms_list.parquet (2 rows, 5 columns)
ℹ️ [19:39:51] root INFO: Running output SQL for channel push
🐛 [19:39:51] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [19:39:51] root INFO: Fetching data to DataFrame
🐛 [19:39:51] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [19:39:52] root INFO: Fetched DataFrame with 2 rows and 5 columns in 0.08s
ℹ️ [19:39:52] root INFO: Fetched 1 rows for channel push
ℹ️ [19:39:52] root INFO: Writing output file for channel push to reports/poc/push/push_list.xlsx
ℹ️ [19:39:52] root INFO: Output file saved to reports/poc/push/push_list.xlsx (1 rows, 5 columns)
ℹ️ [19:39:52] root INFO: Cleaning up DB connection
ℹ️ [20:28:32] root INFO: Executing: DROP TABLE segments;
ℹ️ [20:28:32] root INFO: Executing SQL statement
🐛 [20:28:32] root DEBUG: DROP TABLE segments;
ℹ️ [20:28:33] root INFO: SQL execution finished in 0.71s
ℹ️ [20:28:33] root INFO: Executing: DROP TABLE regions;
ℹ️ [20:28:33] root INFO: Executing SQL statement
🐛 [20:28:33] root DEBUG: DROP TABLE regions;
ℹ️ [20:28:33] root INFO: SQL execution finished in 0.16s
ℹ️ [20:28:33] root INFO: Executing: DROP TABLE accounts;
ℹ️ [20:28:33] root INFO: Executing SQL statement
🐛 [20:28:33] root DEBUG: DROP TABLE accounts;
ℹ️ [20:28:33] root INFO: SQL execution finished in 0.16s
ℹ️ [20:28:33] root INFO: Executing: DROP TABLE customers;
ℹ️ [20:28:33] root INFO: Executing SQL statement
🐛 [20:28:33] root DEBUG: DROP TABLE customers;
ℹ️ [20:28:33] root INFO: SQL execution finished in 0.14s
ℹ️ [20:28:33] root INFO: Executing: CREATE TABLE customers (customer_id INTEGER, status VARCHAR(20));
ℹ️ [20:28:33] root INFO: Executing SQL statement
🐛 [20:28:33] root DEBUG: CREATE TABLE customers (customer_id INTEGER, status VARCHAR(20));
ℹ️ [20:28:33] root INFO: SQL execution finished in 0.12s
ℹ️ [20:28:33] root INFO: Executing: CREATE TABLE accounts (customer_id INTEGER, account_id INTEGER, acct_type VARCHAR(20));
ℹ️ [20:28:33] root INFO: Executing SQL statement
🐛 [20:28:33] root DEBUG: CREATE TABLE accounts (customer_id INTEGER, account_id INTEGER, acct_type VARCHAR(20));
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.14s
ℹ️ [20:28:34] root INFO: Executing: CREATE TABLE regions (customer_id INTEGER, region_id INTEGER, region_type VARCHAR(20));
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: CREATE TABLE regions (customer_id INTEGER, region_id INTEGER, region_type VARCHAR(20));
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.14s
ℹ️ [20:28:34] root INFO: Executing: CREATE TABLE segments (customer_id INTEGER, segment_id INTEGER, segment_flag VARCHAR(20));
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: CREATE TABLE segments (customer_id INTEGER, segment_id INTEGER, segment_flag VARCHAR(20));
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.14s
ℹ️ [20:28:34] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (6, 'Inactive');
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (6, 'Inactive');
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:34] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (7, 'Active');
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (7, 'Active');
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:34] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (8, 'Pending');
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (8, 'Pending');
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:34] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (9, 'Inactive');
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (9, 'Inactive');
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:34] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (10, 'Active');
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (10, 'Active');
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:34] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (11, 'Pending');
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (11, 'Pending');
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:34] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (12, 'Inactive');
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (12, 'Inactive');
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:34] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (13, 'Active');
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (13, 'Active');
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:34] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (14, 'Pending');
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (14, 'Pending');
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:34] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (15, 'Inactive');
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (15, 'Inactive');
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:34] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (16, 'Active');
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (16, 'Active');
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:34] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (17, 'Pending');
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (17, 'Pending');
ℹ️ [20:28:34] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:34] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (18, 'Inactive');
ℹ️ [20:28:34] root INFO: Executing SQL statement
🐛 [20:28:34] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (18, 'Inactive');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (19, 'Active');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (19, 'Active');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (20, 'Pending');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (20, 'Pending');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (21, 'Inactive');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (21, 'Inactive');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (22, 'Active');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (22, 'Active');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (23, 'Pending');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (23, 'Pending');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (24, 'Inactive');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (24, 'Inactive');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (25, 'Active');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (25, 'Active');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (26, 'Pending');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (26, 'Pending');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (27, 'Inactive');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (27, 'Inactive');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (28, 'Active');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (28, 'Active');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (29, 'Pending');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (29, 'Pending');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (30, 'Inactive');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (30, 'Inactive');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (31, 'Active');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (31, 'Active');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (32, 'Pending');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (32, 'Pending');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.08s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (33, 'Inactive');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (33, 'Inactive');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (34, 'Active');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (34, 'Active');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (35, 'Pending');
ℹ️ [20:28:35] root INFO: Executing SQL statement
🐛 [20:28:35] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (35, 'Pending');
ℹ️ [20:28:35] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:35] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (36, 'Inactive');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (36, 'Inactive');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (37, 'Active');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (37, 'Active');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (38, 'Pending');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (38, 'Pending');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (39, 'Inactive');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (39, 'Inactive');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (40, 'Active');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (40, 'Active');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (41, 'Pending');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (41, 'Pending');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (42, 'Inactive');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (42, 'Inactive');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (43, 'Active');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (43, 'Active');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (44, 'Pending');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (44, 'Pending');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (45, 'Inactive');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (45, 'Inactive');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (46, 'Active');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (46, 'Active');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (47, 'Pending');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (47, 'Pending');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (48, 'Inactive');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (48, 'Inactive');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (49, 'Active');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (49, 'Active');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (50, 'Pending');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (50, 'Pending');
ℹ️ [20:28:36] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:36] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (51, 'Inactive');
ℹ️ [20:28:36] root INFO: Executing SQL statement
🐛 [20:28:36] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (51, 'Inactive');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.12s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (52, 'Active');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (52, 'Active');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (53, 'Pending');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (53, 'Pending');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (54, 'Inactive');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (54, 'Inactive');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO customers (customer_id, status) VALUES (55, 'Active');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO customers (customer_id, status) VALUES (55, 'Active');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (6, 306, 'Savings');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (6, 306, 'Savings');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (7, 307, 'Checking');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (7, 307, 'Checking');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (8, 308, 'Savings');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (8, 308, 'Savings');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (9, 309, 'Checking');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (9, 309, 'Checking');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (10, 310, 'Savings');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (10, 310, 'Savings');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (11, 311, 'Checking');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (11, 311, 'Checking');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (12, 312, 'Savings');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (12, 312, 'Savings');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (13, 313, 'Checking');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (13, 313, 'Checking');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (14, 314, 'Savings');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (14, 314, 'Savings');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (15, 315, 'Checking');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (15, 315, 'Checking');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (16, 316, 'Savings');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (16, 316, 'Savings');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (17, 317, 'Checking');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (17, 317, 'Checking');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (18, 318, 'Savings');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (18, 318, 'Savings');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (19, 319, 'Checking');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (19, 319, 'Checking');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (20, 320, 'Savings');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (20, 320, 'Savings');
ℹ️ [20:28:37] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:37] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (21, 321, 'Checking');
ℹ️ [20:28:37] root INFO: Executing SQL statement
🐛 [20:28:37] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (21, 321, 'Checking');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (22, 322, 'Savings');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (22, 322, 'Savings');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (23, 323, 'Checking');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (23, 323, 'Checking');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (24, 324, 'Savings');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (24, 324, 'Savings');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (25, 325, 'Checking');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (25, 325, 'Checking');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (26, 326, 'Savings');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (26, 326, 'Savings');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (27, 327, 'Checking');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (27, 327, 'Checking');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (28, 328, 'Savings');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (28, 328, 'Savings');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (29, 329, 'Checking');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (29, 329, 'Checking');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (30, 330, 'Savings');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (30, 330, 'Savings');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (31, 331, 'Checking');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (31, 331, 'Checking');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (32, 332, 'Savings');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (32, 332, 'Savings');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (33, 333, 'Checking');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (33, 333, 'Checking');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (34, 334, 'Savings');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (34, 334, 'Savings');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (35, 335, 'Checking');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (35, 335, 'Checking');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (36, 336, 'Savings');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (36, 336, 'Savings');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (37, 337, 'Checking');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (37, 337, 'Checking');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (38, 338, 'Savings');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (38, 338, 'Savings');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (39, 339, 'Checking');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (39, 339, 'Checking');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (40, 340, 'Savings');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (40, 340, 'Savings');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (41, 341, 'Checking');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (41, 341, 'Checking');
ℹ️ [20:28:38] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:38] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (42, 342, 'Savings');
ℹ️ [20:28:38] root INFO: Executing SQL statement
🐛 [20:28:38] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (42, 342, 'Savings');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (43, 343, 'Checking');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (43, 343, 'Checking');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (44, 344, 'Savings');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (44, 344, 'Savings');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (45, 345, 'Checking');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (45, 345, 'Checking');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (46, 346, 'Savings');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (46, 346, 'Savings');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (47, 347, 'Checking');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (47, 347, 'Checking');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (48, 348, 'Savings');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (48, 348, 'Savings');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (49, 349, 'Checking');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (49, 349, 'Checking');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (50, 350, 'Savings');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (50, 350, 'Savings');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (51, 351, 'Checking');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (51, 351, 'Checking');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (52, 352, 'Savings');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (52, 352, 'Savings');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (53, 353, 'Checking');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (53, 353, 'Checking');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (54, 354, 'Savings');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (54, 354, 'Savings');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (55, 355, 'Checking');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO accounts (customer_id, account_id, acct_type) VALUES (55, 355, 'Checking');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (6, 60, 'South');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (6, 60, 'South');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (7, 70, 'East');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (7, 70, 'East');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (8, 80, 'West');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (8, 80, 'West');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (9, 90, 'North');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (9, 90, 'North');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (10, 100, 'South');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (10, 100, 'South');
ℹ️ [20:28:39] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:39] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (11, 110, 'East');
ℹ️ [20:28:39] root INFO: Executing SQL statement
🐛 [20:28:39] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (11, 110, 'East');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (12, 120, 'West');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (12, 120, 'West');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (13, 130, 'North');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (13, 130, 'North');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (14, 140, 'South');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (14, 140, 'South');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (15, 150, 'East');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (15, 150, 'East');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (16, 160, 'West');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (16, 160, 'West');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (17, 170, 'North');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (17, 170, 'North');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (18, 180, 'South');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (18, 180, 'South');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (19, 190, 'East');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (19, 190, 'East');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (20, 200, 'West');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (20, 200, 'West');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (21, 210, 'North');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (21, 210, 'North');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (22, 220, 'South');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (22, 220, 'South');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (23, 230, 'East');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (23, 230, 'East');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (24, 240, 'West');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (24, 240, 'West');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (25, 250, 'North');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (25, 250, 'North');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (26, 260, 'South');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (26, 260, 'South');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (27, 270, 'East');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (27, 270, 'East');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (28, 280, 'West');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (28, 280, 'West');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (29, 290, 'North');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (29, 290, 'North');
ℹ️ [20:28:40] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:40] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (30, 300, 'South');
ℹ️ [20:28:40] root INFO: Executing SQL statement
🐛 [20:28:40] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (30, 300, 'South');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (31, 310, 'East');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (31, 310, 'East');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (32, 320, 'West');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (32, 320, 'West');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (33, 330, 'North');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (33, 330, 'North');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (34, 340, 'South');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (34, 340, 'South');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (35, 350, 'East');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (35, 350, 'East');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (36, 360, 'West');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (36, 360, 'West');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (37, 370, 'North');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (37, 370, 'North');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (38, 380, 'South');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (38, 380, 'South');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (39, 390, 'East');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (39, 390, 'East');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (40, 400, 'West');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (40, 400, 'West');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (41, 410, 'North');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (41, 410, 'North');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (42, 420, 'South');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (42, 420, 'South');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (43, 430, 'East');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (43, 430, 'East');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (44, 440, 'West');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (44, 440, 'West');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (45, 450, 'North');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (45, 450, 'North');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (46, 460, 'South');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (46, 460, 'South');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (47, 470, 'East');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (47, 470, 'East');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (48, 480, 'West');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (48, 480, 'West');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (49, 490, 'North');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (49, 490, 'North');
ℹ️ [20:28:41] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:41] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (50, 500, 'South');
ℹ️ [20:28:41] root INFO: Executing SQL statement
🐛 [20:28:41] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (50, 500, 'South');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (51, 510, 'East');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (51, 510, 'East');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (52, 520, 'West');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (52, 520, 'West');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (53, 530, 'North');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (53, 530, 'North');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (54, 540, 'South');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (54, 540, 'South');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO regions (customer_id, region_id, region_type) VALUES (55, 550, 'East');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO regions (customer_id, region_id, region_type) VALUES (55, 550, 'East');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (6, 6001, 'Promo1');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (6, 6001, 'Promo1');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (7, 6002, 'Promo2');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (7, 6002, 'Promo2');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (8, 6003, 'HighTx');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (8, 6003, 'HighTx');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (9, 6004, 'LowTx');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (9, 6004, 'LowTx');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (10, 6005, 'PromoA');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (10, 6005, 'PromoA');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (11, 6006, 'PromoB');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (11, 6006, 'PromoB');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (12, 6007, 'FlagA');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (12, 6007, 'FlagA');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (13, 6008, 'FlagB');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (13, 6008, 'FlagB');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (14, 6009, 'Promo1');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (14, 6009, 'Promo1');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (15, 6010, 'Promo2');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (15, 6010, 'Promo2');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (16, 6011, 'HighTx');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (16, 6011, 'HighTx');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (17, 6012, 'LowTx');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (17, 6012, 'LowTx');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (18, 6013, 'PromoA');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (18, 6013, 'PromoA');
ℹ️ [20:28:42] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:42] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (19, 6014, 'PromoB');
ℹ️ [20:28:42] root INFO: Executing SQL statement
🐛 [20:28:42] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (19, 6014, 'PromoB');
ℹ️ [20:28:43] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:43] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (20, 6015, 'FlagA');
ℹ️ [20:28:43] root INFO: Executing SQL statement
🐛 [20:28:43] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (20, 6015, 'FlagA');
ℹ️ [20:28:43] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:43] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (21, 6016, 'FlagB');
ℹ️ [20:28:43] root INFO: Executing SQL statement
🐛 [20:28:43] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (21, 6016, 'FlagB');
ℹ️ [20:28:43] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:43] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (22, 6017, 'Promo1');
ℹ️ [20:28:43] root INFO: Executing SQL statement
🐛 [20:28:43] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (22, 6017, 'Promo1');
ℹ️ [20:28:43] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:43] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (23, 6018, 'Promo2');
ℹ️ [20:28:43] root INFO: Executing SQL statement
🐛 [20:28:43] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (23, 6018, 'Promo2');
ℹ️ [20:28:43] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:43] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (24, 6019, 'HighTx');
ℹ️ [20:28:43] root INFO: Executing SQL statement
🐛 [20:28:43] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (24, 6019, 'HighTx');
ℹ️ [20:28:43] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:43] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (25, 6020, 'LowTx');
ℹ️ [20:28:43] root INFO: Executing SQL statement
🐛 [20:28:43] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (25, 6020, 'LowTx');
ℹ️ [20:28:43] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:43] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (26, 6021, 'PromoA');
ℹ️ [20:28:43] root INFO: Executing SQL statement
🐛 [20:28:43] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (26, 6021, 'PromoA');
ℹ️ [20:28:43] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:43] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (27, 6022, 'PromoB');
ℹ️ [20:28:43] root INFO: Executing SQL statement
🐛 [20:28:43] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (27, 6022, 'PromoB');
ℹ️ [20:28:43] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:43] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (28, 6023, 'FlagA');
ℹ️ [20:28:43] root INFO: Executing SQL statement
🐛 [20:28:43] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (28, 6023, 'FlagA');
ℹ️ [20:28:43] root INFO: SQL execution finished in 0.08s
ℹ️ [20:28:43] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (29, 6024, 'FlagB');
ℹ️ [20:28:43] root INFO: Executing SQL statement
🐛 [20:28:43] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (29, 6024, 'FlagB');
ℹ️ [20:28:43] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:43] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (30, 6025, 'Promo1');
ℹ️ [20:28:43] root INFO: Executing SQL statement
🐛 [20:28:43] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (30, 6025, 'Promo1');
ℹ️ [20:28:43] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:43] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (31, 6026, 'Promo2');
ℹ️ [20:28:43] root INFO: Executing SQL statement
🐛 [20:28:43] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (31, 6026, 'Promo2');
ℹ️ [20:28:43] root INFO: SQL execution finished in 0.08s
ℹ️ [20:28:43] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (32, 6027, 'HighTx');
ℹ️ [20:28:43] root INFO: Executing SQL statement
🐛 [20:28:43] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (32, 6027, 'HighTx');
ℹ️ [20:28:43] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:43] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (33, 6028, 'LowTx');
ℹ️ [20:28:43] root INFO: Executing SQL statement
🐛 [20:28:43] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (33, 6028, 'LowTx');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.08s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (34, 6029, 'PromoA');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (34, 6029, 'PromoA');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (35, 6030, 'PromoB');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (35, 6030, 'PromoB');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.08s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (36, 6031, 'FlagA');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (36, 6031, 'FlagA');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (37, 6032, 'FlagB');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (37, 6032, 'FlagB');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (38, 6033, 'Promo1');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (38, 6033, 'Promo1');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (39, 6034, 'Promo2');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (39, 6034, 'Promo2');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (40, 6035, 'HighTx');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (40, 6035, 'HighTx');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (41, 6036, 'LowTx');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (41, 6036, 'LowTx');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (42, 6037, 'PromoA');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (42, 6037, 'PromoA');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (43, 6038, 'PromoB');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (43, 6038, 'PromoB');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (44, 6039, 'FlagA');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (44, 6039, 'FlagA');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (45, 6040, 'FlagB');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (45, 6040, 'FlagB');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (46, 6041, 'Promo1');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (46, 6041, 'Promo1');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (47, 6042, 'Promo2');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (47, 6042, 'Promo2');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (48, 6043, 'HighTx');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (48, 6043, 'HighTx');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (49, 6044, 'LowTx');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (49, 6044, 'LowTx');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (50, 6045, 'PromoA');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (50, 6045, 'PromoA');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (51, 6046, 'PromoB');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (51, 6046, 'PromoB');
ℹ️ [20:28:44] root INFO: SQL execution finished in 0.06s
ℹ️ [20:28:44] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (52, 6047, 'FlagA');
ℹ️ [20:28:44] root INFO: Executing SQL statement
🐛 [20:28:44] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (52, 6047, 'FlagA');
ℹ️ [20:28:45] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:45] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (53, 6048, 'FlagB');
ℹ️ [20:28:45] root INFO: Executing SQL statement
🐛 [20:28:45] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (53, 6048, 'FlagB');
ℹ️ [20:28:45] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:45] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (54, 6049, 'Promo1');
ℹ️ [20:28:45] root INFO: Executing SQL statement
🐛 [20:28:45] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (54, 6049, 'Promo1');
ℹ️ [20:28:45] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:45] root INFO: Executing: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (55, 6050, 'Promo2');
ℹ️ [20:28:45] root INFO: Executing SQL statement
🐛 [20:28:45] root DEBUG: INSERT INTO segments (customer_id, segment_id, segment_flag) VALUES (55, 6050, 'Promo2');
ℹ️ [20:28:45] root INFO: SQL execution finished in 0.04s
ℹ️ [20:28:45] root INFO: Cleaning up DB connection
ℹ️ [20:28:45] root INFO: Test POC tables have been prepared.
ℹ️ [20:46:19] root INFO: Dropping existing table eligibility_poc
ℹ️ [20:46:19] root INFO: Executing SQL statement
🐛 [20:46:19] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [20:46:20] root INFO: SQL execution finished in 0.60s
ℹ️ [20:46:20] root INFO: Executing eligibility SQL statement
ℹ️ [20:46:20] root INFO: Executing SQL statement
🐛 [20:46:20] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [20:46:20] root INFO: SQL execution finished in 0.47s
ℹ️ [20:46:20] root INFO: Executing eligibility SQL statement
ℹ️ [20:46:20] root INFO: Executing SQL statement
🐛 [20:46:20] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [20:46:20] root INFO: SQL execution finished in 0.04s
ℹ️ [20:46:20] root INFO: Executing eligibility SQL statement
ℹ️ [20:46:20] root INFO: Executing SQL statement
🐛 [20:46:20] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [20:46:20] root INFO: SQL execution finished in 0.04s
ℹ️ [20:46:20] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [20:46:20] root INFO: Fetching data to DataFrame
🐛 [20:46:20] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [20:46:21] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.21s
ℹ️ [20:46:21] root INFO: Fetching data to DataFrame
🐛 [20:46:21] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [20:46:21] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.70s
ℹ️ [20:46:21] root INFO: Fetching data to DataFrame
🐛 [20:46:21] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [20:46:21] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [20:46:21] root INFO: Fetching data to DataFrame
🐛 [20:46:21] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [20:46:22] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.12s
ℹ️ [20:46:22] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [20:46:22] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [20:46:22] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [20:46:22] root INFO: Fetching data to DataFrame
🐛 [20:46:22] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [20:46:22] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.14s
ℹ️ [20:46:22] root INFO: Fetching data to DataFrame
🐛 [20:46:22] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [20:46:22] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [20:46:22] root INFO: Fetching data to DataFrame
🐛 [20:46:22] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [20:46:22] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [20:46:22] root INFO: Fetching data to DataFrame
🐛 [20:46:22] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [20:46:22] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [20:46:22] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id_account_id.xlsx (12 rows, 6 columns)
ℹ️ [20:46:22] root INFO: Finished waterfall grouping 'customer_id_account_id'
ℹ️ [20:46:22] root INFO: Starting waterfall grouping 'region_id_segment_id'
ℹ️ [20:46:22] root INFO: Fetching data to DataFrame
🐛 [20:46:22] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [20:46:22] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.16s
ℹ️ [20:46:22] root INFO: Fetching data to DataFrame
🐛 [20:46:22] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [20:46:23] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [20:46:23] root INFO: Fetching data to DataFrame
🐛 [20:46:23] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [20:46:23] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [20:46:23] root INFO: Fetching data to DataFrame
🐛 [20:46:23] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [20:46:23] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.18s
ℹ️ [20:46:23] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_region_id_segment_id.xlsx (12 rows, 6 columns)
ℹ️ [20:46:23] root INFO: Finished waterfall grouping 'region_id_segment_id'
ℹ️ [20:46:23] root INFO: Running output SQL for channel email
🐛 [20:46:23] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [20:46:23] root INFO: Fetching data to DataFrame
🐛 [20:46:23] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [20:46:23] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.16s
ℹ️ [20:46:23] root INFO: Fetched 17 rows for channel email
ℹ️ [20:46:23] root INFO: Writing output file for channel email to reports/poc/email/email_list.csv
ℹ️ [20:46:23] root INFO: Output file saved to reports/poc/email/email_list.csv (17 rows, 5 columns)
ℹ️ [20:46:23] root INFO: Running output SQL for channel sms
🐛 [20:46:23] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [20:46:23] root INFO: Fetching data to DataFrame
🐛 [20:46:23] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [20:46:23] root INFO: Fetched DataFrame with 25 rows and 5 columns in 0.18s
ℹ️ [20:46:23] root INFO: Fetched 25 rows for channel sms
ℹ️ [20:46:23] root INFO: Writing output file for channel sms to reports/poc/sms/sms_list.parquet
ℹ️ [20:46:23] root INFO: Output file saved to reports/poc/sms/sms_list.parquet (25 rows, 5 columns)
ℹ️ [20:46:23] root INFO: Running output SQL for channel push
🐛 [20:46:23] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [20:46:23] root INFO: Fetching data to DataFrame
🐛 [20:46:23] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [20:46:23] root INFO: Fetched DataFrame with 6 rows and 5 columns in 0.16s
ℹ️ [20:46:23] root INFO: Fetched 6 rows for channel push
ℹ️ [20:46:23] root INFO: Writing output file for channel push to reports/poc/push/push_list.xlsx
ℹ️ [20:46:23] root INFO: Output file saved to reports/poc/push/push_list.xlsx (6 rows, 5 columns)
ℹ️ [20:46:23] root INFO: Cleaning up DB connection
ℹ️ [20:49:06] root INFO: Dropping existing table eligibility_poc
ℹ️ [20:49:06] root INFO: Executing SQL statement
🐛 [20:49:06] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [20:49:07] root INFO: SQL execution finished in 0.71s
ℹ️ [20:49:07] root INFO: Executing eligibility SQL statement
ℹ️ [20:49:07] root INFO: Executing SQL statement
🐛 [20:49:07] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [20:49:07] root INFO: SQL execution finished in 0.43s
ℹ️ [20:49:07] root INFO: Executing eligibility SQL statement
ℹ️ [20:49:07] root INFO: Executing SQL statement
🐛 [20:49:07] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [20:49:07] root INFO: SQL execution finished in 0.04s
ℹ️ [20:49:07] root INFO: Executing eligibility SQL statement
ℹ️ [20:49:07] root INFO: Executing SQL statement
🐛 [20:49:07] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [20:49:07] root INFO: SQL execution finished in 0.04s
ℹ️ [20:49:07] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [20:49:07] root INFO: Fetching data to DataFrame
🐛 [20:49:07] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [20:49:08] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.27s
ℹ️ [20:49:08] root INFO: Fetching data to DataFrame
🐛 [20:49:08] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [20:49:08] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [20:49:08] root INFO: Fetching data to DataFrame
🐛 [20:49:08] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [20:49:08] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.14s
ℹ️ [20:49:08] root INFO: Fetching data to DataFrame
🐛 [20:49:08] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [20:49:08] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.16s
ℹ️ [20:49:08] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [20:49:08] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [20:49:08] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [20:49:08] root INFO: Fetching data to DataFrame
🐛 [20:49:08] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [20:49:08] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.16s
ℹ️ [20:49:08] root INFO: Fetching data to DataFrame
🐛 [20:49:08] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [20:49:09] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [20:49:09] root INFO: Fetching data to DataFrame
🐛 [20:49:09] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [20:49:09] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.18s
ℹ️ [20:49:09] root INFO: Fetching data to DataFrame
🐛 [20:49:09] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [20:49:09] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.14s
ℹ️ [20:49:09] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id_account_id.xlsx (12 rows, 6 columns)
ℹ️ [20:49:09] root INFO: Finished waterfall grouping 'customer_id_account_id'
ℹ️ [20:49:09] root INFO: Starting waterfall grouping 'region_id_segment_id'
ℹ️ [20:49:09] root INFO: Fetching data to DataFrame
🐛 [20:49:09] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [20:49:09] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.16s
ℹ️ [20:49:09] root INFO: Fetching data to DataFrame
🐛 [20:49:09] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [20:49:09] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.16s
ℹ️ [20:49:09] root INFO: Fetching data to DataFrame
🐛 [20:49:09] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [20:49:10] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.21s
ℹ️ [20:49:10] root INFO: Fetching data to DataFrame
🐛 [20:49:10] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [20:49:10] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.25s
ℹ️ [20:49:10] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_region_id_segment_id.xlsx (12 rows, 6 columns)
ℹ️ [20:49:10] root INFO: Finished waterfall grouping 'region_id_segment_id'
ℹ️ [20:49:10] root INFO: Running output SQL for channel email
🐛 [20:49:10] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [20:49:10] root INFO: Fetching data to DataFrame
🐛 [20:49:10] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [20:49:10] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.14s
ℹ️ [20:49:10] root INFO: Fetched 17 rows for channel email
ℹ️ [20:49:10] root INFO: Writing output file for channel email to reports/poc/email/email_list.csv
ℹ️ [20:49:10] root INFO: Output file saved to reports/poc/email/email_list.csv (17 rows, 5 columns)
ℹ️ [20:49:10] root INFO: Running output SQL for channel sms
🐛 [20:49:10] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [20:49:10] root INFO: Fetching data to DataFrame
🐛 [20:49:10] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [20:49:10] root INFO: Fetched DataFrame with 25 rows and 5 columns in 0.15s
ℹ️ [20:49:10] root INFO: Fetched 25 rows for channel sms
ℹ️ [20:49:10] root INFO: Writing output file for channel sms to reports/poc/sms/sms_list.parquet
ℹ️ [20:49:10] root INFO: Output file saved to reports/poc/sms/sms_list.parquet (25 rows, 5 columns)
ℹ️ [20:49:10] root INFO: Running output SQL for channel push
🐛 [20:49:10] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [20:49:10] root INFO: Fetching data to DataFrame
🐛 [20:49:10] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [20:49:10] root INFO: Fetched DataFrame with 6 rows and 5 columns in 0.14s
ℹ️ [20:49:10] root INFO: Fetched 6 rows for channel push
ℹ️ [20:49:10] root INFO: Writing output file for channel push to reports/poc/push/push_list.xlsx
ℹ️ [20:49:10] root INFO: Output file saved to reports/poc/push/push_list.xlsx (6 rows, 5 columns)
ℹ️ [20:49:10] root INFO: Cleaning up DB connection
ℹ️ [21:32:08] root INFO: Dropping existing table eligibility_poc
ℹ️ [21:32:08] root INFO: Executing SQL statement
🐛 [21:32:08] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [21:32:11] root INFO: SQL execution finished in 3.19s
ℹ️ [21:32:11] root INFO: Executing eligibility SQL statement
ℹ️ [21:32:11] root INFO: Executing SQL statement
🐛 [21:32:11] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [21:32:12] root INFO: SQL execution finished in 0.55s
ℹ️ [21:32:12] root INFO: Executing eligibility SQL statement
ℹ️ [21:32:12] root INFO: Executing SQL statement
🐛 [21:32:12] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [21:32:12] root INFO: SQL execution finished in 0.18s
ℹ️ [21:32:12] root INFO: Executing eligibility SQL statement
ℹ️ [21:32:12] root INFO: Executing SQL statement
🐛 [21:32:12] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [21:32:12] root INFO: SQL execution finished in 0.12s
ℹ️ [21:32:12] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [21:32:12] root INFO: Fetching data to DataFrame
🐛 [21:32:12] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [21:32:12] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.32s
ℹ️ [21:32:12] root INFO: Fetching data to DataFrame
🐛 [21:32:12] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [21:32:13] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.39s
ℹ️ [21:32:13] root INFO: Fetching data to DataFrame
🐛 [21:32:13] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [21:32:13] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.25s
ℹ️ [21:32:13] root INFO: Fetching data to DataFrame
🐛 [21:32:13] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [21:32:13] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.37s
ℹ️ [21:32:14] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [21:32:14] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [21:32:14] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [21:32:14] root INFO: Fetching data to DataFrame
🐛 [21:32:14] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [21:32:14] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.35s
ℹ️ [21:32:14] root INFO: Fetching data to DataFrame
🐛 [21:32:14] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [21:32:14] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.25s
ℹ️ [21:32:14] root INFO: Fetching data to DataFrame
🐛 [21:32:14] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [21:32:15] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.35s
ℹ️ [21:32:15] root INFO: Fetching data to DataFrame
🐛 [21:32:15] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [21:32:15] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.29s
ℹ️ [21:32:15] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id_account_id.xlsx (12 rows, 6 columns)
ℹ️ [21:32:15] root INFO: Finished waterfall grouping 'customer_id_account_id'
ℹ️ [21:32:15] root INFO: Starting waterfall grouping 'region_id_segment_id'
ℹ️ [21:32:15] root INFO: Fetching data to DataFrame
🐛 [21:32:15] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [21:32:15] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.49s
ℹ️ [21:32:15] root INFO: Fetching data to DataFrame
🐛 [21:32:15] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [21:32:16] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.35s
ℹ️ [21:32:16] root INFO: Fetching data to DataFrame
🐛 [21:32:16] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [21:32:16] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.21s
ℹ️ [21:32:16] root INFO: Fetching data to DataFrame
🐛 [21:32:16] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [21:32:16] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.25s
ℹ️ [21:32:16] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_region_id_segment_id.xlsx (12 rows, 6 columns)
ℹ️ [21:32:16] root INFO: Finished waterfall grouping 'region_id_segment_id'
ℹ️ [21:32:16] root INFO: Running output SQL for channel email
🐛 [21:32:16] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [21:32:16] root INFO: Fetching data to DataFrame
🐛 [21:32:16] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN email_optin_5 = 1 THEN 1 ELSE 0 END AS email_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE email_optin_5 = 1

ℹ️ [21:32:17] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.25s
ℹ️ [21:32:17] root INFO: Fetched 17 rows for channel email
ℹ️ [21:32:17] root INFO: Writing output file for channel email to reports/poc/email/email_list.csv
ℹ️ [21:32:17] root INFO: Output file saved to reports/poc/email/email_list.csv (17 rows, 5 columns)
ℹ️ [21:32:17] root INFO: Running output SQL for channel sms
🐛 [21:32:17] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [21:32:17] root INFO: Fetching data to DataFrame
🐛 [21:32:17] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN sms_optin_8 = 1 THEN 1 ELSE 0 END AS sms_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE sms_optin_8 = 1

ℹ️ [21:32:17] root INFO: Fetched DataFrame with 25 rows and 5 columns in 0.11s
ℹ️ [21:32:17] root INFO: Fetched 25 rows for channel sms
ℹ️ [21:32:17] root INFO: Writing output file for channel sms to reports/poc/sms/sms_list.parquet
ℹ️ [21:32:17] root INFO: Output file saved to reports/poc/sms/sms_list.parquet (25 rows, 5 columns)
ℹ️ [21:32:17] root INFO: Running output SQL for channel push
🐛 [21:32:17] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [21:32:17] root INFO: Fetching data to DataFrame
🐛 [21:32:17] root DEBUG: SELECT
  c.customer_id AS customer_id,
  a.account_id AS account_id,
  r.region_id AS region_id,
  s.segment_id AS segment_id,
  CASE WHEN push_promoA_11 = 1 THEN 1 ELSE 0 END AS push_flag
FROM eligibility_poc AS c
LEFT JOIN accounts AS a ON a.customer_id = c.customer_id
LEFT JOIN regions AS r ON r.customer_id = c.customer_id
LEFT JOIN segments AS s ON s.customer_id = c.customer_id
WHERE push_promoA_11 = 1

ℹ️ [21:32:17] root INFO: Fetched DataFrame with 6 rows and 5 columns in 0.08s
ℹ️ [21:32:17] root INFO: Fetched 6 rows for channel push
ℹ️ [21:32:17] root INFO: Writing output file for channel push to reports/poc/push/push_list.xlsx
ℹ️ [21:32:17] root INFO: Output file saved to reports/poc/push/push_list.xlsx (6 rows, 5 columns)
ℹ️ [21:32:17] root INFO: Cleaning up DB connection
ℹ️ [21:38:39] root INFO: Dropping existing table eligibility_poc
ℹ️ [21:38:39] root INFO: Executing SQL statement
🐛 [21:38:39] root DEBUG: DROP TABLE eligibility_poc;
ℹ️ [21:38:40] root INFO: SQL execution finished in 1.37s
ℹ️ [21:38:40] root INFO: Executing eligibility SQL statement
ℹ️ [21:38:40] root INFO: Executing SQL statement
🐛 [21:38:40] root DEBUG: -- Jinja2 template for eligibility SQL
-- Context:
--   eligibility_table: name of final eligibility table
--   unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
--   unique_without_aliases: list of column names only (e.g. ['col'])
--   checks: list of dicts {name: column_name, sql: expression}
--   tables: list of dicts {name, alias, join_type, join_conditions}
--   where_clauses: list of strings
CREATE TABLE eligibility_poc AS (
    SELECT
        c.customer_id,
        a.account_id,
        r.region_id,
        s.segment_id,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_active_1,
        CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_has_account_2,
        CASE WHEN r.region_type = 'North' THEN 1 ELSE 0 END AS main_region_north_3,
        CASE WHEN s.segment_flag = 'FlagA' THEN 1 ELSE 0 END AS main_segment_flagA_4,
        CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_optin_5,
        CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo1_6,
        CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo2_7,
        CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_optin_8,
        CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_high_tx_9,
        CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_low_tx_10,
        CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promoA_11,
        CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promoB_12
    FROM customers c
      LEFT JOIN accounts a
        ON a.customer_id = c.customer_id
      LEFT JOIN regions r
        ON r.customer_id = c.customer_id
      LEFT JOIN segments s
        ON s.customer_id = c.customer_id
 ) WITH DATA PRIMARY INDEX (customer_id, account_id, region_id, segment_id)
ℹ️ [21:38:41] root INFO: SQL execution finished in 0.57s
ℹ️ [21:38:41] root INFO: Executing eligibility SQL statement
ℹ️ [21:38:41] root INFO: Executing SQL statement
🐛 [21:38:41] root DEBUG: -- Collect statistics on the new table
-- Collect statistics on the new table (disabled for testing)
-- COLLECT STATISTICS INDEX prindx ON eligibility_poc
ℹ️ [21:38:41] root INFO: SQL execution finished in 0.04s
ℹ️ [21:38:41] root INFO: Executing eligibility SQL statement
ℹ️ [21:38:41] root INFO: Executing SQL statement
🐛 [21:38:41] root DEBUG: -- COLLECT STATISTICS COLUMN (main_active_1, main_has_account_2, main_region_north_3, main_segment_flagA_4, email_optin_5, email_promo1_6, email_promo2_7, sms_optin_8, sms_high_tx_9, sms_low_tx_10, push_promoA_11, push_promoB_12) ON eligibility_poc
ℹ️ [21:38:41] root INFO: SQL execution finished in 0.04s
ℹ️ [21:38:41] root INFO: Starting waterfall grouping 'customer_id'
ℹ️ [21:38:41] root INFO: Fetching data to DataFrame
🐛 [21:38:41] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [21:38:41] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.26s
ℹ️ [21:38:41] root INFO: Fetching data to DataFrame
🐛 [21:38:41] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [21:38:41] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.21s
ℹ️ [21:38:41] root INFO: Fetching data to DataFrame
🐛 [21:38:41] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [21:38:42] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.19s
ℹ️ [21:38:42] root INFO: Fetching data to DataFrame
🐛 [21:38:42] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [21:38:42] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.18s
ℹ️ [21:38:42] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id.xlsx (12 rows, 6 columns)
ℹ️ [21:38:42] root INFO: Finished waterfall grouping 'customer_id'
ℹ️ [21:38:42] root INFO: Starting waterfall grouping 'customer_id_account_id'
ℹ️ [21:38:42] root INFO: Fetching data to DataFrame
🐛 [21:38:42] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [21:38:42] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.21s
ℹ️ [21:38:42] root INFO: Fetching data to DataFrame
🐛 [21:38:42] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [21:38:42] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.31s
ℹ️ [21:38:42] root INFO: Fetching data to DataFrame
🐛 [21:38:42] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [21:38:43] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.21s
ℹ️ [21:38:43] root INFO: Fetching data to DataFrame
🐛 [21:38:43] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.customer_id,c.account_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.customer_id, c.account_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [21:38:43] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.27s
ℹ️ [21:38:43] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_customer_id_account_id.xlsx (12 rows, 6 columns)
ℹ️ [21:38:43] root INFO: Finished waterfall grouping 'customer_id_account_id'
ℹ️ [21:38:43] root INFO: Starting waterfall grouping 'region_id_segment_id'
ℹ️ [21:38:43] root INFO: Fetching data to DataFrame
🐛 [21:38:43] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(main_active_1) AS max_main_active_1,
    
      MAX(main_has_account_2) AS max_main_has_account_2,
    
      MAX(main_region_north_3) AS max_main_region_north_3,
    
      MAX(main_segment_flagA_4) AS max_main_segment_flagA_4
    
    
  FROM eligibility_poc AS c
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0 THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 0
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 0 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 0 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_active_1,
    COUNT(*) - SUM(CASE WHEN max_main_has_account_2 = 1 AND max_main_active_1 = 1
      THEN 1 ELSE 0 END) AS main_has_account_2,
    COUNT(*) - SUM(CASE WHEN max_main_region_north_3 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1
      THEN 1 ELSE 0 END) AS main_region_north_3,
    COUNT(*) - SUM(CASE WHEN max_main_segment_flagA_4 = 1 AND max_main_active_1 = 1 AND max_main_has_account_2 = 1 AND max_main_region_north_3 = 1
      THEN 1 ELSE 0 END) AS main_segment_flagA_4
FROM flags;
ℹ️ [21:38:43] root INFO: Fetched DataFrame with 4 rows and 5 columns in 0.19s
ℹ️ [21:38:43] root INFO: Fetching data to DataFrame
🐛 [21:38:43] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(email_optin_5) AS max_email_optin_5,
    
      MAX(email_promo1_6) AS max_email_promo1_6,
    
      MAX(email_promo2_7) AS max_email_promo2_7
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0 THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 0
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 0 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 0 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_optin_5,
    COUNT(*) - SUM(CASE WHEN max_email_promo1_6 = 1 AND max_email_optin_5 = 1
      THEN 1 ELSE 0 END) AS email_promo1_6,
    COUNT(*) - SUM(CASE WHEN max_email_promo2_7 = 1 AND max_email_optin_5 = 1 AND max_email_promo1_6 = 1
      THEN 1 ELSE 0 END) AS email_promo2_7
FROM flags;
ℹ️ [21:38:43] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.35s
ℹ️ [21:38:43] root INFO: Fetching data to DataFrame
🐛 [21:38:43] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(sms_optin_8) AS max_sms_optin_8,
    
      MAX(sms_high_tx_9) AS max_sms_high_tx_9,
    
      MAX(sms_low_tx_10) AS max_sms_low_tx_10
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0 THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 0
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 0 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 0 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_optin_8,
    COUNT(*) - SUM(CASE WHEN max_sms_high_tx_9 = 1 AND max_sms_optin_8 = 1
      THEN 1 ELSE 0 END) AS sms_high_tx_9,
    COUNT(*) - SUM(CASE WHEN max_sms_low_tx_10 = 1 AND max_sms_optin_8 = 1 AND max_sms_high_tx_9 = 1
      THEN 1 ELSE 0 END) AS sms_low_tx_10
FROM flags;
ℹ️ [21:38:44] root INFO: Fetched DataFrame with 4 rows and 4 columns in 0.41s
ℹ️ [21:38:44] root INFO: Fetching data to DataFrame
🐛 [21:38:44] root DEBUG: -- Waterfall full metrics SQL using a single CTE
-- Context:
--   eligibility_table: base eligibility table name (with alias)
--   unique_identifiers: list of identifiers with alias (e.g. ['a.pty_id', 'a.accno'])
--   unique_without_aliases: list of identifier columns only (e.g. ['pty_id', 'accno'])
--   check_columns: ordered list of check column names (e.g. ['main_BA_1', 'main_BA_2', ...])
WITH flags AS (
  SELECT
    c.region_id,c.segment_id
    ,
    
      MAX(push_promoA_11) AS max_push_promoA_11,
    
      MAX(push_promoB_12) AS max_push_promoB_12
    
    
  FROM eligibility_poc AS c
  WHERE c.main_active_1=1 AND c.main_has_account_2=1 AND c.main_region_north_3=1 AND c.main_segment_flagA_4=1
  GROUP BY c.region_id, c.segment_id
)
SELECT
  'unique_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0 THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'incremental_drops' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 0
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 0 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'remaining' AS stat_name,
    SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags
UNION ALL
SELECT
  'cumulative_drops' AS stat_name,
    COUNT(*) - SUM(CASE WHEN max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoA_11,
    COUNT(*) - SUM(CASE WHEN max_push_promoB_12 = 1 AND max_push_promoA_11 = 1
      THEN 1 ELSE 0 END) AS push_promoB_12
FROM flags;
ℹ️ [21:38:44] root INFO: Fetched DataFrame with 4 rows and 3 columns in 0.23s
ℹ️ [21:38:44] root INFO: Waterfall report saved to reports/poc/waterfall/waterfall_eligibility_poc_region_id_segment_id.xlsx (12 rows, 6 columns)
ℹ️ [21:38:44] root INFO: Finished waterfall grouping 'region_id_segment_id'
