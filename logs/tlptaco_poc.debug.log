‚ÑπÔ∏è [11:13:03] root INFO: ================================================================================
TLPTACO RUN START 2025-07-28 11:13:03
================================================================================
‚ÑπÔ∏è [11:13:03] root INFO: Calculating the number of steps for the eligibility run.
‚ÑπÔ∏è [11:13:03] root INFO: No cached SQL found. Generating new SQL statements.
‚ÑπÔ∏è [11:13:03] root INFO: Calculation complete: 3 steps.
‚ÑπÔ∏è [11:13:03] root INFO: Calculating the number of waterfall steps.
‚ÑπÔ∏è [11:13:03] root INFO: No cached steps found. Preparing waterfall groups and SQL.
‚ÑπÔ∏è [11:13:03] root INFO: Calculation complete: 3 steps (reports).
‚ÑπÔ∏è [11:13:03] root INFO: Calculating the number of output steps.
‚ÑπÔ∏è [11:13:03] root INFO: No cached steps found. Preparing output jobs and SQL.
‚ÑπÔ∏è [11:13:03] root INFO: Preparing logic for channel 'email'
‚ÑπÔ∏è [11:13:03] root INFO: Preparing logic for channel 'sms'
‚ÑπÔ∏è [11:13:03] root INFO: Preparing logic for channel 'push'
‚ÑπÔ∏è [11:13:03] root INFO: Calculation complete: 3 steps (files).
‚ÑπÔ∏è [11:13:03] root INFO: Using cached SQL statements.
‚ÑπÔ∏è [11:13:03] root INFO: Dropping existing table eligibility_poc
‚ÑπÔ∏è [11:13:03] root INFO: Executing SQL statement
üêõ [11:13:03] root DEBUG: DROP TABLE eligibility_poc;
‚ÑπÔ∏è [11:13:04] root INFO: SQL execution finished in 0.98s
‚ÑπÔ∏è [11:13:04] root INFO: Executing eligibility SQL statement
‚ÑπÔ∏è [11:13:04] root INFO: Executing SQL statement
üêõ [11:13:04] root DEBUG: -- Jinja2 template for eligibility SQL

-- Context:
-- eligibility_table: name of final eligibility table
-- unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
-- unique_without_aliases: list of column names only (e.g. ['col'])
-- checks: list of dicts {name: column_name, sql: expression}
-- tables: list of dicts {name, alias, join_type, join_conditions}
-- where_clauses: list of strings

CREATE TABLE eligibility_poc AS (
SELECT
c.customer_id,
a.account_id,
r.region_id,
s.segment_id,
CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_BA_1,
CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_BA_2,
CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_BA_1,
CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo_1,
CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo_2,
CASE WHEN s.segment_flag IN ('FlagA','FlagB') THEN 1 ELSE 0 END AS email_loyalty_1,
CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_BA_1,
CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_tx_1,
CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_tx_2,
CASE WHEN s.segment_flag IN ('FlagA','FlagB') THEN 1 ELSE 0 END AS sms_rfm_1,
CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promotions_1,
CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promotions_2,
CASE WHEN s.segment_flag IN ('FlagA','FlagB') THEN 1 ELSE 0 END AS push_surveys_1
FROM customers c
LEFT JOIN accounts a
ON a.customer_id = c.customer_id
LEFT JOIN regions r
ON r.customer_id = c.customer_id
LEFT JOIN segments s
ON s.customer_id = c.customer_id
) WITH DATA PRIMARY INDEX prindx (customer_id, account_id, region_id, segment_id)
‚ÑπÔ∏è [11:13:04] root INFO: SQL execution finished in 0.47s
‚ÑπÔ∏è [11:13:04] root INFO: Executing eligibility SQL statement
‚ÑπÔ∏è [11:13:04] root INFO: Executing SQL statement
üêõ [11:13:04] root DEBUG: 

-- MODIFIED: Collect stats only on the primary index for robustness.
COLLECT STATISTICS INDEX prindx ON eligibility_poc
‚ÑπÔ∏è [11:13:05] root INFO: SQL execution finished in 0.16s
‚ÑπÔ∏è [11:13:05] root INFO: Using cached waterfall steps.
‚ÑπÔ∏è [11:13:05] root INFO: Fetching data to DataFrame
üêõ [11:13:05] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:13:05] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.48s
‚ÑπÔ∏è [11:13:05] root INFO: Fetching data to DataFrame
üêõ [11:13:05] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        email_BA_1,email_promo_1,email_promo_2,email_loyalty_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_promo_1 = 1 AND email_promo_2 = 1)) OR ((email_loyalty_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:13:05] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
‚ÑπÔ∏è [11:13:05] root INFO: Fetching data to DataFrame
üêõ [11:13:05] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - promo' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - loyalty' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:13:06] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.97s
‚ÑπÔ∏è [11:13:06] root INFO: Fetching data to DataFrame
üêõ [11:13:06] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            sms_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                sms_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        sms_BA_1,sms_tx_1,sms_tx_2,sms_rfm_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'sms_BA_1'    AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'sms_BA_1'        AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'sms_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN sms_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                     AND ( ((sms_tx_1 = 1 AND sms_tx_2 = 1)) OR ((sms_rfm_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:13:07] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
‚ÑπÔ∏è [11:13:07] root INFO: Fetching data to DataFrame
üêõ [11:13:07] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               sms_tx_1+sms_tx_2+sms_rfm_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   sms_tx_1 + 
                   sms_tx_1 * sms_tx_2 + 
                   sms_tx_1 * sms_tx_2 * sms_rfm_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (sms_tx_1 = 1 AND sms_tx_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (sms_tx_1 = 1 AND sms_tx_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (sms_rfm_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: sms - tx ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - tx' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND ( sms_tx_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND ( sms_tx_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1 AND sms_tx_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND sms_tx_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 AND sms_tx_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: sms - rfm ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - rfm' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_rfm_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'regain'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'remaining'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_rfm_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:13:08] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.95s
‚ÑπÔ∏è [11:13:08] root INFO: Fetching data to DataFrame
üêõ [11:13:08] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND 1=1
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               push_promotions_1+push_promotions_2+push_surveys_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   push_promotions_1 + 
                   push_promotions_1 * push_promotions_2 + 
                   push_promotions_1 * push_promotions_2 * push_surveys_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (push_promotions_1 = 1 AND push_promotions_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (push_promotions_1 = 1 AND push_promotions_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (push_surveys_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: push - promotions ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - promotions' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND ( push_promotions_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND ( push_promotions_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1 AND push_promotions_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND push_promotions_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 AND push_promotions_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: push - surveys ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - surveys' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - surveys'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_surveys_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'regain'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'remaining'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_surveys_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:13:09] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.95s
‚ÑπÔ∏è [11:13:09] root INFO: Fetching data to DataFrame
üêõ [11:13:09] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:13:09] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.48s
‚ÑπÔ∏è [11:13:09] root INFO: Fetching data to DataFrame
üêõ [11:13:09] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        email_BA_1,email_promo_1,email_promo_2,email_loyalty_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_promo_1 = 1 AND email_promo_2 = 1)) OR ((email_loyalty_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:13:09] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
‚ÑπÔ∏è [11:13:09] root INFO: Fetching data to DataFrame
üêõ [11:13:09] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - promo' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - loyalty' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:13:10] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.97s
‚ÑπÔ∏è [11:13:10] root INFO: Fetching data to DataFrame
üêõ [11:13:10] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            sms_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                sms_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        sms_BA_1,sms_tx_1,sms_tx_2,sms_rfm_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'sms_BA_1'    AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'sms_BA_1'        AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'sms_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN sms_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                     AND ( ((sms_tx_1 = 1 AND sms_tx_2 = 1)) OR ((sms_rfm_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:13:11] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
‚ÑπÔ∏è [11:13:11] root INFO: Fetching data to DataFrame
üêõ [11:13:11] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               sms_tx_1+sms_tx_2+sms_rfm_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   sms_tx_1 + 
                   sms_tx_1 * sms_tx_2 + 
                   sms_tx_1 * sms_tx_2 * sms_rfm_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (sms_tx_1 = 1 AND sms_tx_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (sms_tx_1 = 1 AND sms_tx_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (sms_rfm_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: sms - tx ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - tx' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND ( sms_tx_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND ( sms_tx_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1 AND sms_tx_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND sms_tx_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 AND sms_tx_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: sms - rfm ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - rfm' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_rfm_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'regain'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'remaining'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_rfm_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:13:12] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.93s
‚ÑπÔ∏è [11:13:12] root INFO: Fetching data to DataFrame
üêõ [11:13:12] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND 1=1
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               push_promotions_1+push_promotions_2+push_surveys_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   push_promotions_1 + 
                   push_promotions_1 * push_promotions_2 + 
                   push_promotions_1 * push_promotions_2 * push_surveys_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (push_promotions_1 = 1 AND push_promotions_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (push_promotions_1 = 1 AND push_promotions_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (push_surveys_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: push - promotions ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - promotions' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND ( push_promotions_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND ( push_promotions_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1 AND push_promotions_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND push_promotions_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 AND push_promotions_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: push - surveys ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - surveys' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - surveys'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_surveys_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'regain'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'remaining'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_surveys_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:13:13] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.13s
‚ÑπÔ∏è [11:13:13] root INFO: Fetching data to DataFrame
üêõ [11:13:13] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:13:14] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.86s
‚ÑπÔ∏è [11:13:14] root INFO: Fetching data to DataFrame
üêõ [11:13:14] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        email_BA_1,email_promo_1,email_promo_2,email_loyalty_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_promo_1 = 1 AND email_promo_2 = 1)) OR ((email_loyalty_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:13:14] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.39s
‚ÑπÔ∏è [11:13:14] root INFO: Fetching data to DataFrame
üêõ [11:13:14] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - promo' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - loyalty' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:13:15] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.97s
‚ÑπÔ∏è [11:13:15] root INFO: Fetching data to DataFrame
üêõ [11:13:15] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            sms_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                sms_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        sms_BA_1,sms_tx_1,sms_tx_2,sms_rfm_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'sms_BA_1'    AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'sms_BA_1'        AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'sms_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN sms_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                     AND ( ((sms_tx_1 = 1 AND sms_tx_2 = 1)) OR ((sms_rfm_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:13:15] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
‚ÑπÔ∏è [11:13:15] root INFO: Fetching data to DataFrame
üêõ [11:13:15] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               sms_tx_1+sms_tx_2+sms_rfm_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   sms_tx_1 + 
                   sms_tx_1 * sms_tx_2 + 
                   sms_tx_1 * sms_tx_2 * sms_rfm_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (sms_tx_1 = 1 AND sms_tx_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (sms_tx_1 = 1 AND sms_tx_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (sms_rfm_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: sms - tx ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - tx' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND ( sms_tx_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND ( sms_tx_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1 AND sms_tx_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND sms_tx_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 AND sms_tx_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: sms - rfm ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - rfm' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_rfm_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'regain'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'remaining'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_rfm_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:13:16] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.99s
‚ÑπÔ∏è [11:13:16] root INFO: Fetching data to DataFrame
üêõ [11:13:16] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND 1=1
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               push_promotions_1+push_promotions_2+push_surveys_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   push_promotions_1 + 
                   push_promotions_1 * push_promotions_2 + 
                   push_promotions_1 * push_promotions_2 * push_surveys_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (push_promotions_1 = 1 AND push_promotions_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (push_promotions_1 = 1 AND push_promotions_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (push_surveys_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: push - promotions ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - promotions' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND ( push_promotions_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND ( push_promotions_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1 AND push_promotions_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND push_promotions_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 AND push_promotions_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: push - surveys ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - surveys' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - surveys'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_surveys_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'regain'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'remaining'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_surveys_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:13:17] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.95s
‚ÑπÔ∏è [11:13:17] root INFO: Consolidated waterfall report written to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/Running_2025_07_28_11:13:17.xlsx
‚ÑπÔ∏è [11:13:17] root INFO: Waterfall run history appended to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_history.sqlite
‚ÑπÔ∏è [11:13:17] root INFO: Using cached output steps.
‚ÑπÔ∏è [11:13:17] root INFO: Running output job for channel email
üêõ [11:13:17] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) THEN 'email_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) AND (c.email_promo_1 = 1 AND c.email_promo_2 = 1) THEN 'email_promo'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) AND (c.email_loyalty_1 = 1) AND (c.email_promo_1 = 0 OR c.email_promo_2 = 0) THEN 'email_loyalty'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:13:17] root INFO: Fetching data to DataFrame
üêõ [11:13:17] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) THEN 'email_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) AND (c.email_promo_1 = 1 AND c.email_promo_2 = 1) THEN 'email_promo'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) AND (c.email_loyalty_1 = 1) AND (c.email_promo_1 = 0 OR c.email_promo_2 = 0) THEN 'email_loyalty'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:13:17] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.12s
‚ÑπÔ∏è [11:13:17] root INFO: Fetched 17 rows for channel email
‚ÑπÔ∏è [11:13:17] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
‚ÑπÔ∏è [11:13:17] root INFO: Running output job for channel sms
üêõ [11:13:17] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) THEN 'sms_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_tx_1 = 1 AND c.sms_tx_2 = 1) THEN 'sms_tx'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_rfm_1 = 1) AND (c.sms_tx_1 = 0 OR c.sms_tx_2 = 0) THEN 'sms_rfm'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:13:17] root INFO: Fetching data to DataFrame
üêõ [11:13:17] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) THEN 'sms_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_tx_1 = 1 AND c.sms_tx_2 = 1) THEN 'sms_tx'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_rfm_1 = 1) AND (c.sms_tx_1 = 0 OR c.sms_tx_2 = 0) THEN 'sms_rfm'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:13:18] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.15s
‚ÑπÔ∏è [11:13:18] root INFO: Fetched 8 rows for channel sms
‚ÑπÔ∏è [11:13:18] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
‚ÑπÔ∏è [11:13:18] root INFO: Running output job for channel push
üêõ [11:13:18] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) THEN 'push_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) AND (c.push_promotions_1 = 1 AND c.push_promotions_2 = 1) THEN 'push_promotions'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) AND (c.push_surveys_1 = 1) AND (c.push_promotions_1 = 0 OR c.push_promotions_2 = 0) THEN 'push_surveys'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:13:18] root INFO: Fetching data to DataFrame
üêõ [11:13:18] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) THEN 'push_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) AND (c.push_promotions_1 = 1 AND c.push_promotions_2 = 1) THEN 'push_promotions'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) AND (c.push_surveys_1 = 1) AND (c.push_promotions_1 = 0 OR c.push_promotions_2 = 0) THEN 'push_surveys'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:13:18] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.13s
‚ÑπÔ∏è [11:13:18] root INFO: Fetched 17 rows for channel push
‚ÑπÔ∏è [11:13:18] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
‚ÑπÔ∏è [11:13:18] root INFO: Cleaning up DB connection
‚ÑπÔ∏è [11:16:49] root INFO: ================================================================================
TLPTACO RUN START 2025-07-28 11:16:49
================================================================================
‚ÑπÔ∏è [11:16:49] root INFO: Calculating the number of steps for the eligibility run.
‚ÑπÔ∏è [11:16:49] root INFO: No cached SQL found. Generating new SQL statements.
‚ÑπÔ∏è [11:16:49] root INFO: Calculation complete: 3 steps.
‚ÑπÔ∏è [11:16:49] root INFO: Calculating the number of waterfall steps.
‚ÑπÔ∏è [11:16:49] root INFO: No cached steps found. Preparing waterfall groups and SQL.
‚ÑπÔ∏è [11:16:49] root INFO: Calculation complete: 3 steps (reports).
‚ÑπÔ∏è [11:16:49] root INFO: Calculating the number of output steps.
‚ÑπÔ∏è [11:16:49] root INFO: No cached steps found. Preparing output jobs and SQL.
‚ÑπÔ∏è [11:16:49] root INFO: Preparing logic for channel 'email'
‚ÑπÔ∏è [11:16:49] root INFO: Preparing logic for channel 'sms'
‚ÑπÔ∏è [11:16:49] root INFO: Preparing logic for channel 'push'
‚ÑπÔ∏è [11:16:49] root INFO: Calculation complete: 3 steps (files).
‚ÑπÔ∏è [11:16:49] root INFO: Using cached SQL statements.
‚ÑπÔ∏è [11:16:49] root INFO: Dropping existing table eligibility_poc
‚ÑπÔ∏è [11:16:49] root INFO: Executing SQL statement
üêõ [11:16:49] root DEBUG: DROP TABLE eligibility_poc;
‚ÑπÔ∏è [11:16:50] root INFO: SQL execution finished in 0.99s
‚ÑπÔ∏è [11:16:50] root INFO: Executing eligibility SQL statement
‚ÑπÔ∏è [11:16:50] root INFO: Executing SQL statement
üêõ [11:16:50] root DEBUG: -- Jinja2 template for eligibility SQL

-- Context:
-- eligibility_table: name of final eligibility table
-- unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
-- unique_without_aliases: list of column names only (e.g. ['col'])
-- checks: list of dicts {name: column_name, sql: expression}
-- tables: list of dicts {name, alias, join_type, join_conditions}
-- where_clauses: list of strings

CREATE TABLE eligibility_poc AS (
SELECT
c.customer_id,
a.account_id,
r.region_id,
s.segment_id,
CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_BA_1,
CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_BA_2,
CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_BA_1,
CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo_1,
CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo_2,
CASE WHEN s.segment_flag IN ('FlagA','FlagB') THEN 1 ELSE 0 END AS email_loyalty_1,
CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_BA_1,
CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_tx_1,
CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_tx_2,
CASE WHEN s.segment_flag IN ('FlagA','FlagB') THEN 1 ELSE 0 END AS sms_rfm_1,
CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promotions_1,
CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promotions_2,
CASE WHEN s.segment_flag IN ('FlagA','FlagB') THEN 1 ELSE 0 END AS push_surveys_1
FROM customers c
LEFT JOIN accounts a
ON a.customer_id = c.customer_id
LEFT JOIN regions r
ON r.customer_id = c.customer_id
LEFT JOIN segments s
ON s.customer_id = c.customer_id
) WITH DATA PRIMARY INDEX prindx (customer_id, account_id, region_id, segment_id)
‚ÑπÔ∏è [11:16:50] root INFO: SQL execution finished in 0.47s
‚ÑπÔ∏è [11:16:50] root INFO: Executing eligibility SQL statement
‚ÑπÔ∏è [11:16:50] root INFO: Executing SQL statement
üêõ [11:16:50] root DEBUG: 

-- MODIFIED: Collect stats only on the primary index for robustness.
COLLECT STATISTICS INDEX prindx ON eligibility_poc
‚ÑπÔ∏è [11:16:51] root INFO: SQL execution finished in 0.14s
‚ÑπÔ∏è [11:16:51] root INFO: Using cached waterfall steps.
‚ÑπÔ∏è [11:16:51] root INFO: Fetching data to DataFrame
üêõ [11:16:51] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:16:51] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.54s
‚ÑπÔ∏è [11:16:51] root INFO: Fetching data to DataFrame
üêõ [11:16:51] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        email_BA_1,email_promo_1,email_promo_2,email_loyalty_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_promo_1 = 1 AND email_promo_2 = 1)) OR ((email_loyalty_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:16:51] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
‚ÑπÔ∏è [11:16:51] root INFO: Fetching data to DataFrame
üêõ [11:16:51] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - promo' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - loyalty' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:16:52] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.99s
‚ÑπÔ∏è [11:16:52] root INFO: Fetching data to DataFrame
üêõ [11:16:52] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            sms_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                sms_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        sms_BA_1,sms_tx_1,sms_tx_2,sms_rfm_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'sms_BA_1'    AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'sms_BA_1'        AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'sms_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN sms_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                     AND ( ((sms_tx_1 = 1 AND sms_tx_2 = 1)) OR ((sms_rfm_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:16:53] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
‚ÑπÔ∏è [11:16:53] root INFO: Fetching data to DataFrame
üêõ [11:16:53] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               sms_tx_1+sms_tx_2+sms_rfm_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   sms_tx_1 + 
                   sms_tx_1 * sms_tx_2 + 
                   sms_tx_1 * sms_tx_2 * sms_rfm_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (sms_tx_1 = 1 AND sms_tx_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (sms_tx_1 = 1 AND sms_tx_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (sms_rfm_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: sms - tx ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - tx' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND ( sms_tx_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND ( sms_tx_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1 AND sms_tx_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND sms_tx_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 AND sms_tx_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: sms - rfm ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - rfm' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_rfm_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'regain'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'remaining'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_rfm_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:16:54] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.37s
‚ÑπÔ∏è [11:16:54] root INFO: Fetching data to DataFrame
üêõ [11:16:54] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND 1=1
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               push_promotions_1+push_promotions_2+push_surveys_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   push_promotions_1 + 
                   push_promotions_1 * push_promotions_2 + 
                   push_promotions_1 * push_promotions_2 * push_surveys_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (push_promotions_1 = 1 AND push_promotions_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (push_promotions_1 = 1 AND push_promotions_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (push_surveys_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: push - promotions ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - promotions' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND ( push_promotions_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND ( push_promotions_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1 AND push_promotions_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND push_promotions_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 AND push_promotions_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: push - surveys ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - surveys' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - surveys'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_surveys_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'regain'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'remaining'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_surveys_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:16:55] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.18s
‚ÑπÔ∏è [11:16:55] root INFO: Fetching data to DataFrame
üêõ [11:16:55] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:16:56] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.49s
‚ÑπÔ∏è [11:16:56] root INFO: Fetching data to DataFrame
üêõ [11:16:56] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        email_BA_1,email_promo_1,email_promo_2,email_loyalty_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_promo_1 = 1 AND email_promo_2 = 1)) OR ((email_loyalty_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:16:56] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
‚ÑπÔ∏è [11:16:56] root INFO: Fetching data to DataFrame
üêõ [11:16:56] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - promo' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - loyalty' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:16:57] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.04s
‚ÑπÔ∏è [11:16:57] root INFO: Fetching data to DataFrame
üêõ [11:16:57] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            sms_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                sms_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        sms_BA_1,sms_tx_1,sms_tx_2,sms_rfm_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'sms_BA_1'    AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'sms_BA_1'        AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'sms_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN sms_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                     AND ( ((sms_tx_1 = 1 AND sms_tx_2 = 1)) OR ((sms_rfm_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:16:57] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
‚ÑπÔ∏è [11:16:57] root INFO: Fetching data to DataFrame
üêõ [11:16:57] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               sms_tx_1+sms_tx_2+sms_rfm_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   sms_tx_1 + 
                   sms_tx_1 * sms_tx_2 + 
                   sms_tx_1 * sms_tx_2 * sms_rfm_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (sms_tx_1 = 1 AND sms_tx_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (sms_tx_1 = 1 AND sms_tx_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (sms_rfm_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: sms - tx ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - tx' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND ( sms_tx_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND ( sms_tx_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1 AND sms_tx_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND sms_tx_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 AND sms_tx_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: sms - rfm ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - rfm' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_rfm_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'regain'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'remaining'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_rfm_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:16:58] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.00s
‚ÑπÔ∏è [11:16:58] root INFO: Fetching data to DataFrame
üêõ [11:16:58] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND 1=1
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               push_promotions_1+push_promotions_2+push_surveys_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   push_promotions_1 + 
                   push_promotions_1 * push_promotions_2 + 
                   push_promotions_1 * push_promotions_2 * push_surveys_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (push_promotions_1 = 1 AND push_promotions_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (push_promotions_1 = 1 AND push_promotions_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (push_surveys_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: push - promotions ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - promotions' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND ( push_promotions_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND ( push_promotions_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1 AND push_promotions_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND push_promotions_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 AND push_promotions_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: push - surveys ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - surveys' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - surveys'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_surveys_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'regain'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'remaining'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_surveys_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:17:00] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.05s
‚ÑπÔ∏è [11:17:00] root INFO: Fetching data to DataFrame
üêõ [11:17:00] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:17:00] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.52s
‚ÑπÔ∏è [11:17:00] root INFO: Fetching data to DataFrame
üêõ [11:17:00] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        email_BA_1,email_promo_1,email_promo_2,email_loyalty_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_promo_1 = 1 AND email_promo_2 = 1)) OR ((email_loyalty_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:17:00] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
‚ÑπÔ∏è [11:17:00] root INFO: Fetching data to DataFrame
üêõ [11:17:00] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - promo' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - loyalty' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:17:01] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.15s
‚ÑπÔ∏è [11:17:01] root INFO: Fetching data to DataFrame
üêõ [11:17:01] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            sms_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                sms_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        sms_BA_1,sms_tx_1,sms_tx_2,sms_rfm_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'sms_BA_1'    AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'sms_BA_1'        AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'sms_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN sms_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                     AND ( ((sms_tx_1 = 1 AND sms_tx_2 = 1)) OR ((sms_rfm_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:17:02] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
‚ÑπÔ∏è [11:17:02] root INFO: Fetching data to DataFrame
üêõ [11:17:02] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               sms_tx_1+sms_tx_2+sms_rfm_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   sms_tx_1 + 
                   sms_tx_1 * sms_tx_2 + 
                   sms_tx_1 * sms_tx_2 * sms_rfm_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (sms_tx_1 = 1 AND sms_tx_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (sms_tx_1 = 1 AND sms_tx_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (sms_rfm_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: sms - tx ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - tx' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND ( sms_tx_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND ( sms_tx_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1 AND sms_tx_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND sms_tx_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 AND sms_tx_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: sms - rfm ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - rfm' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_rfm_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'regain'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'remaining'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_rfm_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:17:03] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.99s
‚ÑπÔ∏è [11:17:03] root INFO: Fetching data to DataFrame
üêõ [11:17:03] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND 1=1
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               push_promotions_1+push_promotions_2+push_surveys_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   push_promotions_1 + 
                   push_promotions_1 * push_promotions_2 + 
                   push_promotions_1 * push_promotions_2 * push_surveys_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (push_promotions_1 = 1 AND push_promotions_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (push_promotions_1 = 1 AND push_promotions_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (push_surveys_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: push - promotions ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - promotions' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND ( push_promotions_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND ( push_promotions_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1 AND push_promotions_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND push_promotions_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 AND push_promotions_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: push - surveys ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - surveys' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - surveys'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_surveys_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'regain'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'remaining'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_surveys_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:17:04] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.98s
‚ÑπÔ∏è [11:17:04] root INFO: Consolidated waterfall report written to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/XX001_2025_07_28_11:17:04.xlsx
‚ÑπÔ∏è [11:17:04] root INFO: Waterfall run history appended to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_history.sqlite
‚ÑπÔ∏è [11:17:04] root INFO: Using cached output steps.
‚ÑπÔ∏è [11:17:04] root INFO: Running output job for channel email
üêõ [11:17:04] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) THEN 'email_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) AND (c.email_promo_1 = 1 AND c.email_promo_2 = 1) THEN 'email_promo'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) AND (c.email_loyalty_1 = 1) AND (c.email_promo_1 = 0 OR c.email_promo_2 = 0) THEN 'email_loyalty'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:17:04] root INFO: Fetching data to DataFrame
üêõ [11:17:04] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) THEN 'email_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) AND (c.email_promo_1 = 1 AND c.email_promo_2 = 1) THEN 'email_promo'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) AND (c.email_loyalty_1 = 1) AND (c.email_promo_1 = 0 OR c.email_promo_2 = 0) THEN 'email_loyalty'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:17:04] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.12s
‚ÑπÔ∏è [11:17:04] root INFO: Fetched 17 rows for channel email
‚ÑπÔ∏è [11:17:04] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
‚ÑπÔ∏è [11:17:04] root INFO: Running output job for channel sms
üêõ [11:17:04] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) THEN 'sms_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_tx_1 = 1 AND c.sms_tx_2 = 1) THEN 'sms_tx'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_rfm_1 = 1) AND (c.sms_tx_1 = 0 OR c.sms_tx_2 = 0) THEN 'sms_rfm'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:17:04] root INFO: Fetching data to DataFrame
üêõ [11:17:04] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) THEN 'sms_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_tx_1 = 1 AND c.sms_tx_2 = 1) THEN 'sms_tx'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_rfm_1 = 1) AND (c.sms_tx_1 = 0 OR c.sms_tx_2 = 0) THEN 'sms_rfm'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:17:04] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.13s
‚ÑπÔ∏è [11:17:04] root INFO: Fetched 8 rows for channel sms
‚ÑπÔ∏è [11:17:04] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
‚ÑπÔ∏è [11:17:04] root INFO: Running output job for channel push
üêõ [11:17:04] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) THEN 'push_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) AND (c.push_promotions_1 = 1 AND c.push_promotions_2 = 1) THEN 'push_promotions'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) AND (c.push_surveys_1 = 1) AND (c.push_promotions_1 = 0 OR c.push_promotions_2 = 0) THEN 'push_surveys'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:17:04] root INFO: Fetching data to DataFrame
üêõ [11:17:04] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) THEN 'push_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) AND (c.push_promotions_1 = 1 AND c.push_promotions_2 = 1) THEN 'push_promotions'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) AND (c.push_surveys_1 = 1) AND (c.push_promotions_1 = 0 OR c.push_promotions_2 = 0) THEN 'push_surveys'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:17:04] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.13s
‚ÑπÔ∏è [11:17:04] root INFO: Fetched 17 rows for channel push
‚ÑπÔ∏è [11:17:04] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
‚ÑπÔ∏è [11:17:04] root INFO: Cleaning up DB connection
‚ÑπÔ∏è [11:19:33] root INFO: ================================================================================
TLPTACO RUN START 2025-07-28 11:19:33
================================================================================
‚ÑπÔ∏è [11:19:33] root INFO: Calculating the number of steps for the eligibility run.
‚ÑπÔ∏è [11:19:33] root INFO: No cached SQL found. Generating new SQL statements.
‚ÑπÔ∏è [11:19:33] root INFO: Calculation complete: 3 steps.
‚ÑπÔ∏è [11:19:33] root INFO: Calculating the number of waterfall steps.
‚ÑπÔ∏è [11:19:33] root INFO: No cached steps found. Preparing waterfall groups and SQL.
‚ÑπÔ∏è [11:19:33] root INFO: Calculation complete: 3 steps (reports).
‚ÑπÔ∏è [11:19:33] root INFO: Calculating the number of output steps.
‚ÑπÔ∏è [11:19:33] root INFO: No cached steps found. Preparing output jobs and SQL.
‚ÑπÔ∏è [11:19:33] root INFO: Preparing logic for channel 'email'
‚ÑπÔ∏è [11:19:33] root INFO: Preparing logic for channel 'sms'
‚ÑπÔ∏è [11:19:33] root INFO: Preparing logic for channel 'push'
‚ÑπÔ∏è [11:19:33] root INFO: Calculation complete: 3 steps (files).
‚ÑπÔ∏è [11:19:33] root INFO: Using cached SQL statements.
‚ÑπÔ∏è [11:19:33] root INFO: Dropping existing table eligibility_poc
‚ÑπÔ∏è [11:19:33] root INFO: Executing SQL statement
üêõ [11:19:33] root DEBUG: DROP TABLE eligibility_poc;
‚ÑπÔ∏è [11:19:34] root INFO: SQL execution finished in 0.91s
‚ÑπÔ∏è [11:19:34] root INFO: Executing eligibility SQL statement
‚ÑπÔ∏è [11:19:34] root INFO: Executing SQL statement
üêõ [11:19:34] root DEBUG: -- Jinja2 template for eligibility SQL

-- Context:
-- eligibility_table: name of final eligibility table
-- unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
-- unique_without_aliases: list of column names only (e.g. ['col'])
-- checks: list of dicts {name: column_name, sql: expression}
-- tables: list of dicts {name, alias, join_type, join_conditions}
-- where_clauses: list of strings

CREATE TABLE eligibility_poc AS (
SELECT
c.customer_id,
a.account_id,
r.region_id,
s.segment_id,
CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_BA_1,
CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_BA_1,
CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo_1,
CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo_2,
CASE WHEN s.segment_flag IN ('FlagA','FlagB') THEN 1 ELSE 0 END AS email_loyalty_1,
CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_BA_1,
CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_tx_1,
CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_tx_2,
CASE WHEN s.segment_flag IN ('FlagA','FlagB') THEN 1 ELSE 0 END AS sms_rfm_1,
CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promotions_1,
CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promotions_2,
CASE WHEN s.segment_flag IN ('FlagA','FlagB') THEN 1 ELSE 0 END AS push_surveys_1
FROM customers c
LEFT JOIN accounts a
ON a.customer_id = c.customer_id
LEFT JOIN regions r
ON r.customer_id = c.customer_id
LEFT JOIN segments s
ON s.customer_id = c.customer_id
) WITH DATA PRIMARY INDEX prindx (customer_id, account_id, region_id, segment_id)
‚ÑπÔ∏è [11:19:35] root INFO: SQL execution finished in 0.49s
‚ÑπÔ∏è [11:19:35] root INFO: Executing eligibility SQL statement
‚ÑπÔ∏è [11:19:35] root INFO: Executing SQL statement
üêõ [11:19:35] root DEBUG: 

-- MODIFIED: Collect stats only on the primary index for robustness.
COLLECT STATISTICS INDEX prindx ON eligibility_poc
‚ÑπÔ∏è [11:19:35] root INFO: SQL execution finished in 0.16s
‚ÑπÔ∏è [11:19:35] root INFO: Using cached waterfall steps.
‚ÑπÔ∏è [11:19:35] root INFO: Fetching data to DataFrame
üêõ [11:19:35] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        main_BA_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:19:35] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.32s
‚ÑπÔ∏è [11:19:35] root INFO: Fetching data to DataFrame
üêõ [11:19:35] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        email_BA_1,email_promo_1,email_promo_2,email_loyalty_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_promo_1 = 1 AND email_promo_2 = 1)) OR ((email_loyalty_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:19:36] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
‚ÑπÔ∏è [11:19:36] root INFO: Fetching data to DataFrame
üêõ [11:19:36] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - promo' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - loyalty' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:19:37] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.11s
‚ÑπÔ∏è [11:19:37] root INFO: Fetching data to DataFrame
üêõ [11:19:37] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            sms_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                sms_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        sms_BA_1,sms_tx_1,sms_tx_2,sms_rfm_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'sms_BA_1'    AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'sms_BA_1'        AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'sms_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN sms_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                     AND ( ((sms_tx_1 = 1 AND sms_tx_2 = 1)) OR ((sms_rfm_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:19:37] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.41s
‚ÑπÔ∏è [11:19:37] root INFO: Fetching data to DataFrame
üêõ [11:19:37] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1) AND (c.sms_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               sms_tx_1+sms_tx_2+sms_rfm_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   sms_tx_1 + 
                   sms_tx_1 * sms_tx_2 + 
                   sms_tx_1 * sms_tx_2 * sms_rfm_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (sms_tx_1 = 1 AND sms_tx_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (sms_tx_1 = 1 AND sms_tx_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (sms_rfm_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: sms - tx ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - tx' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND ( sms_tx_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND ( sms_tx_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1 AND sms_tx_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND sms_tx_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 AND sms_tx_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: sms - rfm ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - rfm' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_rfm_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'regain'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'remaining'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_rfm_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:19:38] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.23s
‚ÑπÔ∏è [11:19:38] root INFO: Fetching data to DataFrame
üêõ [11:19:38] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1) AND 1=1
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               push_promotions_1+push_promotions_2+push_surveys_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   push_promotions_1 + 
                   push_promotions_1 * push_promotions_2 + 
                   push_promotions_1 * push_promotions_2 * push_surveys_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (push_promotions_1 = 1 AND push_promotions_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (push_promotions_1 = 1 AND push_promotions_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (push_surveys_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: push - promotions ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - promotions' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND ( push_promotions_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND ( push_promotions_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1 AND push_promotions_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND push_promotions_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 AND push_promotions_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: push - surveys ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - surveys' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - surveys'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_surveys_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'regain'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'remaining'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_surveys_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:19:39] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.93s
‚ÑπÔ∏è [11:19:39] root INFO: Fetching data to DataFrame
üêõ [11:19:39] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        main_BA_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:19:40] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
‚ÑπÔ∏è [11:19:40] root INFO: Fetching data to DataFrame
üêõ [11:19:40] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        email_BA_1,email_promo_1,email_promo_2,email_loyalty_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_promo_1 = 1 AND email_promo_2 = 1)) OR ((email_loyalty_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:19:40] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
‚ÑπÔ∏è [11:19:40] root INFO: Fetching data to DataFrame
üêõ [11:19:40] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - promo' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - loyalty' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:19:41] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.97s
‚ÑπÔ∏è [11:19:41] root INFO: Fetching data to DataFrame
üêõ [11:19:41] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            sms_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                sms_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        sms_BA_1,sms_tx_1,sms_tx_2,sms_rfm_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'sms_BA_1'    AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'sms_BA_1'        AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'sms_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN sms_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                     AND ( ((sms_tx_1 = 1 AND sms_tx_2 = 1)) OR ((sms_rfm_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:19:41] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
‚ÑπÔ∏è [11:19:41] root INFO: Fetching data to DataFrame
üêõ [11:19:41] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1) AND (c.sms_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               sms_tx_1+sms_tx_2+sms_rfm_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   sms_tx_1 + 
                   sms_tx_1 * sms_tx_2 + 
                   sms_tx_1 * sms_tx_2 * sms_rfm_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (sms_tx_1 = 1 AND sms_tx_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (sms_tx_1 = 1 AND sms_tx_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (sms_rfm_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: sms - tx ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - tx' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND ( sms_tx_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND ( sms_tx_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1 AND sms_tx_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND sms_tx_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 AND sms_tx_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: sms - rfm ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - rfm' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_rfm_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'regain'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'remaining'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_rfm_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:19:42] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.87s
‚ÑπÔ∏è [11:19:42] root INFO: Fetching data to DataFrame
üêõ [11:19:42] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1) AND 1=1
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               push_promotions_1+push_promotions_2+push_surveys_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   push_promotions_1 + 
                   push_promotions_1 * push_promotions_2 + 
                   push_promotions_1 * push_promotions_2 * push_surveys_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (push_promotions_1 = 1 AND push_promotions_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (push_promotions_1 = 1 AND push_promotions_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (push_surveys_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: push - promotions ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - promotions' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND ( push_promotions_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND ( push_promotions_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1 AND push_promotions_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND push_promotions_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 AND push_promotions_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: push - surveys ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - surveys' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - surveys'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_surveys_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'regain'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'remaining'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_surveys_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:19:43] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.93s
‚ÑπÔ∏è [11:19:43] root INFO: Fetching data to DataFrame
üêõ [11:19:43] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        main_BA_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:19:43] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
‚ÑπÔ∏è [11:19:43] root INFO: Fetching data to DataFrame
üêõ [11:19:43] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        email_BA_1,email_promo_1,email_promo_2,email_loyalty_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_promo_1 = 1 AND email_promo_2 = 1)) OR ((email_loyalty_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:19:43] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
‚ÑπÔ∏è [11:19:43] root INFO: Fetching data to DataFrame
üêõ [11:19:43] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - promo' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - loyalty' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:19:44] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.93s
‚ÑπÔ∏è [11:19:44] root INFO: Fetching data to DataFrame
üêõ [11:19:44] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            sms_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                sms_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        sms_BA_1,sms_tx_1,sms_tx_2,sms_rfm_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'sms_BA_1'    AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'sms_BA_1'        AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'sms_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN sms_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                     AND ( ((sms_tx_1 = 1 AND sms_tx_2 = 1)) OR ((sms_rfm_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [11:19:45] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
‚ÑπÔ∏è [11:19:45] root INFO: Fetching data to DataFrame
üêõ [11:19:45] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1) AND (c.sms_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               sms_tx_1+sms_tx_2+sms_rfm_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   sms_tx_1 + 
                   sms_tx_1 * sms_tx_2 + 
                   sms_tx_1 * sms_tx_2 * sms_rfm_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (sms_tx_1 = 1 AND sms_tx_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (sms_tx_1 = 1 AND sms_tx_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (sms_rfm_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: sms - tx ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - tx' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND ( sms_tx_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND ( sms_tx_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1 AND sms_tx_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND sms_tx_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 AND sms_tx_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: sms - rfm ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - rfm' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_rfm_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'regain'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'remaining'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_rfm_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:19:46] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.91s
‚ÑπÔ∏è [11:19:46] root INFO: Fetching data to DataFrame
üêõ [11:19:46] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1) AND 1=1
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               push_promotions_1+push_promotions_2+push_surveys_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   push_promotions_1 + 
                   push_promotions_1 * push_promotions_2 + 
                   push_promotions_1 * push_promotions_2 * push_surveys_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (push_promotions_1 = 1 AND push_promotions_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (push_promotions_1 = 1 AND push_promotions_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (push_surveys_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: push - promotions ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - promotions' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND ( push_promotions_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND ( push_promotions_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1 AND push_promotions_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND push_promotions_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 AND push_promotions_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: push - surveys ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - surveys' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - surveys'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_surveys_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'regain'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'remaining'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_surveys_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [11:19:47] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.91s
‚ÑπÔ∏è [11:19:47] root INFO: Consolidated waterfall report written to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/XX001_2025_07_28_11:19:47.xlsx
‚ÑπÔ∏è [11:19:47] root INFO: Waterfall run history appended to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_history.sqlite
‚ÑπÔ∏è [11:19:47] root INFO: Using cached output steps.
‚ÑπÔ∏è [11:19:47] root INFO: Running output job for channel email
üêõ [11:19:47] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1) AND (c.email_BA_1 = 1) THEN 'email_BA'
            WHEN (c.main_BA_1 = 1) AND (c.email_BA_1 = 1) AND (c.email_promo_1 = 1 AND c.email_promo_2 = 1) THEN 'email_promo'
            WHEN (c.main_BA_1 = 1) AND (c.email_BA_1 = 1) AND (c.email_loyalty_1 = 1) AND (c.email_promo_1 = 0 OR c.email_promo_2 = 0) THEN 'email_loyalty'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:19:47] root INFO: Fetching data to DataFrame
üêõ [11:19:47] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1) AND (c.email_BA_1 = 1) THEN 'email_BA'
            WHEN (c.main_BA_1 = 1) AND (c.email_BA_1 = 1) AND (c.email_promo_1 = 1 AND c.email_promo_2 = 1) THEN 'email_promo'
            WHEN (c.main_BA_1 = 1) AND (c.email_BA_1 = 1) AND (c.email_loyalty_1 = 1) AND (c.email_promo_1 = 0 OR c.email_promo_2 = 0) THEN 'email_loyalty'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:19:47] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.12s
‚ÑπÔ∏è [11:19:47] root INFO: Fetched 17 rows for channel email
‚ÑπÔ∏è [11:19:47] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
‚ÑπÔ∏è [11:19:47] root INFO: Running output job for channel sms
üêõ [11:19:47] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1) AND (c.sms_BA_1 = 1) THEN 'sms_BA'
            WHEN (c.main_BA_1 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_tx_1 = 1 AND c.sms_tx_2 = 1) THEN 'sms_tx'
            WHEN (c.main_BA_1 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_rfm_1 = 1) AND (c.sms_tx_1 = 0 OR c.sms_tx_2 = 0) THEN 'sms_rfm'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:19:47] root INFO: Fetching data to DataFrame
üêõ [11:19:47] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1) AND (c.sms_BA_1 = 1) THEN 'sms_BA'
            WHEN (c.main_BA_1 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_tx_1 = 1 AND c.sms_tx_2 = 1) THEN 'sms_tx'
            WHEN (c.main_BA_1 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_rfm_1 = 1) AND (c.sms_tx_1 = 0 OR c.sms_tx_2 = 0) THEN 'sms_rfm'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:19:47] root INFO: Fetched DataFrame with 25 rows and 5 columns in 0.13s
‚ÑπÔ∏è [11:19:47] root INFO: Fetched 25 rows for channel sms
‚ÑπÔ∏è [11:19:47] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
‚ÑπÔ∏è [11:19:47] root INFO: Running output job for channel push
üêõ [11:19:47] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1) AND (1 = 1) THEN 'push_BA'
            WHEN (c.main_BA_1 = 1) AND (1 = 1) AND (c.push_promotions_1 = 1 AND c.push_promotions_2 = 1) THEN 'push_promotions'
            WHEN (c.main_BA_1 = 1) AND (1 = 1) AND (c.push_surveys_1 = 1) AND (c.push_promotions_1 = 0 OR c.push_promotions_2 = 0) THEN 'push_surveys'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:19:47] root INFO: Fetching data to DataFrame
üêõ [11:19:47] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1) AND (1 = 1) THEN 'push_BA'
            WHEN (c.main_BA_1 = 1) AND (1 = 1) AND (c.push_promotions_1 = 1 AND c.push_promotions_2 = 1) THEN 'push_promotions'
            WHEN (c.main_BA_1 = 1) AND (1 = 1) AND (c.push_surveys_1 = 1) AND (c.push_promotions_1 = 0 OR c.push_promotions_2 = 0) THEN 'push_surveys'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [11:19:47] root INFO: Fetched DataFrame with 50 rows and 5 columns in 0.13s
‚ÑπÔ∏è [11:19:47] root INFO: Fetched 50 rows for channel push
‚ÑπÔ∏è [11:19:47] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
‚ÑπÔ∏è [11:19:47] root INFO: Cleaning up DB connection
‚ÑπÔ∏è [16:21:46] root INFO: ================================================================================
TLPTACO RUN START 2025-07-28 16:21:46
================================================================================
‚ÑπÔ∏è [16:21:46] root INFO: Calculating the number of steps for the eligibility run.
‚ÑπÔ∏è [16:21:46] root INFO: No cached SQL found. Generating new SQL statements.
‚ÑπÔ∏è [16:21:46] root INFO: Calculation complete: 3 steps.
‚ÑπÔ∏è [16:21:46] root INFO: Calculating the number of waterfall steps.
‚ÑπÔ∏è [16:21:46] root INFO: No cached steps found. Preparing waterfall groups and SQL.
‚ÑπÔ∏è [16:21:46] root INFO: Calculation complete: 3 steps (reports).
‚ÑπÔ∏è [16:21:46] root INFO: Calculating the number of output steps.
‚ÑπÔ∏è [16:21:46] root INFO: No cached steps found. Preparing output jobs and SQL.
‚ÑπÔ∏è [16:21:46] root INFO: Preparing logic for channel 'email'
‚ÑπÔ∏è [16:21:46] root INFO: Preparing logic for channel 'sms'
‚ÑπÔ∏è [16:21:46] root INFO: Preparing logic for channel 'push'
‚ÑπÔ∏è [16:21:46] root INFO: Calculation complete: 3 steps (files).
‚ÑπÔ∏è [16:21:46] root INFO: Using cached SQL statements.
‚ÑπÔ∏è [16:21:46] root INFO: Dropping existing table eligibility_poc
‚ÑπÔ∏è [16:21:46] root INFO: Executing SQL statement
üêõ [16:21:46] root DEBUG: DROP TABLE eligibility_poc;
‚ÑπÔ∏è [16:21:47] root INFO: SQL execution finished in 1.36s
‚ÑπÔ∏è [16:21:47] root INFO: Executing eligibility SQL statement
‚ÑπÔ∏è [16:21:47] root INFO: Executing SQL statement
üêõ [16:21:47] root DEBUG: -- Jinja2 template for eligibility SQL

-- Context:
-- eligibility_table: name of final eligibility table
-- unique_identifiers: list of identifiers with alias (e.g. ['a.col', 'b.col'])
-- unique_without_aliases: list of column names only (e.g. ['col'])
-- checks: list of dicts {name: column_name, sql: expression}
-- tables: list of dicts {name, alias, join_type, join_conditions}
-- where_clauses: list of strings

CREATE TABLE eligibility_poc AS (
SELECT
c.customer_id,
a.account_id,
r.region_id,
s.segment_id,
CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS main_BA_1,
CASE WHEN a.account_id IS NOT NULL THEN 1 ELSE 0 END AS main_BA_2,
CASE WHEN c.status = 'Active' THEN 1 ELSE 0 END AS email_BA_1,
CASE WHEN s.segment_flag = 'Promo1' THEN 1 ELSE 0 END AS email_promo_1,
CASE WHEN s.segment_flag = 'Promo2' THEN 1 ELSE 0 END AS email_promo_2,
CASE WHEN s.segment_flag IN ('FlagA','FlagB') THEN 1 ELSE 0 END AS email_loyalty_1,
CASE WHEN a.acct_type = 'Savings' THEN 1 ELSE 0 END AS sms_BA_1,
CASE WHEN s.segment_flag = 'HighTx' THEN 1 ELSE 0 END AS sms_tx_1,
CASE WHEN s.segment_flag = 'LowTx' THEN 1 ELSE 0 END AS sms_tx_2,
CASE WHEN s.segment_flag IN ('FlagA','FlagB') THEN 1 ELSE 0 END AS sms_rfm_1,
CASE WHEN s.segment_flag = 'PromoA' THEN 1 ELSE 0 END AS push_promotions_1,
CASE WHEN s.segment_flag = 'PromoB' THEN 1 ELSE 0 END AS push_promotions_2,
CASE WHEN s.segment_flag IN ('FlagA','FlagB') THEN 1 ELSE 0 END AS push_surveys_1
FROM customers c
LEFT JOIN accounts a
ON a.customer_id = c.customer_id
LEFT JOIN regions r
ON r.customer_id = c.customer_id
LEFT JOIN segments s
ON s.customer_id = c.customer_id
) WITH DATA PRIMARY INDEX prindx (customer_id, account_id, region_id, segment_id)
‚ÑπÔ∏è [16:21:48] root INFO: SQL execution finished in 0.55s
‚ÑπÔ∏è [16:21:48] root INFO: Executing eligibility SQL statement
‚ÑπÔ∏è [16:21:48] root INFO: Executing SQL statement
üêõ [16:21:48] root DEBUG: 

-- MODIFIED: Collect stats only on the primary index for robustness.
COLLECT STATISTICS INDEX prindx ON eligibility_poc
‚ÑπÔ∏è [16:21:48] root INFO: SQL execution finished in 0.16s
‚ÑπÔ∏è [16:21:48] root INFO: Using cached waterfall steps.
‚ÑπÔ∏è [16:21:48] root INFO: Fetching data to DataFrame
üêõ [16:21:48] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [16:21:49] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.53s
‚ÑπÔ∏è [16:21:49] root INFO: Fetching data to DataFrame
üêõ [16:21:49] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        email_BA_1,email_promo_1,email_promo_2,email_loyalty_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_promo_1 = 1 AND email_promo_2 = 1)) OR ((email_loyalty_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [16:21:49] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.29s
‚ÑπÔ∏è [16:21:49] root INFO: Fetching data to DataFrame
üêõ [16:21:49] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - promo' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - loyalty' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, email_loyalty_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [16:21:50] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.92s
‚ÑπÔ∏è [16:21:50] root INFO: Fetching data to DataFrame
üêõ [16:21:50] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            sms_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                sms_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id, 
        sms_BA_1,sms_tx_1,sms_tx_2,sms_rfm_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'sms_BA_1'    AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'sms_BA_1'        AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'sms_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN sms_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                     AND ( ((sms_tx_1 = 1 AND sms_tx_2 = 1)) OR ((sms_rfm_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [16:21:50] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.35s
‚ÑπÔ∏è [16:21:50] root INFO: Fetching data to DataFrame
üêõ [16:21:50] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               sms_tx_1+sms_tx_2+sms_rfm_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   sms_tx_1 + 
                   sms_tx_1 * sms_tx_2 + 
                   sms_tx_1 * sms_tx_2 * sms_rfm_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (sms_tx_1 = 1 AND sms_tx_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (sms_tx_1 = 1 AND sms_tx_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (sms_rfm_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: sms - tx ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - tx' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND ( sms_tx_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND ( sms_tx_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1 AND sms_tx_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND sms_tx_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 AND sms_tx_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, sms_tx_1, sms_tx_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: sms - rfm ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - rfm' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_rfm_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'regain'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'remaining'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_rfm_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, sms_rfm_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [16:21:51] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.91s
‚ÑπÔ∏è [16:21:51] root INFO: Fetching data to DataFrame
üêõ [16:21:51] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND 1=1
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               push_promotions_1+push_promotions_2+push_surveys_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   push_promotions_1 + 
                   push_promotions_1 * push_promotions_2 + 
                   push_promotions_1 * push_promotions_2 * push_surveys_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (push_promotions_1 = 1 AND push_promotions_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (push_promotions_1 = 1 AND push_promotions_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (push_surveys_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: push - promotions ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - promotions' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND ( push_promotions_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND ( push_promotions_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1 AND push_promotions_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND push_promotions_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 AND push_promotions_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, push_promotions_1, push_promotions_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: push - surveys ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - surveys' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - surveys'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_surveys_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'regain'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'remaining'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_surveys_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, push_surveys_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [16:21:52] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.91s
‚ÑπÔ∏è [16:21:52] root INFO: Fetching data to DataFrame
üêõ [16:21:52] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [16:21:53] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.43s
‚ÑπÔ∏è [16:21:53] root INFO: Fetching data to DataFrame
üêõ [16:21:53] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        email_BA_1,email_promo_1,email_promo_2,email_loyalty_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_promo_1 = 1 AND email_promo_2 = 1)) OR ((email_loyalty_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [16:21:53] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
‚ÑπÔ∏è [16:21:53] root INFO: Fetching data to DataFrame
üêõ [16:21:53] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - promo' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - loyalty' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, email_loyalty_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [16:21:54] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.97s
‚ÑπÔ∏è [16:21:54] root INFO: Fetching data to DataFrame
üêõ [16:21:54] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            sms_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                sms_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY customer_id, account_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        customer_id,account_id, 
        sms_BA_1,sms_tx_1,sms_tx_2,sms_rfm_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'sms_BA_1'    AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'sms_BA_1'        AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'sms_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN sms_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                     AND ( ((sms_tx_1 = 1 AND sms_tx_2 = 1)) OR ((sms_rfm_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [16:21:54] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.27s
‚ÑπÔ∏è [16:21:54] root INFO: Fetching data to DataFrame
üêõ [16:21:54] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               sms_tx_1+sms_tx_2+sms_rfm_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   sms_tx_1 + 
                   sms_tx_1 * sms_tx_2 + 
                   sms_tx_1 * sms_tx_2 * sms_rfm_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (sms_tx_1 = 1 AND sms_tx_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (sms_tx_1 = 1 AND sms_tx_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (sms_rfm_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: sms - tx ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - tx' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND ( sms_tx_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND ( sms_tx_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1 AND sms_tx_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND sms_tx_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 AND sms_tx_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, sms_tx_1, sms_tx_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: sms - rfm ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - rfm' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_rfm_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'regain'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'remaining'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_rfm_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, sms_rfm_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [16:21:55] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.87s
‚ÑπÔ∏è [16:21:55] root INFO: Fetching data to DataFrame
üêõ [16:21:55] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND 1=1
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               push_promotions_1+push_promotions_2+push_surveys_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   push_promotions_1 + 
                   push_promotions_1 * push_promotions_2 + 
                   push_promotions_1 * push_promotions_2 * push_surveys_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY customer_id, account_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (push_promotions_1 = 1 AND push_promotions_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (push_promotions_1 = 1 AND push_promotions_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (push_surveys_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: push - promotions ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - promotions' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND ( push_promotions_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND ( push_promotions_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1 AND push_promotions_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND push_promotions_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 AND push_promotions_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(customer_id, account_id, push_promotions_1, push_promotions_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: push - surveys ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - surveys' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - surveys'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_surveys_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'regain'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'remaining'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_surveys_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT customer_id,account_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(customer_id, account_id, push_surveys_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [16:21:56] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.92s
‚ÑπÔ∏è [16:21:56] root INFO: Fetching data to DataFrame
üêõ [16:21:56] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            main_BA_1 + main_BA_2 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                main_BA_1 + 
                main_BA_1 * main_BA_2
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        main_BA_1,main_BA_2
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_1'    AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'unique_drops' AS stat_name,
           'main_BA_2'    AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_1'        AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'incremental_drops' AS stat_name,
           'main_BA_2'        AS check_name,
           SUM(CASE WHEN main_BA_2 = 0 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'cumulative_drops' AS stat_name,
           'main_BA_2'       AS check_name,
           COUNT(*) - SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 0
                    AND (main_BA_2 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'regain' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 0
                    AND (main_BA_1 = 1 )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'main_BA_1' AS check_name,
           SUM(CASE WHEN main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    UNION ALL
    
    SELECT 'remaining' AS stat_name,
           'main_BA_2' AS check_name,
           SUM(CASE WHEN main_BA_2 = 1 AND main_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [16:21:56] root INFO: Fetched DataFrame with 11 rows and 3 columns in 0.47s
‚ÑπÔ∏è [16:21:56] root INFO: Fetching data to DataFrame
üêõ [16:21:56] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            email_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                email_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        email_BA_1,email_promo_1,email_promo_2,email_loyalty_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'email_BA_1'    AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'email_BA_1'        AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'email_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN email_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 0
                     AND ( ((email_promo_1 = 1 AND email_promo_2 = 1)) OR ((email_loyalty_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'email_BA_1' AS check_name,
           SUM(CASE WHEN email_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [16:21:57] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.31s
‚ÑπÔ∏è [16:21:57] root INFO: Fetching data to DataFrame
üêõ [16:21:57] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               email_promo_1+email_promo_2+email_loyalty_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   email_promo_1 + 
                   email_promo_1 * email_promo_2 + 
                   email_promo_1 * email_promo_2 * email_loyalty_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (email_promo_1 = 1 AND email_promo_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (email_promo_1 = 1 AND email_promo_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (email_loyalty_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: email - promo ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - promo' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND ( email_promo_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND ( email_promo_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_promo_1 = 1 AND email_promo_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_1 = 0 AND email_promo_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'regain'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_promo_2 = 0 AND email_promo_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    UNION ALL
    
    
    
    SELECT 'email - promo'                             AS section,
           'remaining'                              AS stat_name,
           'email_promo_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_promo_1 = 1 AND email_promo_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_promo_1,email_promo_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, email_promo_1, email_promo_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: email - loyalty ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('email - loyalty' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'unique_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'incremental_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  email_loyalty_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'regain'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN email_loyalty_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'email - loyalty'                             AS section,
           'remaining'                              AS stat_name,
           'email_loyalty_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  email_loyalty_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               email_loyalty_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, email_loyalty_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [16:21:58] root INFO: Fetched DataFrame with 17 rows and 4 columns in 1.33s
‚ÑπÔ∏è [16:21:58] root INFO: Fetching data to DataFrame
üêõ [16:21:58] root DEBUG: -- Waterfall Report (Full / BA-level)
-- ---------------------------------------------------------------------------
-- This Jinja2 template builds a standard 5-metric waterfall for a *linear* list
-- of check columns.  It *deduplicates* the underlying eligibility table on the
-- supplied unique identifiers so that each identifier contributes **at most**
-- one row to the statistics.  The preferred row is chosen by the following
-- heuristic which mirrors the business specification in temp/logic.txt:
--   1.  Row with the *highest* number of passed checks (`pass_cnt`).
--   2.  (Tie-break) Row appearing *first* in physical order (deterministic).
--
-- Context variables (supplied by WaterfallEngine):
--   eligibility_table   : name of smart eligibility table (aliased as c)
--   unique_identifiers  : list[str] ‚Äì fully-qualified identifier columns
--   check_columns       : ordered list[str] of 1/0 flag columns to evaluate
--   pre_filter          : OPTIONAL SQL predicate applied prior to stats
--   bucketable_condition: OPTIONAL predicate used only by the Regain metric
-- ---------------------------------------------------------------------------




    

    





-- TODO: see if I can replace * with the same column selection as the CTE flags table below for efficiency
WITH base_population AS (
    SELECT *
    FROM eligibility_poc c
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1)
),

-- Deduplicate so each identifier group contributes only once.  Preference is
-- given to rows with more passed checks (pass_cnt desc).
deduped AS (
    SELECT *
    FROM (
        SELECT
            bp.*,
            sms_BA_1 AS pass_cnt,
            -- Longest unbroken streak of passes from the left
            (
                sms_BA_1
                
            ) AS streak_len,
            ROW_NUMBER() OVER (
                PARTITION BY region_id, segment_id
                ORDER BY pass_cnt DESC, streak_len DESC
            ) AS _rn
        FROM base_population bp
    ) x
    WHERE _rn = 1
),

flags AS (
    SELECT
        region_id,segment_id, 
        sms_BA_1,sms_tx_1,sms_tx_2,sms_rfm_1
    FROM deduped
)

-- ---------------------------------------------------------------------------
-- Metrics
-- ---------------------------------------------------------------------------
SELECT
    stat_name,
    check_name,
    cntr
FROM (
    -- Starting population (row 0)
    SELECT CAST('initial_population' AS VARCHAR(50))    AS stat_name,
           CAST('Total' AS VARCHAR(50))                 AS check_name,
           COUNT(*)                                     AS cntr
    FROM flags

    UNION ALL

    -- ‚ë†  Drop If Only This Scrub (unique_drops)
    
    SELECT 'unique_drops' AS stat_name,
           'sms_BA_1'    AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                    
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë°  Drop Incremental (incremental_drops)
    
    SELECT 'incremental_drops' AS stat_name,
           'sms_BA_1'        AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë¢  Drop Cumulative (cumulative_drops)
    
    SELECT 'cumulative_drops' AS stat_name,
           'sms_BA_1'       AS check_name,
           COUNT(*) - SUM(CASE WHEN sms_BA_1 = 1
                         THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë£  Regain If No Scrub (regain)
    
    SELECT 'regain' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 0
                     AND ( ((sms_tx_1 = 1 AND sms_tx_2 = 1)) OR ((sms_rfm_1 = 1)) )
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    

    UNION ALL

    -- ‚ë§  Remaining Population (remaining)
    
    SELECT 'remaining' AS stat_name,
           'sms_BA_1' AS check_name,
           SUM(CASE WHEN sms_BA_1 = 1
               THEN 1 ELSE 0 END) AS cntr
    FROM flags
    
    
) AS metrics;
‚ÑπÔ∏è [16:21:59] root INFO: Fetched DataFrame with 6 rows and 3 columns in 0.51s
‚ÑπÔ∏è [16:21:59] root INFO: Fetching data to DataFrame
üêõ [16:21:59] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1)
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               sms_tx_1+sms_tx_2+sms_rfm_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   sms_tx_1 + 
                   sms_tx_1 * sms_tx_2 + 
                   sms_tx_1 * sms_tx_2 * sms_rfm_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (sms_tx_1 = 1 AND sms_tx_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (sms_tx_1 = 1 AND sms_tx_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (sms_rfm_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: sms - tx ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - tx' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND ( sms_tx_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND ( sms_tx_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_tx_1 = 1 AND sms_tx_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_1 = 0 AND sms_tx_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'regain'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_tx_2 = 0 AND sms_tx_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    UNION ALL
    
    
    
    SELECT 'sms - tx'                             AS section,
           'remaining'                              AS stat_name,
           'sms_tx_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_tx_1 = 1 AND sms_tx_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_tx_1,sms_tx_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, sms_tx_1, sms_tx_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: sms - rfm ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('sms - rfm' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'unique_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'incremental_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  sms_rfm_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'regain'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN sms_rfm_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'sms - rfm'                             AS section,
           'remaining'                              AS stat_name,
           'sms_rfm_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  sms_rfm_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               sms_rfm_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, sms_rfm_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [16:21:59] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.91s
‚ÑπÔ∏è [16:21:59] root INFO: Fetching data to DataFrame
üêõ [16:21:59] root DEBUG: -- Waterfall Report ‚Äì Non-BA Segments (claim & exclude logic)
-- ---------------------------------------------------------------------------
--  Requirements distilled from temp/logic.txt
--  -------------------------------------------------------------
--  ‚Ä¢ Process the ordered list of *segments* for a channel.
--  ‚Ä¢ For each segment N
--        ‚Äì Candidate pool   = population that has NOT been bucketed by a
--                              previous segment (N-1, N-2, ‚Ä¶).
--        ‚Äì Claimed rows     = subset of candidate pool that passes the
--                              segment‚Äôs summary condition.
--        ‚Äì Produce 6 rows of output:
--              0. section="<seg name>", stat_name='Records Claimed'
--              1-5 waterfall metrics (unique_drops, incremental_drops,
--                 cumulative_drops, regain, remaining) evaluated **on the
--                 candidate pool**, not on claimed rows.
--
--  Context provided by WaterfallEngine
--  -------------------------------------------------------------
--    eligibility_table   ‚Äì smart table (aliased as c in conditions)
--    unique_identifiers  ‚Äì list[str]  id columns (possibly qualified)
--    pre_filter          ‚Äì SQL predicate satisfied by *every* row that
--                          reaches this template (main BA + channel BA)
--    segments            ‚Äì ordered list of dicts
--                            name           ‚Äì display label
--                            checks         ‚Äì list[str] flag column names
--                            summary_column ‚Äì SQL predicate defining the
--                                            bucket for the segment
-- ---------------------------------------------------------------------------




    

    


WITH base_population AS (
    SELECT *
    FROM eligibility_poc AS c         -- ‚ñº added AS
    WHERE (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND 1=1
),

-- ---------------------------------------------------------------------------
-- Deduplication (same tie-break rules as full waterfall)
-- ---------------------------------------------------------------------------



    

    


deduped AS (
    SELECT * FROM (
        SELECT bp.*,
               -- total passes in *all* non-BA checks (used for ranking)
               push_promotions_1+push_promotions_2+push_surveys_1 AS pass_cnt,   -- ‚ñº opening tag no ‚Äú-‚Äù
               -- longest left-to-right streak of passes across all checks
               (
                   push_promotions_1 + 
                   push_promotions_1 * push_promotions_2 + 
                   push_promotions_1 * push_promotions_2 * push_surveys_1
                   
               ) AS streak_len,
               ROW_NUMBER() OVER (
                   PARTITION BY region_id, segment_id
                   ORDER BY pass_cnt DESC, streak_len DESC
               ) AS _rn
        FROM base_population AS bp            -- ‚ñº added AS
    ) t
    WHERE _rn = 1
),

-- ---------------------------------------------------------------------------
-- Build per-segment candidate & claimed CTEs
-- ---------------------------------------------------------------------------




seg_pool_0 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
),

seg_claim_0 AS (
    SELECT *
    FROM seg_pool_0 AS sp              -- ‚ñº added AS
    WHERE (push_promotions_1 = 1 AND push_promotions_2 = 1)
),





seg_pool_1 AS (
    SELECT *
    FROM deduped AS d                          -- ‚ñº added AS
    
    
    WHERE 
              NOT ( (push_promotions_1 = 1 AND push_promotions_2 = 1) )
              
          
    
),

seg_claim_1 AS (
    SELECT *
    FROM seg_pool_1 AS sp              -- ‚ñº added AS
    WHERE (push_surveys_1 = 1)
)



-- ---------------------------------------------------------------------------
-- Final SELECT block ‚Äì emit claimed size + 5-metric waterfall per segment
-- ---------------------------------------------------------------------------





-- >>> Segment: push - promotions ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - promotions' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_0

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND ( push_promotions_2 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND ( push_promotions_1 = 1 )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_promotions_1 = 1 AND push_promotions_2 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_1 = 0 AND push_promotions_2 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'regain'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_promotions_2 = 0 AND push_promotions_1 = 1
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    UNION ALL
    
    
    
    SELECT 'push - promotions'                             AS section,
           'remaining'                              AS stat_name,
           'push_promotions_2'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_promotions_1 = 1 AND push_promotions_2 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_promotions_1,push_promotions_2
        FROM seg_pool_0
    ) AS flags(region_id, segment_id, push_promotions_1, push_promotions_2)
    
    
    
) AS metrics

UNION ALL





-- >>> Segment: push - surveys ------------------------------------------------
-- Row 0 ‚Äì records claimed by the segment
SELECT CAST('push - surveys' AS VARCHAR(50))    AS section,
       CAST('Records Claimed' AS VARCHAR(50))   AS stat_name,
       CAST('' AS VARCHAR(50))                  AS check_name,
       COUNT(*)                                 AS cntr
FROM seg_claim_1

UNION ALL

-- Metrics evaluated on the *candidate* pool (seg_pool)
SELECT section,
       stat_name,
       check_name,
       cntr
FROM (
    
    
    
    SELECT 'push - surveys'                             AS section,
           'unique_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'incremental_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'cumulative_drops'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN NOT (  push_surveys_1 = 1  )
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'regain'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN push_surveys_1 = 0
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    UNION ALL
    
    
    
    
    
    SELECT 'push - surveys'                             AS section,
           'remaining'                              AS stat_name,
           'push_surveys_1'                                 AS check_name,
           SUM(
               CASE
                   
                       WHEN  push_surveys_1 = 1 
                       THEN 1
                   
                   ELSE 0
               END
           ) AS cntr
    FROM (
        SELECT region_id,segment_id, 
               push_surveys_1
        FROM seg_pool_1
    ) AS flags(region_id, segment_id, push_surveys_1)
    
    
    
) AS metrics




;
‚ÑπÔ∏è [16:22:00] root INFO: Fetched DataFrame with 17 rows and 4 columns in 0.97s
‚ÑπÔ∏è [16:22:01] root INFO: Consolidated waterfall report written to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/XX001_2025_07_28_16:22:01.xlsx
‚ÑπÔ∏è [16:22:01] root INFO: Waterfall run history appended to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/waterfall/waterfall_history.sqlite
‚ÑπÔ∏è [16:22:01] root INFO: Using cached output steps.
‚ÑπÔ∏è [16:22:01] root INFO: Running output job for channel email
üêõ [16:22:01] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) THEN 'email_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) AND (c.email_promo_1 = 1 AND c.email_promo_2 = 1) THEN 'email_promo'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) AND (c.email_loyalty_1 = 1) AND (c.email_promo_1 = 0 OR c.email_promo_2 = 0) THEN 'email_loyalty'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [16:22:01] root INFO: Fetching data to DataFrame
üêõ [16:22:01] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) THEN 'email_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) AND (c.email_promo_1 = 1 AND c.email_promo_2 = 1) THEN 'email_promo'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.email_BA_1 = 1) AND (c.email_loyalty_1 = 1) AND (c.email_promo_1 = 0 OR c.email_promo_2 = 0) THEN 'email_loyalty'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [16:22:01] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.15s
‚ÑπÔ∏è [16:22:01] root INFO: Fetched 17 rows for channel email
‚ÑπÔ∏è [16:22:01] root INFO: Writing output file for channel email to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/email/email_list.csv
‚ÑπÔ∏è [16:22:01] root INFO: Running output job for channel sms
üêõ [16:22:01] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) THEN 'sms_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_tx_1 = 1 AND c.sms_tx_2 = 1) THEN 'sms_tx'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_rfm_1 = 1) AND (c.sms_tx_1 = 0 OR c.sms_tx_2 = 0) THEN 'sms_rfm'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [16:22:01] root INFO: Fetching data to DataFrame
üêõ [16:22:01] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) THEN 'sms_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_tx_1 = 1 AND c.sms_tx_2 = 1) THEN 'sms_tx'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (c.sms_BA_1 = 1) AND (c.sms_rfm_1 = 1) AND (c.sms_tx_1 = 0 OR c.sms_tx_2 = 0) THEN 'sms_rfm'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [16:22:01] root INFO: Fetched DataFrame with 8 rows and 5 columns in 0.15s
‚ÑπÔ∏è [16:22:01] root INFO: Fetched 8 rows for channel sms
‚ÑπÔ∏è [16:22:01] root INFO: Writing output file for channel sms to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/sms/sms_list.parquet
‚ÑπÔ∏è [16:22:01] root INFO: Running output job for channel push
üêõ [16:22:01] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) THEN 'push_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) AND (c.push_promotions_1 = 1 AND c.push_promotions_2 = 1) THEN 'push_promotions'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) AND (c.push_surveys_1 = 1) AND (c.push_promotions_1 = 0 OR c.push_promotions_2 = 0) THEN 'push_surveys'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [16:22:01] root INFO: Fetching data to DataFrame
üêõ [16:22:01] root DEBUG: -- Jinja2 template for final channel output with "Claim and Exclude" logic and deduplication.
--
-- Context:
--   columns: list of columns to select (e.g. ['c.id', 'c.name', ...])
--   eligibility_table: name of the smart eligibility table.
--   cases: A list of dicts, ordered by priority, for the CASE statement.
--          Each dict: {condition: SQL condition string, template: template_name string}
--   unique_on: A list of columns to partition by for deduplication (e.g., ['c.customer_id']).
--
SELECT
    customer_id,
    account_id,
    region_id,
    segment_id,
    template_id
FROM (
    SELECT
        c.*,
        -- This CASE statement is the core of the "Claim and Exclude" logic.
        -- Because it stops at the first WHEN that is true, the order of the 'cases'
        -- passed from Python enforces the mutual exclusivity.
        CASE
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) THEN 'push_BA'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) AND (c.push_promotions_1 = 1 AND c.push_promotions_2 = 1) THEN 'push_promotions'
            WHEN (c.main_BA_1 = 1 AND c.main_BA_2 = 1) AND (1 = 1) AND (c.push_surveys_1 = 1) AND (c.push_promotions_1 = 0 OR c.push_promotions_2 = 0) THEN 'push_surveys'
            ELSE NULL
        END AS template_id
    FROM eligibility_poc c
) AS assigned
-- Only include records that were successfully claimed by a template.
WHERE template_id IS NOT NULL
-- This QUALIFY clause handles deduplication efficiently in the database.
-- It selects only the first row for each unique entity, based on a deterministic order.
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY template_id) = 1;
‚ÑπÔ∏è [16:22:01] root INFO: Fetched DataFrame with 17 rows and 5 columns in 0.15s
‚ÑπÔ∏è [16:22:01] root INFO: Fetched 17 rows for channel push
‚ÑπÔ∏è [16:22:01] root INFO: Writing output file for channel push to /home/taco/projects/recodeWaterfall/reports/poc/reports/poc/push/push_list.xlsx
‚ÑπÔ∏è [16:22:01] root INFO: Cleaning up DB connection
